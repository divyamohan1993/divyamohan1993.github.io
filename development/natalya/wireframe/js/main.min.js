! function e(t, n, i) {
	function r(a, s) {
		if (!n[a]) {
			if (!t[a]) {
				var c = "function" == typeof require && require;
				if (!s && c) return c(a, !0);
				if (o) return o(a, !0);
				var l = new Error("Cannot find module '" + a + "'");
				throw l.code = "MODULE_NOT_FOUND", l
			}
			var u = n[a] = {
				exports: {}
			};
			t[a][0].call(u.exports, function(e) {
				var n = t[a][1][e];
				return r(n || e)
			}, u, u.exports, e, t, n, i)
		}
		return n[a].exports
	}
	for (var o = "function" == typeof require && require, a = 0; a < i.length; a++) r(i[a]);
	return r
}({
	1: [function(e, t, n) {
		! function(e, i) {
			if ("object" == typeof n && "object" == typeof t) t.exports = i();
			else if ("function" == typeof define && define.amd) define([], i);
			else {
				var r = i();
				for (var o in r)("object" == typeof n ? n : e)[o] = r[o]
			}
		}(this, function() {
			return function(e) {
				function t(i) {
					if (n[i]) return n[i].exports;
					var r = n[i] = {
						i: i,
						l: !1,
						exports: {}
					};
					return e[i].call(r.exports, r, r.exports, t), r.l = !0, r.exports
				}
				var n = {};
				return t.m = e, t.c = n, t.d = function(e, n, i) {
					t.o(e, n) || Object.defineProperty(e, n, {
						configurable: !1,
						enumerable: !0,
						get: i
					})
				}, t.n = function(e) {
					var n = e && e.__esModule ? function() {
						return e.default
					} : function() {
						return e
					};
					return t.d(n, "a", n), n
				}, t.o = function(e, t) {
					return Object.prototype.hasOwnProperty.call(e, t)
				}, t.p = "", t(t.s = 4)
			}([function(e, t, n) {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.setMatrixArrayType = function(e) {
					t.ARRAY_TYPE = r = e
				}, t.toRadian = function(e) {
					return e * o
				}, t.equals = function(e, t) {
					return Math.abs(e - t) <= i * Math.max(1, Math.abs(e), Math.abs(t))
				};
				var i = t.EPSILON = 1e-6,
					r = t.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array,
					o = (t.RANDOM = Math.random, Math.PI / 180)
			}, function(e, t, n) {
				"use strict";

				function i(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = t[6],
						u = t[7],
						h = t[8],
						d = n[0],
						f = n[1],
						v = n[2],
						p = n[3],
						m = n[4],
						g = n[5],
						y = n[6],
						x = n[7],
						b = n[8];
					return e[0] = d * i + f * a + v * l, e[1] = d * r + f * s + v * u, e[2] = d * o + f * c + v * h, e[3] = p * i + m * a + g * l, e[4] = p * r + m * s + g * u, e[5] = p * o + m * c + g * h, e[6] = y * i + x * a + b * l, e[7] = y * r + x * s + b * u, e[8] = y * o + x * c + b * h, e
				}

				function r(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e[6] = t[6] - n[6], e[7] = t[7] - n[7], e[8] = t[8] - n[8], e
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.sub = t.mul = void 0, t.create = function() {
					var e = new o.ARRAY_TYPE(9);
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
				}, t.fromMat4 = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e
				}, t.clone = function(e) {
					var t = new o.ARRAY_TYPE(9);
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
				}, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
				}, t.fromValues = function(e, t, n, i, r, a, s, c, l) {
					var u = new o.ARRAY_TYPE(9);
					return u[0] = e, u[1] = t, u[2] = n, u[3] = i, u[4] = r, u[5] = a, u[6] = s, u[7] = c, u[8] = l, u
				}, t.set = function(e, t, n, i, r, o, a, s, c, l) {
					return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e[4] = o, e[5] = a, e[6] = s, e[7] = c, e[8] = l, e
				}, t.identity = function(e) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
				}, t.transpose = function(e, t) {
					if (e === t) {
						var n = t[1],
							i = t[2],
							r = t[5];
						e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = i, e[7] = r
					} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
					return e
				}, t.invert = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = t[4],
						s = t[5],
						c = t[6],
						l = t[7],
						u = t[8],
						h = u * a - s * l,
						d = -u * o + s * c,
						f = l * o - a * c,
						v = n * h + i * d + r * f;
					return v ? (v = 1 / v, e[0] = h * v, e[1] = (-u * i + r * l) * v, e[2] = (s * i - r * a) * v, e[3] = d * v, e[4] = (u * n - r * c) * v, e[5] = (-s * n + r * o) * v, e[6] = f * v, e[7] = (-l * n + i * c) * v, e[8] = (a * n - i * o) * v, e) : null
				}, t.adjoint = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = t[4],
						s = t[5],
						c = t[6],
						l = t[7],
						u = t[8];
					return e[0] = a * u - s * l, e[1] = r * l - i * u, e[2] = i * s - r * a, e[3] = s * c - o * u, e[4] = n * u - r * c, e[5] = r * o - n * s, e[6] = o * l - a * c, e[7] = i * c - n * l, e[8] = n * a - i * o, e
				}, t.determinant = function(e) {
					var t = e[0],
						n = e[1],
						i = e[2],
						r = e[3],
						o = e[4],
						a = e[5],
						s = e[6],
						c = e[7],
						l = e[8];
					return t * (l * o - a * c) + n * (-l * r + a * s) + i * (c * r - o * s)
				}, t.multiply = i, t.translate = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = t[6],
						u = t[7],
						h = t[8],
						d = n[0],
						f = n[1];
					return e[0] = i, e[1] = r, e[2] = o, e[3] = a, e[4] = s, e[5] = c, e[6] = d * i + f * a + l, e[7] = d * r + f * s + u, e[8] = d * o + f * c + h, e
				}, t.rotate = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = t[6],
						u = t[7],
						h = t[8],
						d = Math.sin(n),
						f = Math.cos(n);
					return e[0] = f * i + d * a, e[1] = f * r + d * s, e[2] = f * o + d * c, e[3] = f * a - d * i, e[4] = f * s - d * r, e[5] = f * c - d * o, e[6] = l, e[7] = u, e[8] = h, e
				}, t.scale = function(e, t, n) {
					var i = n[0],
						r = n[1];
					return e[0] = i * t[0], e[1] = i * t[1], e[2] = i * t[2], e[3] = r * t[3], e[4] = r * t[4], e[5] = r * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
				}, t.fromTranslation = function(e, t) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e
				}, t.fromRotation = function(e, t) {
					var n = Math.sin(t),
						i = Math.cos(t);
					return e[0] = i, e[1] = n, e[2] = 0, e[3] = -n, e[4] = i, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
				}, t.fromScaling = function(e, t) {
					return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
				}, t.fromMat2d = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = t[2], e[4] = t[3], e[5] = 0, e[6] = t[4], e[7] = t[5], e[8] = 1, e
				}, t.fromQuat = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = n + n,
						s = i + i,
						c = r + r,
						l = n * a,
						u = i * a,
						h = i * s,
						d = r * a,
						f = r * s,
						v = r * c,
						p = o * a,
						m = o * s,
						g = o * c;
					return e[0] = 1 - h - v, e[3] = u - g, e[6] = d + m, e[1] = u + g, e[4] = 1 - l - v, e[7] = f - p, e[2] = d - m, e[5] = f + p, e[8] = 1 - l - h, e
				}, t.normalFromMat4 = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = t[4],
						s = t[5],
						c = t[6],
						l = t[7],
						u = t[8],
						h = t[9],
						d = t[10],
						f = t[11],
						v = t[12],
						p = t[13],
						m = t[14],
						g = t[15],
						y = n * s - i * a,
						x = n * c - r * a,
						b = n * l - o * a,
						w = i * c - r * s,
						M = i * l - o * s,
						_ = r * l - o * c,
						S = u * p - h * v,
						E = u * m - d * v,
						T = u * g - f * v,
						P = h * m - d * p,
						A = h * g - f * p,
						L = d * g - f * m,
						C = y * L - x * A + b * P + w * T - M * E + _ * S;
					return C ? (C = 1 / C, e[0] = (s * L - c * A + l * P) * C, e[1] = (c * T - a * L - l * E) * C, e[2] = (a * A - s * T + l * S) * C, e[3] = (r * A - i * L - o * P) * C, e[4] = (n * L - r * T + o * E) * C, e[5] = (i * T - n * A - o * S) * C, e[6] = (p * _ - m * M + g * w) * C, e[7] = (m * b - v * _ - g * x) * C, e[8] = (v * M - p * b + g * y) * C, e) : null
				}, t.projection = function(e, t, n) {
					return e[0] = 2 / t, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / n, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e
				}, t.str = function(e) {
					return "mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")"
				}, t.frob = function(e) {
					return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + Math.pow(e[6], 2) + Math.pow(e[7], 2) + Math.pow(e[8], 2))
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e[8] = t[8] + n[8], e
				}, t.subtract = r, t.multiplyScalar = function(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * n, e
				}, t.multiplyScalarAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e[3] = t[3] + n[3] * i, e[4] = t[4] + n[4] * i, e[5] = t[5] + n[5] * i, e[6] = t[6] + n[6] * i, e[7] = t[7] + n[7] * i, e[8] = t[8] + n[8] * i, e
				}, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = e[2],
						a = e[3],
						s = e[4],
						c = e[5],
						l = e[6],
						u = e[7],
						h = e[8],
						d = t[0],
						f = t[1],
						v = t[2],
						p = t[3],
						m = t[4],
						g = t[5],
						y = t[6],
						x = t[7],
						b = t[8];
					return Math.abs(n - d) <= o.EPSILON * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(i - f) <= o.EPSILON * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(r - v) <= o.EPSILON * Math.max(1, Math.abs(r), Math.abs(v)) && Math.abs(a - p) <= o.EPSILON * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(s - m) <= o.EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(c - g) <= o.EPSILON * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - y) <= o.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - x) <= o.EPSILON * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(h - b) <= o.EPSILON * Math.max(1, Math.abs(h), Math.abs(b))
				};
				var o = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.mul = i, t.sub = r
			}, function(e, t, n) {
				"use strict";

				function i() {
					var e = new v.ARRAY_TYPE(3);
					return e[0] = 0, e[1] = 0, e[2] = 0, e
				}

				function r(e) {
					var t = e[0],
						n = e[1],
						i = e[2];
					return Math.sqrt(t * t + n * n + i * i)
				}

				function o(e, t, n) {
					var i = new v.ARRAY_TYPE(3);
					return i[0] = e, i[1] = t, i[2] = n, i
				}

				function a(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e
				}

				function s(e, t, n) {
					return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e
				}

				function c(e, t, n) {
					return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e
				}

				function l(e, t) {
					var n = t[0] - e[0],
						i = t[1] - e[1],
						r = t[2] - e[2];
					return Math.sqrt(n * n + i * i + r * r)
				}

				function u(e, t) {
					var n = t[0] - e[0],
						i = t[1] - e[1],
						r = t[2] - e[2];
					return n * n + i * i + r * r
				}

				function h(e) {
					var t = e[0],
						n = e[1],
						i = e[2];
					return t * t + n * n + i * i
				}

				function d(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = n * n + i * i + r * r;
					return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o, e[2] = t[2] * o), e
				}

				function f(e, t) {
					return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.forEach = t.sqrLen = t.len = t.sqrDist = t.dist = t.div = t.mul = t.sub = void 0, t.create = i, t.clone = function(e) {
					var t = new v.ARRAY_TYPE(3);
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
				}, t.length = r, t.fromValues = o, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
				}, t.set = function(e, t, n, i) {
					return e[0] = t, e[1] = n, e[2] = i, e
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e
				}, t.subtract = a, t.multiply = s, t.divide = c, t.ceil = function(e, t) {
					return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e
				}, t.floor = function(e, t) {
					return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e
				}, t.min = function(e, t, n) {
					return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e
				}, t.max = function(e, t, n) {
					return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e
				}, t.round = function(e, t) {
					return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e
				}, t.scale = function(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
				}, t.scaleAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e
				}, t.distance = l, t.squaredDistance = u, t.squaredLength = h, t.negate = function(e, t) {
					return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e
				}, t.inverse = function(e, t) {
					return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e
				}, t.normalize = d, t.dot = f, t.cross = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = n[0],
						s = n[1],
						c = n[2];
					return e[0] = r * c - o * s, e[1] = o * a - i * c, e[2] = i * s - r * a, e
				}, t.lerp = function(e, t, n, i) {
					var r = t[0],
						o = t[1],
						a = t[2];
					return e[0] = r + i * (n[0] - r), e[1] = o + i * (n[1] - o), e[2] = a + i * (n[2] - a), e
				}, t.hermite = function(e, t, n, i, r, o) {
					var a = o * o,
						s = a * (2 * o - 3) + 1,
						c = a * (o - 2) + o,
						l = a * (o - 1),
						u = a * (3 - 2 * o);
					return e[0] = t[0] * s + n[0] * c + i[0] * l + r[0] * u, e[1] = t[1] * s + n[1] * c + i[1] * l + r[1] * u, e[2] = t[2] * s + n[2] * c + i[2] * l + r[2] * u, e
				}, t.bezier = function(e, t, n, i, r, o) {
					var a = 1 - o,
						s = a * a,
						c = o * o,
						l = s * a,
						u = 3 * o * s,
						h = 3 * c * a,
						d = c * o;
					return e[0] = t[0] * l + n[0] * u + i[0] * h + r[0] * d, e[1] = t[1] * l + n[1] * u + i[1] * h + r[1] * d, e[2] = t[2] * l + n[2] * u + i[2] * h + r[2] * d, e
				}, t.random = function(e, t) {
					t = t || 1;
					var n = 2 * v.RANDOM() * Math.PI,
						i = 2 * v.RANDOM() - 1,
						r = Math.sqrt(1 - i * i) * t;
					return e[0] = Math.cos(n) * r, e[1] = Math.sin(n) * r, e[2] = i * t, e
				}, t.transformMat4 = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = n[3] * i + n[7] * r + n[11] * o + n[15];
					return a = a || 1, e[0] = (n[0] * i + n[4] * r + n[8] * o + n[12]) / a, e[1] = (n[1] * i + n[5] * r + n[9] * o + n[13]) / a, e[2] = (n[2] * i + n[6] * r + n[10] * o + n[14]) / a, e
				}, t.transformMat3 = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2];
					return e[0] = i * n[0] + r * n[3] + o * n[6], e[1] = i * n[1] + r * n[4] + o * n[7], e[2] = i * n[2] + r * n[5] + o * n[8], e
				}, t.transformQuat = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = n[0],
						s = n[1],
						c = n[2],
						l = n[3],
						u = l * i + s * o - c * r,
						h = l * r + c * i - a * o,
						d = l * o + a * r - s * i,
						f = -a * i - s * r - c * o;
					return e[0] = u * l + f * -a + h * -c - d * -s, e[1] = h * l + f * -s + d * -a - u * -c, e[2] = d * l + f * -c + u * -s - h * -a, e
				}, t.rotateX = function(e, t, n, i) {
					var r = [],
						o = [];
					return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], o[0] = r[0], o[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), o[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e
				}, t.rotateY = function(e, t, n, i) {
					var r = [],
						o = [];
					return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], o[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), o[1] = r[1], o[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e
				}, t.rotateZ = function(e, t, n, i) {
					var r = [],
						o = [];
					return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], o[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), o[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), o[2] = r[2], e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e
				}, t.angle = function(e, t) {
					var n = o(e[0], e[1], e[2]),
						i = o(t[0], t[1], t[2]);
					d(n, n), d(i, i);
					var r = f(n, i);
					return r > 1 ? 0 : r < -1 ? Math.PI : Math.acos(r)
				}, t.str = function(e) {
					return "vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")"
				}, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = e[2],
						o = t[0],
						a = t[1],
						s = t[2];
					return Math.abs(n - o) <= v.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - a) <= v.EPSILON * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - s) <= v.EPSILON * Math.max(1, Math.abs(r), Math.abs(s))
				};
				var v = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.sub = a, t.mul = s, t.div = c, t.dist = l, t.sqrDist = u, t.len = r, t.sqrLen = h, t.forEach = function() {
					var e = i();
					return function(t, n, i, r, o, a) {
						var s = void 0,
							c = void 0;
						for (n || (n = 3), i || (i = 0), c = r ? Math.min(r * n + i, t.length) : t.length, s = i; s < c; s += n) e[0] = t[s], e[1] = t[s + 1], e[2] = t[s + 2], o(e, e, a), t[s] = e[0], t[s + 1] = e[1], t[s + 2] = e[2];
						return t
					}
				}()
			}, function(e, t, n) {
				"use strict";

				function i() {
					var e = new f.ARRAY_TYPE(4);
					return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e
				}

				function r(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e
				}

				function o(e, t, n) {
					return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e[3] = t[3] * n[3], e
				}

				function a(e, t, n) {
					return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e[3] = t[3] / n[3], e
				}

				function s(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
				}

				function c(e, t) {
					var n = t[0] - e[0],
						i = t[1] - e[1],
						r = t[2] - e[2],
						o = t[3] - e[3];
					return Math.sqrt(n * n + i * i + r * r + o * o)
				}

				function l(e, t) {
					var n = t[0] - e[0],
						i = t[1] - e[1],
						r = t[2] - e[2],
						o = t[3] - e[3];
					return n * n + i * i + r * r + o * o
				}

				function u(e) {
					var t = e[0],
						n = e[1],
						i = e[2],
						r = e[3];
					return Math.sqrt(t * t + n * n + i * i + r * r)
				}

				function h(e) {
					var t = e[0],
						n = e[1],
						i = e[2],
						r = e[3];
					return t * t + n * n + i * i + r * r
				}

				function d(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = n * n + i * i + r * r + o * o;
					return a > 0 && (a = 1 / Math.sqrt(a), e[0] = n * a, e[1] = i * a, e[2] = r * a, e[3] = o * a), e
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.forEach = t.sqrLen = t.len = t.sqrDist = t.dist = t.div = t.mul = t.sub = void 0, t.create = i, t.clone = function(e) {
					var t = new f.ARRAY_TYPE(4);
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
				}, t.fromValues = function(e, t, n, i) {
					var r = new f.ARRAY_TYPE(4);
					return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r
				}, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
				}, t.set = function(e, t, n, i, r) {
					return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e
				}, t.subtract = r, t.multiply = o, t.divide = a, t.ceil = function(e, t) {
					return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e
				}, t.floor = function(e, t) {
					return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e
				}, t.min = function(e, t, n) {
					return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e[3] = Math.min(t[3], n[3]), e
				}, t.max = function(e, t, n) {
					return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e[3] = Math.max(t[3], n[3]), e
				}, t.round = function(e, t) {
					return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e
				}, t.scale = s, t.scaleAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e[3] = t[3] + n[3] * i, e
				}, t.distance = c, t.squaredDistance = l, t.length = u, t.squaredLength = h, t.negate = function(e, t) {
					return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e
				}, t.inverse = function(e, t) {
					return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e
				}, t.normalize = d, t.dot = function(e, t) {
					return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
				}, t.lerp = function(e, t, n, i) {
					var r = t[0],
						o = t[1],
						a = t[2],
						s = t[3];
					return e[0] = r + i * (n[0] - r), e[1] = o + i * (n[1] - o), e[2] = a + i * (n[2] - a), e[3] = s + i * (n[3] - s), e
				}, t.random = function(e, t) {
					return t = t || 1, e[0] = f.RANDOM(), e[1] = f.RANDOM(), e[2] = f.RANDOM(), e[3] = f.RANDOM(), d(e, e), s(e, e, t), e
				}, t.transformMat4 = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3];
					return e[0] = n[0] * i + n[4] * r + n[8] * o + n[12] * a, e[1] = n[1] * i + n[5] * r + n[9] * o + n[13] * a, e[2] = n[2] * i + n[6] * r + n[10] * o + n[14] * a, e[3] = n[3] * i + n[7] * r + n[11] * o + n[15] * a, e
				}, t.transformQuat = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = n[0],
						s = n[1],
						c = n[2],
						l = n[3],
						u = l * i + s * o - c * r,
						h = l * r + c * i - a * o,
						d = l * o + a * r - s * i,
						f = -a * i - s * r - c * o;
					return e[0] = u * l + f * -a + h * -c - d * -s, e[1] = h * l + f * -s + d * -a - u * -c, e[2] = d * l + f * -c + u * -s - h * -a, e[3] = t[3], e
				}, t.str = function(e) {
					return "vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
				}, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = e[2],
						o = e[3],
						a = t[0],
						s = t[1],
						c = t[2],
						l = t[3];
					return Math.abs(n - a) <= f.EPSILON * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - s) <= f.EPSILON * Math.max(1, Math.abs(i), Math.abs(s)) && Math.abs(r - c) <= f.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(o - l) <= f.EPSILON * Math.max(1, Math.abs(o), Math.abs(l))
				};
				var f = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.sub = r, t.mul = o, t.div = a, t.dist = c, t.sqrDist = l, t.len = u, t.sqrLen = h, t.forEach = function() {
					var e = i();
					return function(t, n, i, r, o, a) {
						var s = void 0,
							c = void 0;
						for (n || (n = 4), i || (i = 0), c = r ? Math.min(r * n + i, t.length) : t.length, s = i; s < c; s += n) e[0] = t[s], e[1] = t[s + 1], e[2] = t[s + 2], e[3] = t[s + 3], o(e, e, a), t[s] = e[0], t[s + 1] = e[1], t[s + 2] = e[2], t[s + 3] = e[3];
						return t
					}
				}()
			}, function(e, t, n) {
				"use strict";

				function i(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.vec4 = t.vec3 = t.vec2 = t.quat = t.mat4 = t.mat3 = t.mat2d = t.mat2 = t.glMatrix = void 0;
				var r = i(n(0)),
					o = i(n(5)),
					a = i(n(6)),
					s = i(n(1)),
					c = i(n(7)),
					l = i(n(8)),
					u = i(n(9)),
					h = i(n(2)),
					d = i(n(3));
				t.glMatrix = r, t.mat2 = o, t.mat2d = a, t.mat3 = s, t.mat4 = c, t.quat = l, t.vec2 = u, t.vec3 = h, t.vec4 = d
			}, function(e, t, n) {
				"use strict";

				function i(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = n[0],
						c = n[1],
						l = n[2],
						u = n[3];
					return e[0] = i * s + o * c, e[1] = r * s + a * c, e[2] = i * l + o * u, e[3] = r * l + a * u, e
				}

				function r(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.sub = t.mul = void 0, t.create = function() {
					var e = new o.ARRAY_TYPE(4);
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e
				}, t.clone = function(e) {
					var t = new o.ARRAY_TYPE(4);
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
				}, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
				}, t.identity = function(e) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e
				}, t.fromValues = function(e, t, n, i) {
					var r = new o.ARRAY_TYPE(4);
					return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r
				}, t.set = function(e, t, n, i, r) {
					return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e
				}, t.transpose = function(e, t) {
					if (e === t) {
						var n = t[1];
						e[1] = t[2], e[2] = n
					} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];
					return e
				}, t.invert = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = n * o - r * i;
					return a ? (a = 1 / a, e[0] = o * a, e[1] = -i * a, e[2] = -r * a, e[3] = n * a, e) : null
				}, t.adjoint = function(e, t) {
					var n = t[0];
					return e[0] = t[3], e[1] = -t[1], e[2] = -t[2], e[3] = n, e
				}, t.determinant = function(e) {
					return e[0] * e[3] - e[2] * e[1]
				}, t.multiply = i, t.rotate = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = Math.sin(n),
						c = Math.cos(n);
					return e[0] = i * c + o * s, e[1] = r * c + a * s, e[2] = i * -s + o * c, e[3] = r * -s + a * c, e
				}, t.scale = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = n[0],
						c = n[1];
					return e[0] = i * s, e[1] = r * s, e[2] = o * c, e[3] = a * c, e
				}, t.fromRotation = function(e, t) {
					var n = Math.sin(t),
						i = Math.cos(t);
					return e[0] = i, e[1] = n, e[2] = -n, e[3] = i, e
				}, t.fromScaling = function(e, t) {
					return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e
				}, t.str = function(e) {
					return "mat2(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
				}, t.frob = function(e) {
					return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2))
				}, t.LDU = function(e, t, n, i) {
					return e[2] = i[2] / i[0], n[0] = i[0], n[1] = i[1], n[3] = i[3] - e[2] * n[1], [e, t, n]
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e
				}, t.subtract = r, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = e[2],
						a = e[3],
						s = t[0],
						c = t[1],
						l = t[2],
						u = t[3];
					return Math.abs(n - s) <= o.EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(i - c) <= o.EPSILON * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(r - l) <= o.EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(a - u) <= o.EPSILON * Math.max(1, Math.abs(a), Math.abs(u))
				}, t.multiplyScalar = function(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
				}, t.multiplyScalarAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e[3] = t[3] + n[3] * i, e
				};
				var o = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.mul = i, t.sub = r
			}, function(e, t, n) {
				"use strict";

				function i(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = n[0],
						u = n[1],
						h = n[2],
						d = n[3],
						f = n[4],
						v = n[5];
					return e[0] = i * l + o * u, e[1] = r * l + a * u, e[2] = i * h + o * d, e[3] = r * h + a * d, e[4] = i * f + o * v + s, e[5] = r * f + a * v + c, e
				}

				function r(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.sub = t.mul = void 0, t.create = function() {
					var e = new o.ARRAY_TYPE(6);
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e
				}, t.clone = function(e) {
					var t = new o.ARRAY_TYPE(6);
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
				}, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
				}, t.identity = function(e) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e
				}, t.fromValues = function(e, t, n, i, r, a) {
					var s = new o.ARRAY_TYPE(6);
					return s[0] = e, s[1] = t, s[2] = n, s[3] = i, s[4] = r, s[5] = a, s
				}, t.set = function(e, t, n, i, r, o, a) {
					return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e[4] = o, e[5] = a, e
				}, t.invert = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = t[4],
						s = t[5],
						c = n * o - i * r;
					return c ? (c = 1 / c, e[0] = o * c, e[1] = -i * c, e[2] = -r * c, e[3] = n * c, e[4] = (r * s - o * a) * c, e[5] = (i * a - n * s) * c, e) : null
				}, t.determinant = function(e) {
					return e[0] * e[3] - e[1] * e[2]
				}, t.multiply = i, t.rotate = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = Math.sin(n),
						u = Math.cos(n);
					return e[0] = i * u + o * l, e[1] = r * u + a * l, e[2] = i * -l + o * u, e[3] = r * -l + a * u, e[4] = s, e[5] = c, e
				}, t.scale = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = n[0],
						u = n[1];
					return e[0] = i * l, e[1] = r * l, e[2] = o * u, e[3] = a * u, e[4] = s, e[5] = c, e
				}, t.translate = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = n[0],
						u = n[1];
					return e[0] = i, e[1] = r, e[2] = o, e[3] = a, e[4] = i * l + o * u + s, e[5] = r * l + a * u + c, e
				}, t.fromRotation = function(e, t) {
					var n = Math.sin(t),
						i = Math.cos(t);
					return e[0] = i, e[1] = n, e[2] = -n, e[3] = i, e[4] = 0, e[5] = 0, e
				}, t.fromScaling = function(e, t) {
					return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e[4] = 0, e[5] = 0, e
				}, t.fromTranslation = function(e, t) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0], e[5] = t[1], e
				}, t.str = function(e) {
					return "mat2d(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ")"
				}, t.frob = function(e) {
					return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + 1)
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e
				}, t.subtract = r, t.multiplyScalar = function(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e
				}, t.multiplyScalarAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e[3] = t[3] + n[3] * i, e[4] = t[4] + n[4] * i, e[5] = t[5] + n[5] * i, e
				}, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = e[2],
						a = e[3],
						s = e[4],
						c = e[5],
						l = t[0],
						u = t[1],
						h = t[2],
						d = t[3],
						f = t[4],
						v = t[5];
					return Math.abs(n - l) <= o.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(i - u) <= o.EPSILON * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(r - h) <= o.EPSILON * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(a - d) <= o.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(s - f) <= o.EPSILON * Math.max(1, Math.abs(s), Math.abs(f)) && Math.abs(c - v) <= o.EPSILON * Math.max(1, Math.abs(c), Math.abs(v))
				};
				var o = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.mul = i, t.sub = r
			}, function(e, t, n) {
				"use strict";

				function i(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = t[4],
						c = t[5],
						l = t[6],
						u = t[7],
						h = t[8],
						d = t[9],
						f = t[10],
						v = t[11],
						p = t[12],
						m = t[13],
						g = t[14],
						y = t[15],
						x = n[0],
						b = n[1],
						w = n[2],
						M = n[3];
					return e[0] = x * i + b * s + w * h + M * p, e[1] = x * r + b * c + w * d + M * m, e[2] = x * o + b * l + w * f + M * g, e[3] = x * a + b * u + w * v + M * y, x = n[4], b = n[5], w = n[6], M = n[7], e[4] = x * i + b * s + w * h + M * p, e[5] = x * r + b * c + w * d + M * m, e[6] = x * o + b * l + w * f + M * g, e[7] = x * a + b * u + w * v + M * y, x = n[8], b = n[9], w = n[10], M = n[11], e[8] = x * i + b * s + w * h + M * p, e[9] = x * r + b * c + w * d + M * m, e[10] = x * o + b * l + w * f + M * g, e[11] = x * a + b * u + w * v + M * y, x = n[12], b = n[13], w = n[14], M = n[15], e[12] = x * i + b * s + w * h + M * p, e[13] = x * r + b * c + w * d + M * m, e[14] = x * o + b * l + w * f + M * g, e[15] = x * a + b * u + w * v + M * y, e
				}

				function r(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e[6] = t[6] - n[6], e[7] = t[7] - n[7], e[8] = t[8] - n[8], e[9] = t[9] - n[9], e[10] = t[10] - n[10], e[11] = t[11] - n[11], e[12] = t[12] - n[12], e[13] = t[13] - n[13], e[14] = t[14] - n[14], e[15] = t[15] - n[15], e
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.sub = t.mul = void 0, t.create = function() {
					var e = new o.ARRAY_TYPE(16);
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.clone = function(e) {
					var t = new o.ARRAY_TYPE(16);
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
				}, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
				}, t.fromValues = function(e, t, n, i, r, a, s, c, l, u, h, d, f, v, p, m) {
					var g = new o.ARRAY_TYPE(16);
					return g[0] = e, g[1] = t, g[2] = n, g[3] = i, g[4] = r, g[5] = a, g[6] = s, g[7] = c, g[8] = l, g[9] = u, g[10] = h, g[11] = d, g[12] = f, g[13] = v, g[14] = p, g[15] = m, g
				}, t.set = function(e, t, n, i, r, o, a, s, c, l, u, h, d, f, v, p, m) {
					return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e[4] = o, e[5] = a, e[6] = s, e[7] = c, e[8] = l, e[9] = u, e[10] = h, e[11] = d, e[12] = f, e[13] = v, e[14] = p, e[15] = m, e
				}, t.identity = function(e) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.transpose = function(e, t) {
					if (e === t) {
						var n = t[1],
							i = t[2],
							r = t[3],
							o = t[6],
							a = t[7],
							s = t[11];
						e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = i, e[9] = o, e[11] = t[14], e[12] = r, e[13] = a, e[14] = s
					} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
					return e
				}, t.invert = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = t[4],
						s = t[5],
						c = t[6],
						l = t[7],
						u = t[8],
						h = t[9],
						d = t[10],
						f = t[11],
						v = t[12],
						p = t[13],
						m = t[14],
						g = t[15],
						y = n * s - i * a,
						x = n * c - r * a,
						b = n * l - o * a,
						w = i * c - r * s,
						M = i * l - o * s,
						_ = r * l - o * c,
						S = u * p - h * v,
						E = u * m - d * v,
						T = u * g - f * v,
						P = h * m - d * p,
						A = h * g - f * p,
						L = d * g - f * m,
						C = y * L - x * A + b * P + w * T - M * E + _ * S;
					return C ? (C = 1 / C, e[0] = (s * L - c * A + l * P) * C, e[1] = (r * A - i * L - o * P) * C, e[2] = (p * _ - m * M + g * w) * C, e[3] = (d * M - h * _ - f * w) * C, e[4] = (c * T - a * L - l * E) * C, e[5] = (n * L - r * T + o * E) * C, e[6] = (m * b - v * _ - g * x) * C, e[7] = (u * _ - d * b + f * x) * C, e[8] = (a * A - s * T + l * S) * C, e[9] = (i * T - n * A - o * S) * C, e[10] = (v * M - p * b + g * y) * C, e[11] = (h * b - u * M - f * y) * C, e[12] = (s * E - a * P - c * S) * C, e[13] = (n * P - i * E + r * S) * C, e[14] = (p * x - v * w - m * y) * C, e[15] = (u * w - h * x + d * y) * C, e) : null
				}, t.adjoint = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = t[4],
						s = t[5],
						c = t[6],
						l = t[7],
						u = t[8],
						h = t[9],
						d = t[10],
						f = t[11],
						v = t[12],
						p = t[13],
						m = t[14],
						g = t[15];
					return e[0] = s * (d * g - f * m) - h * (c * g - l * m) + p * (c * f - l * d), e[1] = -(i * (d * g - f * m) - h * (r * g - o * m) + p * (r * f - o * d)), e[2] = i * (c * g - l * m) - s * (r * g - o * m) + p * (r * l - o * c), e[3] = -(i * (c * f - l * d) - s * (r * f - o * d) + h * (r * l - o * c)), e[4] = -(a * (d * g - f * m) - u * (c * g - l * m) + v * (c * f - l * d)), e[5] = n * (d * g - f * m) - u * (r * g - o * m) + v * (r * f - o * d), e[6] = -(n * (c * g - l * m) - a * (r * g - o * m) + v * (r * l - o * c)), e[7] = n * (c * f - l * d) - a * (r * f - o * d) + u * (r * l - o * c), e[8] = a * (h * g - f * p) - u * (s * g - l * p) + v * (s * f - l * h), e[9] = -(n * (h * g - f * p) - u * (i * g - o * p) + v * (i * f - o * h)), e[10] = n * (s * g - l * p) - a * (i * g - o * p) + v * (i * l - o * s), e[11] = -(n * (s * f - l * h) - a * (i * f - o * h) + u * (i * l - o * s)), e[12] = -(a * (h * m - d * p) - u * (s * m - c * p) + v * (s * d - c * h)), e[13] = n * (h * m - d * p) - u * (i * m - r * p) + v * (i * d - r * h), e[14] = -(n * (s * m - c * p) - a * (i * m - r * p) + v * (i * c - r * s)), e[15] = n * (s * d - c * h) - a * (i * d - r * h) + u * (i * c - r * s), e
				}, t.determinant = function(e) {
					var t = e[0],
						n = e[1],
						i = e[2],
						r = e[3],
						o = e[4],
						a = e[5],
						s = e[6],
						c = e[7],
						l = e[8],
						u = e[9],
						h = e[10],
						d = e[11],
						f = e[12],
						v = e[13],
						p = e[14],
						m = e[15];
					return (t * a - n * o) * (h * m - d * p) - (t * s - i * o) * (u * m - d * v) + (t * c - r * o) * (u * p - h * v) + (n * s - i * a) * (l * m - d * f) - (n * c - r * a) * (l * p - h * f) + (i * c - r * s) * (l * v - u * f)
				}, t.multiply = i, t.translate = function(e, t, n) {
					var i = n[0],
						r = n[1],
						o = n[2],
						a = void 0,
						s = void 0,
						c = void 0,
						l = void 0,
						u = void 0,
						h = void 0,
						d = void 0,
						f = void 0,
						v = void 0,
						p = void 0,
						m = void 0,
						g = void 0;
					return t === e ? (e[12] = t[0] * i + t[4] * r + t[8] * o + t[12], e[13] = t[1] * i + t[5] * r + t[9] * o + t[13], e[14] = t[2] * i + t[6] * r + t[10] * o + t[14], e[15] = t[3] * i + t[7] * r + t[11] * o + t[15]) : (a = t[0], s = t[1], c = t[2], l = t[3], u = t[4], h = t[5], d = t[6], f = t[7], v = t[8], p = t[9], m = t[10], g = t[11], e[0] = a, e[1] = s, e[2] = c, e[3] = l, e[4] = u, e[5] = h, e[6] = d, e[7] = f, e[8] = v, e[9] = p, e[10] = m, e[11] = g, e[12] = a * i + u * r + v * o + t[12], e[13] = s * i + h * r + p * o + t[13], e[14] = c * i + d * r + m * o + t[14], e[15] = l * i + f * r + g * o + t[15]), e
				}, t.scale = function(e, t, n) {
					var i = n[0],
						r = n[1],
						o = n[2];
					return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = t[11] * o, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
				}, t.rotate = function(e, t, n, i) {
					var r = i[0],
						a = i[1],
						s = i[2],
						c = Math.sqrt(r * r + a * a + s * s),
						l = void 0,
						u = void 0,
						h = void 0,
						d = void 0,
						f = void 0,
						v = void 0,
						p = void 0,
						m = void 0,
						g = void 0,
						y = void 0,
						x = void 0,
						b = void 0,
						w = void 0,
						M = void 0,
						_ = void 0,
						S = void 0,
						E = void 0,
						T = void 0,
						P = void 0,
						A = void 0,
						L = void 0,
						C = void 0,
						z = void 0,
						R = void 0;
					return Math.abs(c) < o.EPSILON ? null : (c = 1 / c, r *= c, a *= c, s *= c, l = Math.sin(n), u = Math.cos(n), h = 1 - u, d = t[0], f = t[1], v = t[2], p = t[3], m = t[4], g = t[5], y = t[6], x = t[7], b = t[8], w = t[9], M = t[10], _ = t[11], S = r * r * h + u, E = a * r * h + s * l, T = s * r * h - a * l, P = r * a * h - s * l, A = a * a * h + u, L = s * a * h + r * l, C = r * s * h + a * l, z = a * s * h - r * l, R = s * s * h + u, e[0] = d * S + m * E + b * T, e[1] = f * S + g * E + w * T, e[2] = v * S + y * E + M * T, e[3] = p * S + x * E + _ * T, e[4] = d * P + m * A + b * L, e[5] = f * P + g * A + w * L, e[6] = v * P + y * A + M * L, e[7] = p * P + x * A + _ * L, e[8] = d * C + m * z + b * R, e[9] = f * C + g * z + w * R, e[10] = v * C + y * z + M * R, e[11] = p * C + x * z + _ * R, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e)
				}, t.rotateX = function(e, t, n) {
					var i = Math.sin(n),
						r = Math.cos(n),
						o = t[4],
						a = t[5],
						s = t[6],
						c = t[7],
						l = t[8],
						u = t[9],
						h = t[10],
						d = t[11];
					return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = o * r + l * i, e[5] = a * r + u * i, e[6] = s * r + h * i, e[7] = c * r + d * i, e[8] = l * r - o * i, e[9] = u * r - a * i, e[10] = h * r - s * i, e[11] = d * r - c * i, e
				}, t.rotateY = function(e, t, n) {
					var i = Math.sin(n),
						r = Math.cos(n),
						o = t[0],
						a = t[1],
						s = t[2],
						c = t[3],
						l = t[8],
						u = t[9],
						h = t[10],
						d = t[11];
					return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * r - l * i, e[1] = a * r - u * i, e[2] = s * r - h * i, e[3] = c * r - d * i, e[8] = o * i + l * r, e[9] = a * i + u * r, e[10] = s * i + h * r, e[11] = c * i + d * r, e
				}, t.rotateZ = function(e, t, n) {
					var i = Math.sin(n),
						r = Math.cos(n),
						o = t[0],
						a = t[1],
						s = t[2],
						c = t[3],
						l = t[4],
						u = t[5],
						h = t[6],
						d = t[7];
					return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * r + l * i, e[1] = a * r + u * i, e[2] = s * r + h * i, e[3] = c * r + d * i, e[4] = l * r - o * i, e[5] = u * r - a * i, e[6] = h * r - s * i, e[7] = d * r - c * i, e
				}, t.fromTranslation = function(e, t) {
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e
				}, t.fromScaling = function(e, t) {
					return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.fromRotation = function(e, t, n) {
					var i = n[0],
						r = n[1],
						a = n[2],
						s = Math.sqrt(i * i + r * r + a * a),
						c = void 0,
						l = void 0,
						u = void 0;
					return Math.abs(s) < o.EPSILON ? null : (s = 1 / s, i *= s, r *= s, a *= s, c = Math.sin(t), l = Math.cos(t), u = 1 - l, e[0] = i * i * u + l, e[1] = r * i * u + a * c, e[2] = a * i * u - r * c, e[3] = 0, e[4] = i * r * u - a * c, e[5] = r * r * u + l, e[6] = a * r * u + i * c, e[7] = 0, e[8] = i * a * u + r * c, e[9] = r * a * u - i * c, e[10] = a * a * u + l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e)
				}, t.fromXRotation = function(e, t) {
					var n = Math.sin(t),
						i = Math.cos(t);
					return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = n, e[7] = 0, e[8] = 0, e[9] = -n, e[10] = i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.fromYRotation = function(e, t) {
					var n = Math.sin(t),
						i = Math.cos(t);
					return e[0] = i, e[1] = 0, e[2] = -n, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = n, e[9] = 0, e[10] = i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.fromZRotation = function(e, t) {
					var n = Math.sin(t),
						i = Math.cos(t);
					return e[0] = i, e[1] = n, e[2] = 0, e[3] = 0, e[4] = -n, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.fromRotationTranslation = function(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = i + i,
						c = r + r,
						l = o + o,
						u = i * s,
						h = i * c,
						d = i * l,
						f = r * c,
						v = r * l,
						p = o * l,
						m = a * s,
						g = a * c,
						y = a * l;
					return e[0] = 1 - (f + p), e[1] = h + y, e[2] = d - g, e[3] = 0, e[4] = h - y, e[5] = 1 - (u + p), e[6] = v + m, e[7] = 0, e[8] = d + g, e[9] = v - m, e[10] = 1 - (u + f), e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e
				}, t.getTranslation = function(e, t) {
					return e[0] = t[12], e[1] = t[13], e[2] = t[14], e
				}, t.getScaling = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[4],
						a = t[5],
						s = t[6],
						c = t[8],
						l = t[9],
						u = t[10];
					return e[0] = Math.sqrt(n * n + i * i + r * r), e[1] = Math.sqrt(o * o + a * a + s * s), e[2] = Math.sqrt(c * c + l * l + u * u), e
				}, t.getRotation = function(e, t) {
					var n = t[0] + t[5] + t[10],
						i = 0;
					return n > 0 ? (i = 2 * Math.sqrt(n + 1), e[3] = .25 * i, e[0] = (t[6] - t[9]) / i, e[1] = (t[8] - t[2]) / i, e[2] = (t[1] - t[4]) / i) : t[0] > t[5] & t[0] > t[10] ? (i = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / i, e[0] = .25 * i, e[1] = (t[1] + t[4]) / i, e[2] = (t[8] + t[2]) / i) : t[5] > t[10] ? (i = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / i, e[0] = (t[1] + t[4]) / i, e[1] = .25 * i, e[2] = (t[6] + t[9]) / i) : (i = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / i, e[0] = (t[8] + t[2]) / i, e[1] = (t[6] + t[9]) / i, e[2] = .25 * i), e
				}, t.fromRotationTranslationScale = function(e, t, n, i) {
					var r = t[0],
						o = t[1],
						a = t[2],
						s = t[3],
						c = r + r,
						l = o + o,
						u = a + a,
						h = r * c,
						d = r * l,
						f = r * u,
						v = o * l,
						p = o * u,
						m = a * u,
						g = s * c,
						y = s * l,
						x = s * u,
						b = i[0],
						w = i[1],
						M = i[2];
					return e[0] = (1 - (v + m)) * b, e[1] = (d + x) * b, e[2] = (f - y) * b, e[3] = 0, e[4] = (d - x) * w, e[5] = (1 - (h + m)) * w, e[6] = (p + g) * w, e[7] = 0, e[8] = (f + y) * M, e[9] = (p - g) * M, e[10] = (1 - (h + v)) * M, e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e
				}, t.fromRotationTranslationScaleOrigin = function(e, t, n, i, r) {
					var o = t[0],
						a = t[1],
						s = t[2],
						c = t[3],
						l = o + o,
						u = a + a,
						h = s + s,
						d = o * l,
						f = o * u,
						v = o * h,
						p = a * u,
						m = a * h,
						g = s * h,
						y = c * l,
						x = c * u,
						b = c * h,
						w = i[0],
						M = i[1],
						_ = i[2],
						S = r[0],
						E = r[1],
						T = r[2];
					return e[0] = (1 - (p + g)) * w, e[1] = (f + b) * w, e[2] = (v - x) * w, e[3] = 0, e[4] = (f - b) * M, e[5] = (1 - (d + g)) * M, e[6] = (m + y) * M, e[7] = 0, e[8] = (v + x) * _, e[9] = (m - y) * _, e[10] = (1 - (d + p)) * _, e[11] = 0, e[12] = n[0] + S - (e[0] * S + e[4] * E + e[8] * T), e[13] = n[1] + E - (e[1] * S + e[5] * E + e[9] * T), e[14] = n[2] + T - (e[2] * S + e[6] * E + e[10] * T), e[15] = 1, e
				}, t.fromQuat = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = n + n,
						s = i + i,
						c = r + r,
						l = n * a,
						u = i * a,
						h = i * s,
						d = r * a,
						f = r * s,
						v = r * c,
						p = o * a,
						m = o * s,
						g = o * c;
					return e[0] = 1 - h - v, e[1] = u + g, e[2] = d - m, e[3] = 0, e[4] = u - g, e[5] = 1 - l - v, e[6] = f + p, e[7] = 0, e[8] = d + m, e[9] = f - p, e[10] = 1 - l - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
				}, t.frustum = function(e, t, n, i, r, o, a) {
					var s = 1 / (n - t),
						c = 1 / (r - i),
						l = 1 / (o - a);
					return e[0] = 2 * o * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * o * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * s, e[9] = (r + i) * c, e[10] = (a + o) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = a * o * 2 * l, e[15] = 0, e
				}, t.perspective = function(e, t, n, i, r) {
					var o = 1 / Math.tan(t / 2),
						a = 1 / (i - r);
					return e[0] = o / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (r + i) * a, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * r * i * a, e[15] = 0, e
				}, t.perspectiveFromFieldOfView = function(e, t, n, i) {
					var r = Math.tan(t.upDegrees * Math.PI / 180),
						o = Math.tan(t.downDegrees * Math.PI / 180),
						a = Math.tan(t.leftDegrees * Math.PI / 180),
						s = Math.tan(t.rightDegrees * Math.PI / 180),
						c = 2 / (a + s),
						l = 2 / (r + o);
					return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = l, e[6] = 0, e[7] = 0, e[8] = -(a - s) * c * .5, e[9] = (r - o) * l * .5, e[10] = i / (n - i), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = i * n / (n - i), e[15] = 0, e
				}, t.ortho = function(e, t, n, i, r, o, a) {
					var s = 1 / (t - n),
						c = 1 / (i - r),
						l = 1 / (o - a);
					return e[0] = -2 * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * l, e[11] = 0, e[12] = (t + n) * s, e[13] = (r + i) * c, e[14] = (a + o) * l, e[15] = 1, e
				}, t.lookAt = function(e, t, n, i) {
					var r = void 0,
						a = void 0,
						s = void 0,
						c = void 0,
						l = void 0,
						u = void 0,
						h = void 0,
						d = void 0,
						f = void 0,
						v = void 0,
						p = t[0],
						m = t[1],
						g = t[2],
						y = i[0],
						x = i[1],
						b = i[2],
						w = n[0],
						M = n[1],
						_ = n[2];
					return Math.abs(p - w) < o.EPSILON && Math.abs(m - M) < o.EPSILON && Math.abs(g - _) < o.EPSILON ? mat4.identity(e) : (h = p - w, d = m - M, f = g - _, v = 1 / Math.sqrt(h * h + d * d + f * f), h *= v, d *= v, f *= v, r = x * f - b * d, a = b * h - y * f, s = y * d - x * h, (v = Math.sqrt(r * r + a * a + s * s)) ? (r *= v = 1 / v, a *= v, s *= v) : (r = 0, a = 0, s = 0), c = d * s - f * a, l = f * r - h * s, u = h * a - d * r, (v = Math.sqrt(c * c + l * l + u * u)) ? (c *= v = 1 / v, l *= v, u *= v) : (c = 0, l = 0, u = 0), e[0] = r, e[1] = c, e[2] = h, e[3] = 0, e[4] = a, e[5] = l, e[6] = d, e[7] = 0, e[8] = s, e[9] = u, e[10] = f, e[11] = 0, e[12] = -(r * p + a * m + s * g), e[13] = -(c * p + l * m + u * g), e[14] = -(h * p + d * m + f * g), e[15] = 1, e)
				}, t.targetTo = function(e, t, n, i) {
					var r = t[0],
						o = t[1],
						a = t[2],
						s = i[0],
						c = i[1],
						l = i[2],
						u = r - n[0],
						h = o - n[1],
						d = a - n[2],
						f = u * u + h * h + d * d;
					f > 0 && (u *= f = 1 / Math.sqrt(f), h *= f, d *= f);
					var v = c * d - l * h,
						p = l * u - s * d,
						m = s * h - c * u;
					return e[0] = v, e[1] = p, e[2] = m, e[3] = 0, e[4] = h * m - d * p, e[5] = d * v - u * m, e[6] = u * p - h * v, e[7] = 0, e[8] = u, e[9] = h, e[10] = d, e[11] = 0, e[12] = r, e[13] = o, e[14] = a, e[15] = 1, e
				}, t.str = function(e) {
					return "mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")"
				}, t.frob = function(e) {
					return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + Math.pow(e[6], 2) + Math.pow(e[7], 2) + Math.pow(e[8], 2) + Math.pow(e[9], 2) + Math.pow(e[10], 2) + Math.pow(e[11], 2) + Math.pow(e[12], 2) + Math.pow(e[13], 2) + Math.pow(e[14], 2) + Math.pow(e[15], 2))
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e[8] = t[8] + n[8], e[9] = t[9] + n[9], e[10] = t[10] + n[10], e[11] = t[11] + n[11], e[12] = t[12] + n[12], e[13] = t[13] + n[13], e[14] = t[14] + n[14], e[15] = t[15] + n[15], e
				}, t.subtract = r, t.multiplyScalar = function(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * n, e[9] = t[9] * n, e[10] = t[10] * n, e[11] = t[11] * n, e[12] = t[12] * n, e[13] = t[13] * n, e[14] = t[14] * n, e[15] = t[15] * n, e
				}, t.multiplyScalarAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e[3] = t[3] + n[3] * i, e[4] = t[4] + n[4] * i, e[5] = t[5] + n[5] * i, e[6] = t[6] + n[6] * i, e[7] = t[7] + n[7] * i, e[8] = t[8] + n[8] * i, e[9] = t[9] + n[9] * i, e[10] = t[10] + n[10] * i, e[11] = t[11] + n[11] * i, e[12] = t[12] + n[12] * i, e[13] = t[13] + n[13] * i, e[14] = t[14] + n[14] * i, e[15] = t[15] + n[15] * i, e
				}, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = e[2],
						a = e[3],
						s = e[4],
						c = e[5],
						l = e[6],
						u = e[7],
						h = e[8],
						d = e[9],
						f = e[10],
						v = e[11],
						p = e[12],
						m = e[13],
						g = e[14],
						y = e[15],
						x = t[0],
						b = t[1],
						w = t[2],
						M = t[3],
						_ = t[4],
						S = t[5],
						E = t[6],
						T = t[7],
						P = t[8],
						A = t[9],
						L = t[10],
						C = t[11],
						z = t[12],
						R = t[13],
						I = t[14],
						j = t[15];
					return Math.abs(n - x) <= o.EPSILON * Math.max(1, Math.abs(n), Math.abs(x)) && Math.abs(i - b) <= o.EPSILON * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(r - w) <= o.EPSILON * Math.max(1, Math.abs(r), Math.abs(w)) && Math.abs(a - M) <= o.EPSILON * Math.max(1, Math.abs(a), Math.abs(M)) && Math.abs(s - _) <= o.EPSILON * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(c - S) <= o.EPSILON * Math.max(1, Math.abs(c), Math.abs(S)) && Math.abs(l - E) <= o.EPSILON * Math.max(1, Math.abs(l), Math.abs(E)) && Math.abs(u - T) <= o.EPSILON * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(h - P) <= o.EPSILON * Math.max(1, Math.abs(h), Math.abs(P)) && Math.abs(d - A) <= o.EPSILON * Math.max(1, Math.abs(d), Math.abs(A)) && Math.abs(f - L) <= o.EPSILON * Math.max(1, Math.abs(f), Math.abs(L)) && Math.abs(v - C) <= o.EPSILON * Math.max(1, Math.abs(v), Math.abs(C)) && Math.abs(p - z) <= o.EPSILON * Math.max(1, Math.abs(p), Math.abs(z)) && Math.abs(m - R) <= o.EPSILON * Math.max(1, Math.abs(m), Math.abs(R)) && Math.abs(g - I) <= o.EPSILON * Math.max(1, Math.abs(g), Math.abs(I)) && Math.abs(y - j) <= o.EPSILON * Math.max(1, Math.abs(y), Math.abs(j))
				};
				var o = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.mul = i, t.sub = r
			}, function(e, t, n) {
				"use strict";

				function i(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}

				function r() {
					var e = new l.ARRAY_TYPE(4);
					return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
				}

				function o(e, t, n) {
					n *= .5;
					var i = Math.sin(n);
					return e[0] = i * t[0], e[1] = i * t[1], e[2] = i * t[2], e[3] = Math.cos(n), e
				}

				function a(e, t, n) {
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = n[0],
						c = n[1],
						l = n[2],
						u = n[3];
					return e[0] = i * u + a * s + r * l - o * c, e[1] = r * u + a * c + o * s - i * l, e[2] = o * u + a * l + i * c - r * s, e[3] = a * u - i * s - r * c - o * l, e
				}

				function s(e, t, n, i) {
					var r = t[0],
						o = t[1],
						a = t[2],
						s = t[3],
						c = n[0],
						l = n[1],
						u = n[2],
						h = n[3],
						d = void 0,
						f = void 0,
						v = void 0,
						p = void 0,
						m = void 0;
					return (f = r * c + o * l + a * u + s * h) < 0 && (f = -f, c = -c, l = -l, u = -u, h = -h), 1 - f > 1e-6 ? (d = Math.acos(f), v = Math.sin(d), p = Math.sin((1 - i) * d) / v, m = Math.sin(i * d) / v) : (p = 1 - i, m = i), e[0] = p * r + m * c, e[1] = p * o + m * l, e[2] = p * a + m * u, e[3] = p * s + m * h, e
				}

				function c(e, t) {
					var n = t[0] + t[4] + t[8],
						i = void 0;
					if (n > 0) i = Math.sqrt(n + 1), e[3] = .5 * i, i = .5 / i, e[0] = (t[5] - t[7]) * i, e[1] = (t[6] - t[2]) * i, e[2] = (t[1] - t[3]) * i;
					else {
						var r = 0;
						t[4] > t[0] && (r = 1), t[8] > t[3 * r + r] && (r = 2);
						var o = (r + 1) % 3,
							a = (r + 2) % 3;
						i = Math.sqrt(t[3 * r + r] - t[3 * o + o] - t[3 * a + a] + 1), e[r] = .5 * i, i = .5 / i, e[3] = (t[3 * o + a] - t[3 * a + o]) * i, e[o] = (t[3 * o + r] + t[3 * r + o]) * i, e[a] = (t[3 * a + r] + t[3 * r + a]) * i
					}
					return e
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.setAxes = t.sqlerp = t.rotationTo = t.equals = t.exactEquals = t.normalize = t.sqrLen = t.squaredLength = t.len = t.length = t.lerp = t.dot = t.scale = t.mul = t.add = t.set = t.copy = t.fromValues = t.clone = void 0, t.create = r, t.identity = function(e) {
					return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
				}, t.setAxisAngle = o, t.getAxisAngle = function(e, t) {
					var n = 2 * Math.acos(t[3]),
						i = Math.sin(n / 2);
					return 0 != i ? (e[0] = t[0] / i, e[1] = t[1] / i, e[2] = t[2] / i) : (e[0] = 1, e[1] = 0, e[2] = 0), n
				}, t.multiply = a, t.rotateX = function(e, t, n) {
					n *= .5;
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = Math.sin(n),
						c = Math.cos(n);
					return e[0] = i * c + a * s, e[1] = r * c + o * s, e[2] = o * c - r * s, e[3] = a * c - i * s, e
				}, t.rotateY = function(e, t, n) {
					n *= .5;
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = Math.sin(n),
						c = Math.cos(n);
					return e[0] = i * c - o * s, e[1] = r * c + a * s, e[2] = o * c + i * s, e[3] = a * c - r * s, e
				}, t.rotateZ = function(e, t, n) {
					n *= .5;
					var i = t[0],
						r = t[1],
						o = t[2],
						a = t[3],
						s = Math.sin(n),
						c = Math.cos(n);
					return e[0] = i * c + r * s, e[1] = r * c - i * s, e[2] = o * c + a * s, e[3] = a * c - o * s, e
				}, t.calculateW = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2];
					return e[0] = n, e[1] = i, e[2] = r, e[3] = Math.sqrt(Math.abs(1 - n * n - i * i - r * r)), e
				}, t.slerp = s, t.invert = function(e, t) {
					var n = t[0],
						i = t[1],
						r = t[2],
						o = t[3],
						a = n * n + i * i + r * r + o * o,
						s = a ? 1 / a : 0;
					return e[0] = -n * s, e[1] = -i * s, e[2] = -r * s, e[3] = o * s, e
				}, t.conjugate = function(e, t) {
					return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e
				}, t.fromMat3 = c, t.fromEuler = function(e, t, n, i) {
					var r = .5 * Math.PI / 180;
					t *= r, n *= r, i *= r;
					var o = Math.sin(t),
						a = Math.cos(t),
						s = Math.sin(n),
						c = Math.cos(n),
						l = Math.sin(i),
						u = Math.cos(i);
					return e[0] = o * c * u - a * s * l, e[1] = a * s * u + o * c * l, e[2] = a * c * l - o * s * u, e[3] = a * c * u + o * s * l, e
				}, t.str = function(e) {
					return "quat(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
				};
				var l = i(n(0)),
					u = i(n(1)),
					h = i(n(2)),
					d = i(n(3)),
					f = (t.clone = d.clone, t.fromValues = d.fromValues, t.copy = d.copy, t.set = d.set, t.add = d.add, t.mul = a, t.scale = d.scale, t.dot = d.dot, t.lerp = d.lerp, t.length = d.length),
					v = (t.len = f, t.squaredLength = d.squaredLength),
					p = (t.sqrLen = v, t.normalize = d.normalize);
				t.exactEquals = d.exactEquals, t.equals = d.equals, t.rotationTo = function() {
					var e = h.create(),
						t = h.fromValues(1, 0, 0),
						n = h.fromValues(0, 1, 0);
					return function(i, r, a) {
						var s = h.dot(r, a);
						return s < -.999999 ? (h.cross(e, t, r), h.len(e) < 1e-6 && h.cross(e, n, r), h.normalize(e, e), o(i, e, Math.PI), i) : s > .999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : (h.cross(e, r, a), i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = 1 + s, p(i, i))
					}
				}(), t.sqlerp = function() {
					var e = r(),
						t = r();
					return function(n, i, r, o, a, c) {
						return s(e, i, a, c), s(t, r, o, c), s(n, e, t, 2 * c * (1 - c)), n
					}
				}(), t.setAxes = function() {
					var e = u.create();
					return function(t, n, i, r) {
						return e[0] = i[0], e[3] = i[1], e[6] = i[2], e[1] = r[0], e[4] = r[1], e[7] = r[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], p(t, c(t, e))
					}
				}()
			}, function(e, t, n) {
				"use strict";

				function i() {
					var e = new h.ARRAY_TYPE(2);
					return e[0] = 0, e[1] = 0, e
				}

				function r(e, t, n) {
					return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e
				}

				function o(e, t, n) {
					return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e
				}

				function a(e, t, n) {
					return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e
				}

				function s(e, t) {
					var n = t[0] - e[0],
						i = t[1] - e[1];
					return Math.sqrt(n * n + i * i)
				}

				function c(e, t) {
					var n = t[0] - e[0],
						i = t[1] - e[1];
					return n * n + i * i
				}

				function l(e) {
					var t = e[0],
						n = e[1];
					return Math.sqrt(t * t + n * n)
				}

				function u(e) {
					var t = e[0],
						n = e[1];
					return t * t + n * n
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.forEach = t.sqrLen = t.sqrDist = t.dist = t.div = t.mul = t.sub = t.len = void 0, t.create = i, t.clone = function(e) {
					var t = new h.ARRAY_TYPE(2);
					return t[0] = e[0], t[1] = e[1], t
				}, t.fromValues = function(e, t) {
					var n = new h.ARRAY_TYPE(2);
					return n[0] = e, n[1] = t, n
				}, t.copy = function(e, t) {
					return e[0] = t[0], e[1] = t[1], e
				}, t.set = function(e, t, n) {
					return e[0] = t, e[1] = n, e
				}, t.add = function(e, t, n) {
					return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e
				}, t.subtract = r, t.multiply = o, t.divide = a, t.ceil = function(e, t) {
					return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e
				}, t.floor = function(e, t) {
					return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e
				}, t.min = function(e, t, n) {
					return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e
				}, t.max = function(e, t, n) {
					return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e
				}, t.round = function(e, t) {
					return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e
				}, t.scale = function(e, t, n) {
					return e[0] = t[0] * n, e[1] = t[1] * n, e
				}, t.scaleAndAdd = function(e, t, n, i) {
					return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e
				}, t.distance = s, t.squaredDistance = c, t.length = l, t.squaredLength = u, t.negate = function(e, t) {
					return e[0] = -t[0], e[1] = -t[1], e
				}, t.inverse = function(e, t) {
					return e[0] = 1 / t[0], e[1] = 1 / t[1], e
				}, t.normalize = function(e, t) {
					var n = t[0],
						i = t[1],
						r = n * n + i * i;
					return r > 0 && (r = 1 / Math.sqrt(r), e[0] = t[0] * r, e[1] = t[1] * r), e
				}, t.dot = function(e, t) {
					return e[0] * t[0] + e[1] * t[1]
				}, t.cross = function(e, t, n) {
					var i = t[0] * n[1] - t[1] * n[0];
					return e[0] = e[1] = 0, e[2] = i, e
				}, t.lerp = function(e, t, n, i) {
					var r = t[0],
						o = t[1];
					return e[0] = r + i * (n[0] - r), e[1] = o + i * (n[1] - o), e
				}, t.random = function(e, t) {
					t = t || 1;
					var n = 2 * h.RANDOM() * Math.PI;
					return e[0] = Math.cos(n) * t, e[1] = Math.sin(n) * t, e
				}, t.transformMat2 = function(e, t, n) {
					var i = t[0],
						r = t[1];
					return e[0] = n[0] * i + n[2] * r, e[1] = n[1] * i + n[3] * r, e
				}, t.transformMat2d = function(e, t, n) {
					var i = t[0],
						r = t[1];
					return e[0] = n[0] * i + n[2] * r + n[4], e[1] = n[1] * i + n[3] * r + n[5], e
				}, t.transformMat3 = function(e, t, n) {
					var i = t[0],
						r = t[1];
					return e[0] = n[0] * i + n[3] * r + n[6], e[1] = n[1] * i + n[4] * r + n[7], e
				}, t.transformMat4 = function(e, t, n) {
					var i = t[0],
						r = t[1];
					return e[0] = n[0] * i + n[4] * r + n[12], e[1] = n[1] * i + n[5] * r + n[13], e
				}, t.str = function(e) {
					return "vec2(" + e[0] + ", " + e[1] + ")"
				}, t.exactEquals = function(e, t) {
					return e[0] === t[0] && e[1] === t[1]
				}, t.equals = function(e, t) {
					var n = e[0],
						i = e[1],
						r = t[0],
						o = t[1];
					return Math.abs(n - r) <= h.EPSILON * Math.max(1, Math.abs(n), Math.abs(r)) && Math.abs(i - o) <= h.EPSILON * Math.max(1, Math.abs(i), Math.abs(o))
				};
				var h = function(e) {
					if (e && e.__esModule) return e;
					var t = {};
					if (null != e)
						for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t.default = e, t
				}(n(0));
				t.len = l, t.sub = r, t.mul = o, t.div = a, t.dist = s, t.sqrDist = c, t.sqrLen = u, t.forEach = function() {
					var e = i();
					return function(t, n, i, r, o, a) {
						var s = void 0,
							c = void 0;
						for (n || (n = 2), i || (i = 0), c = r ? Math.min(r * n + i, t.length) : t.length, s = i; s < c; s += n) e[0] = t[s], e[1] = t[s + 1], o(e, e, a), t[s] = e[0], t[s + 1] = e[1];
						return t
					}
				}()
			}])
		})
	}, {}],
	2: [function(e, t, n) {
		t.exports = function(e) {
			"string" == typeof e && (e = [e]);
			for (var t = [].slice.call(arguments, 1), n = [], i = 0; i < e.length - 1; i++) n.push(e[i], t[i] || "");
			return n.push(e[i]), n.join("")
		}
	}, {}],
	3: [function(e, t, n) {
		t.exports = {
			degrees: function(e) {
				return e / Math.PI * 180
			},
			radians: function(e) {
				return e * Math.PI / 180
			},
			clamp: function(e, t, n) {
				return Math.min(Math.max(e, t), n)
			},
			mix: function(e, t, n) {
				return e * (1 - n) + t * n
			},
			spherical: function(e, t, n) {
				return [Math.cos(e) * Math.cos(t) * n, Math.sin(e) * n, Math.cos(e) * Math.sin(t) * n]
			},
			randomArbitrary: function(e, t) {
				return Math.random() * (t - e) + e
			},
			randomInt: function(e, t) {
				return Math.floor(Math.random() * (t - e + 1)) + e
			}
		}
	}, {}],
	4: [function(e, t, n) {
		t.exports = function(e, t) {
			var n;
			return function(i) {
				clearTimeout(n), n = setTimeout(function() {
					e(i)
				}, t)
			}
		}
	}, {}],
	5: [function(e, t, n) {
		t.exports = function() {
			return navigator.userAgent.indexOf("Android") >= 0
		}
	}, {}],
	6: [function(e, t, n) {
		t.exports = function() {
			var e = navigator.userAgent;
			return e.indexOf("MSIE") > -1 || e.indexOf("rv:11.0") > -1
		}
	}, {}],
	7: [function(e, t, n) {
		t.exports = function() {
			var e = navigator.userAgent;
			return e.indexOf("iPhone") >= 0 || e.indexOf("iPod") >= 0 || e.indexOf("iPad") >= 0
		}
	}, {}],
	8: [function(e, t, n) {
		! function(e, i) {
			"object" == typeof n && void 0 !== t ? i(n) : "function" == typeof define && define.amd ? define(["exports"], i) : i(e.THREE = {})
		}(this, function(e) {
			"use strict";

			function t() {}

			function n(e, t) {
				this.x = e || 0, this.y = t || 0
			}

			function i() {
				this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
			}

			function r(e, t, n, i) {
				this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
			}

			function o(e, t, n) {
				this.x = e || 0, this.y = t || 0, this.z = n || 0
			}

			function a() {
				this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
			}

			function s(e, t, i, r, o, c, l, u, h, d) {
				Object.defineProperty(this, "id", {
					value: ys++
				}), this.uuid = gs.generateUUID(), this.name = "", this.image = void 0 !== e ? e : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : s.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : ba, this.wrapT = void 0 !== r ? r : ba, this.magFilter = void 0 !== o ? o : Ea, this.minFilter = void 0 !== c ? c : Pa, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== l ? l : Ga, this.type = void 0 !== u ? u : Aa, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.center = new n(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new a, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : cs, this.version = 0, this.onUpdate = null
			}

			function c(e, t, n, i) {
				this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
			}

			function l(e, t, n) {
				this.uuid = gs.generateUUID(), this.width = e, this.height = t, this.scissor = new c(0, 0, e, t), this.scissorTest = !1, this.viewport = new c(0, 0, e, t), void 0 === (n = n || {}).minFilter && (n.minFilter = Ea), this.texture = new s(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
			}

			function u(e, t, n) {
				l.call(this, e, t, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
			}

			function h(e, t, n, i, r, o, a, c, l, u, h, d) {
				s.call(this, null, o, a, c, l, u, i, r, h, d), this.image = {
					data: e,
					width: t,
					height: n
				}, this.magFilter = void 0 !== l ? l : Ma, this.minFilter = void 0 !== u ? u : Ma, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
			}

			function d(e, t, n, i, r, o, a, c, l, u) {
				e = void 0 !== e ? e : [], t = void 0 !== t ? t : da, s.call(this, e, t, n, i, r, o, a, c, l, u), this.flipY = !1
			}

			function f() {
				this.seq = [], this.map = {}
			}

			function v(e, t, n) {
				var i = e[0];
				if (i <= 0 || i > 0) return e;
				var r = t * n,
					o = ws[r];
				if (void 0 === o && (o = new Float32Array(r), ws[r] = o), 0 !== t) {
					i.toArray(o, 0);
					for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s)
				}
				return o
			}

			function p(e, t) {
				var n = Ms[t];
				void 0 === n && (n = new Int32Array(t), Ms[t] = n);
				for (var i = 0; i !== t; ++i) n[i] = e.allocTextureUnit();
				return n
			}

			function m(e, t) {
				e.uniform1f(this.addr, t)
			}

			function g(e, t) {
				e.uniform1i(this.addr, t)
			}

			function y(e, t) {
				void 0 === t.x ? e.uniform2fv(this.addr, t) : e.uniform2f(this.addr, t.x, t.y)
			}

			function x(e, t) {
				void 0 !== t.x ? e.uniform3f(this.addr, t.x, t.y, t.z) : void 0 !== t.r ? e.uniform3f(this.addr, t.r, t.g, t.b) : e.uniform3fv(this.addr, t)
			}

			function b(e, t) {
				void 0 === t.x ? e.uniform4fv(this.addr, t) : e.uniform4f(this.addr, t.x, t.y, t.z, t.w)
			}

			function w(e, t) {
				e.uniformMatrix2fv(this.addr, !1, t.elements || t)
			}

			function M(e, t) {
				void 0 === t.elements ? e.uniformMatrix3fv(this.addr, !1, t) : (Ss.set(t.elements), e.uniformMatrix3fv(this.addr, !1, Ss))
			}

			function _(e, t) {
				void 0 === t.elements ? e.uniformMatrix4fv(this.addr, !1, t) : (_s.set(t.elements), e.uniformMatrix4fv(this.addr, !1, _s))
			}

			function S(e, t, n) {
				var i = n.allocTextureUnit();
				e.uniform1i(this.addr, i), n.setTexture2D(t || xs, i)
			}

			function E(e, t, n) {
				var i = n.allocTextureUnit();
				e.uniform1i(this.addr, i), n.setTextureCube(t || bs, i)
			}

			function T(e, t) {
				e.uniform2iv(this.addr, t)
			}

			function P(e, t) {
				e.uniform3iv(this.addr, t)
			}

			function A(e, t) {
				e.uniform4iv(this.addr, t)
			}

			function L(e) {
				switch (e) {
					case 5126:
						return m;
					case 35664:
						return y;
					case 35665:
						return x;
					case 35666:
						return b;
					case 35674:
						return w;
					case 35675:
						return M;
					case 35676:
						return _;
					case 35678:
					case 36198:
						return S;
					case 35680:
						return E;
					case 5124:
					case 35670:
						return g;
					case 35667:
					case 35671:
						return T;
					case 35668:
					case 35672:
						return P;
					case 35669:
					case 35673:
						return A
				}
			}

			function C(e, t) {
				e.uniform1fv(this.addr, t)
			}

			function z(e, t) {
				e.uniform1iv(this.addr, t)
			}

			function R(e, t) {
				e.uniform2fv(this.addr, v(t, this.size, 2))
			}

			function I(e, t) {
				e.uniform3fv(this.addr, v(t, this.size, 3))
			}

			function j(e, t) {
				e.uniform4fv(this.addr, v(t, this.size, 4))
			}

			function O(e, t) {
				e.uniformMatrix2fv(this.addr, !1, v(t, this.size, 4))
			}

			function D(e, t) {
				e.uniformMatrix3fv(this.addr, !1, v(t, this.size, 9))
			}

			function F(e, t) {
				e.uniformMatrix4fv(this.addr, !1, v(t, this.size, 16))
			}

			function U(e, t, n) {
				var i = t.length,
					r = p(n, i);
				e.uniform1iv(this.addr, r);
				for (var o = 0; o !== i; ++o) n.setTexture2D(t[o] || xs, r[o])
			}

			function k(e, t, n) {
				var i = t.length,
					r = p(n, i);
				e.uniform1iv(this.addr, r);
				for (var o = 0; o !== i; ++o) n.setTextureCube(t[o] || bs, r[o])
			}

			function N(e) {
				switch (e) {
					case 5126:
						return C;
					case 35664:
						return R;
					case 35665:
						return I;
					case 35666:
						return j;
					case 35674:
						return O;
					case 35675:
						return D;
					case 35676:
						return F;
					case 35678:
						return U;
					case 35680:
						return k;
					case 5124:
					case 35670:
						return z;
					case 35667:
					case 35671:
						return T;
					case 35668:
					case 35672:
						return P;
					case 35669:
					case 35673:
						return A
				}
			}

			function B(e, t, n) {
				this.id = e, this.addr = n, this.setValue = L(t.type)
			}

			function G(e, t, n) {
				this.id = e, this.addr = n, this.size = t.size, this.setValue = N(t.type)
			}

			function H(e) {
				this.id = e, f.call(this)
			}

			function V(e, t) {
				e.seq.push(t), e.map[t.id] = t
			}

			function W(e, t, n) {
				var i = e.name,
					r = i.length;
				for (Es.lastIndex = 0;;) {
					var o = Es.exec(i),
						a = Es.lastIndex,
						s = o[1],
						c = "]" === o[2],
						l = o[3];
					if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === r) {
						V(n, void 0 === l ? new B(s, e, t) : new G(s, e, t));
						break
					}
					var u = n.map[s];
					void 0 === u && V(n, u = new H(s)), n = u
				}
			}

			function Y(e, t, n) {
				f.call(this), this.renderer = n;
				for (var i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), r = 0; r < i; ++r) {
					var o = e.getActiveUniform(t, r),
						a = o.name;
					W(o, e.getUniformLocation(t, a), this)
				}
			}

			function X(e, t, n) {
				return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
			}

			function q(e, t) {
				this.min = void 0 !== e ? e : new n(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new n(-1 / 0, -1 / 0)
			}

			function Z(e, t, i, r, a) {
				function s() {
					var e = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
						n = new Uint16Array([0, 1, 2, 0, 2, 3]);
					l = t.createBuffer(), u = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferData(t.ARRAY_BUFFER, e, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, u), t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW), p = t.createTexture(), m = t.createTexture(), i.bindTexture(t.TEXTURE_2D, p), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 16, 16, 0, t.RGB, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), i.bindTexture(t.TEXTURE_2D, m), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 16, 16, 0, t.RGBA, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), h = {
						vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tvUV = uv;", "\tvec2 pos = position;", "\tif ( renderType == 2 ) {", "\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "\t\tvVisibility =        visibility.r / 9.0;", "\t\tvVisibility *= 1.0 - visibility.g / 9.0;", "\t\tvVisibility *=       visibility.b / 9.0;", "\t\tvVisibility *= 1.0 - visibility.a / 9.0;", "\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "\t}", "\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
						fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tif ( renderType == 0 ) {", "\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "\t} else if ( renderType == 1 ) {", "\t\tgl_FragColor = texture2D( map, vUV );", "\t} else {", "\t\tvec4 texture = texture2D( map, vUV );", "\t\ttexture.a *= opacity * vVisibility;", "\t\tgl_FragColor = texture;", "\t\tgl_FragColor.rgb *= color;", "\t}", "}"].join("\n")
					}, d = c(h), f = {
						vertex: t.getAttribLocation(d, "position"),
						uv: t.getAttribLocation(d, "uv")
					}, v = {
						renderType: t.getUniformLocation(d, "renderType"),
						map: t.getUniformLocation(d, "map"),
						occlusionMap: t.getUniformLocation(d, "occlusionMap"),
						opacity: t.getUniformLocation(d, "opacity"),
						color: t.getUniformLocation(d, "color"),
						scale: t.getUniformLocation(d, "scale"),
						rotation: t.getUniformLocation(d, "rotation"),
						screenPosition: t.getUniformLocation(d, "screenPosition")
					}
				}

				function c(e) {
					var n = t.createProgram(),
						i = t.createShader(t.FRAGMENT_SHADER),
						r = t.createShader(t.VERTEX_SHADER),
						o = "precision " + a.precision + " float;\n";
					return t.shaderSource(i, o + e.fragmentShader), t.shaderSource(r, o + e.vertexShader), t.compileShader(i), t.compileShader(r), t.attachShader(n, i), t.attachShader(n, r), t.linkProgram(n), n
				}
				var l, u, h, d, f, v, p, m;
				this.render = function(e, a, c, h) {
					if (0 !== e.length) {
						var g = new o,
							y = h.w / h.z,
							x = .5 * h.z,
							b = .5 * h.w,
							w = 16 / h.w,
							M = new n(w * y, w),
							_ = new o(1, 1, 0),
							S = new n(1, 1),
							E = new q;
						E.min.set(h.x, h.y), E.max.set(h.x + (h.z - 16), h.y + (h.w - 16)), void 0 === d && s(), i.useProgram(d), i.initAttributes(), i.enableAttribute(f.vertex), i.enableAttribute(f.uv), i.disableUnusedAttributes(), t.uniform1i(v.occlusionMap, 0), t.uniform1i(v.map, 1), t.bindBuffer(t.ARRAY_BUFFER, l), t.vertexAttribPointer(f.vertex, 2, t.FLOAT, !1, 16, 0), t.vertexAttribPointer(f.uv, 2, t.FLOAT, !1, 16, 8), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, u), i.disable(t.CULL_FACE), i.buffers.depth.setMask(!1);
						for (var T = 0, P = e.length; T < P; T++) {
							w = 16 / h.w, M.set(w * y, w);
							var A = e[T];
							if (g.set(A.matrixWorld.elements[12], A.matrixWorld.elements[13], A.matrixWorld.elements[14]), g.applyMatrix4(c.matrixWorldInverse), g.applyMatrix4(c.projectionMatrix), _.copy(g), S.x = h.x + _.x * x + x - 8, S.y = h.y + _.y * b + b - 8, !0 === E.containsPoint(S)) {
								i.activeTexture(t.TEXTURE0), i.bindTexture(t.TEXTURE_2D, null), i.activeTexture(t.TEXTURE1), i.bindTexture(t.TEXTURE_2D, p), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGB, S.x, S.y, 16, 16, 0), t.uniform1i(v.renderType, 0), t.uniform2f(v.scale, M.x, M.y), t.uniform3f(v.screenPosition, _.x, _.y, _.z), i.disable(t.BLEND), i.enable(t.DEPTH_TEST), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), i.activeTexture(t.TEXTURE0), i.bindTexture(t.TEXTURE_2D, m), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, S.x, S.y, 16, 16, 0), t.uniform1i(v.renderType, 1), i.disable(t.DEPTH_TEST), i.activeTexture(t.TEXTURE1), i.bindTexture(t.TEXTURE_2D, p), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), A.positionScreen.copy(_), A.customUpdateCallback ? A.customUpdateCallback(A) : A.updateLensFlares(), t.uniform1i(v.renderType, 2), i.enable(t.BLEND);
								for (var L = 0, C = A.lensFlares.length; L < C; L++) {
									var z = A.lensFlares[L];
									z.opacity > .001 && z.scale > .001 && (_.x = z.x, _.y = z.y, _.z = z.z, w = z.size * z.scale / h.w, M.x = w * y, M.y = w, t.uniform3f(v.screenPosition, _.x, _.y, _.z), t.uniform2f(v.scale, M.x, M.y), t.uniform1f(v.rotation, z.rotation), t.uniform1f(v.opacity, z.opacity), t.uniform3f(v.color, z.color.r, z.color.g, z.color.b), i.setBlending(z.blending, z.blendEquation, z.blendSrc, z.blendDst), r.setTexture2D(z.texture, 1), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0))
								}
							}
						}
						i.enable(t.CULL_FACE), i.enable(t.DEPTH_TEST), i.buffers.depth.setMask(!0), i.reset()
					}
				}
			}

			function K(e, t, n, i, r, o, a, c, l) {
				s.call(this, e, t, n, i, r, o, a, c, l), this.needsUpdate = !0
			}

			function J(e, t, n, i, a) {
				function s() {
					var e = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
						n = new Uint16Array([0, 1, 2, 0, 2, 3]);
					u = t.createBuffer(), h = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, u), t.bufferData(t.ARRAY_BUFFER, e, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, h), t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW), d = c(), f = {
						position: t.getAttribLocation(d, "position"),
						uv: t.getAttribLocation(d, "uv")
					}, v = {
						uvOffset: t.getUniformLocation(d, "uvOffset"),
						uvScale: t.getUniformLocation(d, "uvScale"),
						rotation: t.getUniformLocation(d, "rotation"),
						scale: t.getUniformLocation(d, "scale"),
						color: t.getUniformLocation(d, "color"),
						map: t.getUniformLocation(d, "map"),
						opacity: t.getUniformLocation(d, "opacity"),
						modelViewMatrix: t.getUniformLocation(d, "modelViewMatrix"),
						projectionMatrix: t.getUniformLocation(d, "projectionMatrix"),
						fogType: t.getUniformLocation(d, "fogType"),
						fogDensity: t.getUniformLocation(d, "fogDensity"),
						fogNear: t.getUniformLocation(d, "fogNear"),
						fogFar: t.getUniformLocation(d, "fogFar"),
						fogColor: t.getUniformLocation(d, "fogColor"),
						fogDepth: t.getUniformLocation(d, "fogDepth"),
						alphaTest: t.getUniformLocation(d, "alphaTest")
					};
					var i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
					i.width = 8, i.height = 8;
					var r = i.getContext("2d");
					r.fillStyle = "white", r.fillRect(0, 0, 8, 8), p = new K(i)
				}

				function c() {
					var e = t.createProgram(),
						n = t.createShader(t.VERTEX_SHADER),
						i = t.createShader(t.FRAGMENT_SHADER);
					return t.shaderSource(n, ["precision " + a.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = position * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")), t.shaderSource(i, ["precision " + a.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")), t.compileShader(n), t.compileShader(i), t.attachShader(e, n), t.attachShader(e, i), t.linkProgram(e), e
				}

				function l(e, t) {
					return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : t.id - e.id
				}
				var u, h, d, f, v, p, m = new o,
					g = new r,
					y = new o;
				this.render = function(r, o, a) {
					if (0 !== r.length) {
						void 0 === d && s(), n.useProgram(d), n.initAttributes(), n.enableAttribute(f.position), n.enableAttribute(f.uv), n.disableUnusedAttributes(), n.disable(t.CULL_FACE), n.enable(t.BLEND), t.bindBuffer(t.ARRAY_BUFFER, u), t.vertexAttribPointer(f.position, 2, t.FLOAT, !1, 16, 0), t.vertexAttribPointer(f.uv, 2, t.FLOAT, !1, 16, 8), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, h), t.uniformMatrix4fv(v.projectionMatrix, !1, a.projectionMatrix.elements), n.activeTexture(t.TEXTURE0), t.uniform1i(v.map, 0);
						var c = 0,
							x = 0,
							b = o.fog;
						b ? (t.uniform3f(v.fogColor, b.color.r, b.color.g, b.color.b), b.isFog ? (t.uniform1f(v.fogNear, b.near), t.uniform1f(v.fogFar, b.far), t.uniform1i(v.fogType, 1), c = 1, x = 1) : b.isFogExp2 && (t.uniform1f(v.fogDensity, b.density), t.uniform1i(v.fogType, 2), c = 2, x = 2)) : (t.uniform1i(v.fogType, 0), c = 0, x = 0);
						for (var w = 0, M = r.length; w < M; w++)(S = r[w]).modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, S.matrixWorld), S.z = -S.modelViewMatrix.elements[14];
						r.sort(l);
						for (var _ = [], w = 0, M = r.length; w < M; w++) {
							var S = r[w],
								E = S.material;
							if (!1 !== E.visible) {
								S.onBeforeRender(e, o, a, void 0, E, void 0), t.uniform1f(v.alphaTest, E.alphaTest), t.uniformMatrix4fv(v.modelViewMatrix, !1, S.modelViewMatrix.elements), S.matrixWorld.decompose(m, g, y), _[0] = y.x, _[1] = y.y;
								var T = 0;
								o.fog && E.fog && (T = x), c !== T && (t.uniform1i(v.fogType, T), c = T), null !== E.map ? (t.uniform2f(v.uvOffset, E.map.offset.x, E.map.offset.y), t.uniform2f(v.uvScale, E.map.repeat.x, E.map.repeat.y)) : (t.uniform2f(v.uvOffset, 0, 0), t.uniform2f(v.uvScale, 1, 1)), t.uniform1f(v.opacity, E.opacity), t.uniform3f(v.color, E.color.r, E.color.g, E.color.b), t.uniform1f(v.rotation, E.rotation), t.uniform2fv(v.scale, _), n.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst, E.blendEquationAlpha, E.blendSrcAlpha, E.blendDstAlpha, E.premultipliedAlpha), n.buffers.depth.setTest(E.depthTest), n.buffers.depth.setMask(E.depthWrite), n.buffers.color.setMask(E.colorWrite), i.setTexture2D(E.map || p, 0), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), S.onAfterRender(e, o, a, void 0, E, void 0)
							}
						}
						n.enable(t.CULL_FACE), n.reset()
					}
				}
			}

			function Q() {
				Object.defineProperty(this, "id", {
					value: zs++
				}), this.uuid = gs.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Lo, this.side = Mo, this.flatShading = !1, this.vertexColors = Eo, this.opacity = 1, this.transparent = !1, this.blendSrc = Ho, this.blendDst = Vo, this.blendEquation = jo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = $o, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
			}

			function $(e) {
				Q.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ps, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
			}

			function ee(e) {
				Q.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new o, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e)
			}

			function te(e, t) {
				this.min = void 0 !== e ? e : new o(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new o(-1 / 0, -1 / 0, -1 / 0)
			}

			function ne(e, t) {
				this.center = void 0 !== e ? e : new o, this.radius = void 0 !== t ? t : 0
			}

			function ie(e, t) {
				this.normal = void 0 !== e ? e : new o(1, 0, 0), this.constant = void 0 !== t ? t : 0
			}

			function re(e, t, n, i, r, o) {
				this.planes = [void 0 !== e ? e : new ie, void 0 !== t ? t : new ie, void 0 !== n ? n : new ie, void 0 !== i ? i : new ie, void 0 !== r ? r : new ie, void 0 !== o ? o : new ie]
			}

			function oe(e, t, r) {
				function a(t, n, i, r, o, a) {
					var s = t.geometry,
						c = null,
						l = x,
						u = t.customDepthMaterial;
					if (i && (l = b, u = t.customDistanceMaterial), u) c = u;
					else {
						var h = !1;
						n.morphTargets && (s && s.isBufferGeometry ? h = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (h = s.morphTargets && s.morphTargets.length > 0)), t.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
						var d = t.isSkinnedMesh && n.skinning,
							f = 0;
						h && (f |= m), d && (f |= g), c = l[f]
					}
					if (e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
						var v = c.uuid,
							p = n.uuid,
							y = w[v];
						void 0 === y && (y = {}, w[v] = y);
						var M = y[p];
						void 0 === M && (M = c.clone(), y[p] = M), c = M
					}
					c.visible = n.visible, c.wireframe = n.wireframe;
					var _ = n.side;
					return C.renderSingleSided && _ == So && (_ = Mo), C.renderReverseSided && (_ === Mo ? _ = _o : _ === _o && (_ = Mo)), c.side = _, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, i && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = o, c.farDistance = a), c
				}

				function s(n, i, r, o) {
					if (!1 !== n.visible) {
						if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || u.intersectsObject(n))) {
							n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld);
							var c = t.update(n),
								l = n.material;
							if (Array.isArray(l))
								for (var h = c.groups, d = 0, f = h.length; d < f; d++) {
									var v = h[d],
										m = l[v.materialIndex];
									if (m && m.visible) {
										g = a(n, m, o, p, r.near, r.far);
										e.renderBufferDirect(r, null, c, g, n, v)
									}
								} else if (l.visible) {
									var g = a(n, l, o, p, r.near, r.far);
									e.renderBufferDirect(r, null, c, g, n, null)
								}
						}
						for (var y = n.children, x = 0, b = y.length; x < b; x++) s(y[x], i, r, o)
					}
				}
				for (var u = new re, h = new i, d = new n, f = new n(r, r), v = new o, p = new o, m = 1, g = 2, y = 1 + (m | g), x = new Array(y), b = new Array(y), w = {}, M = [new o(1, 0, 0), new o(-1, 0, 0), new o(0, 0, 1), new o(0, 0, -1), new o(0, 1, 0), new o(0, -1, 0)], _ = [new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 0, 1), new o(0, 0, -1)], S = [new c, new c, new c, new c, new c, new c], E = 0; E !== y; ++E) {
					var T = 0 != (E & m),
						P = 0 != (E & g),
						A = new $({
							depthPacking: ms,
							morphTargets: T,
							skinning: P
						});
					x[E] = A;
					var L = new ee({
						morphTargets: T,
						skinning: P
					});
					b[E] = L
				}
				var C = this;
				this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = bo, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(t, n, i) {
					if (!1 !== C.enabled && (!1 !== C.autoUpdate || !1 !== C.needsUpdate) && 0 !== t.length) {
						var r = e.context,
							o = e.state;
						o.disable(r.BLEND), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
						for (var a, c = 0, m = t.length; c < m; c++) {
							var g = t[c],
								y = g.shadow,
								x = g && g.isPointLight;
							if (void 0 !== y) {
								var b = y.camera;
								if (d.copy(y.mapSize), d.min(f), x) {
									var w = d.x,
										E = d.y;
									S[0].set(2 * w, E, w, E), S[1].set(0, E, w, E), S[2].set(3 * w, E, w, E), S[3].set(w, E, w, E), S[4].set(3 * w, 0, w, E), S[5].set(w, 0, w, E), d.x *= 4, d.y *= 2
								}
								if (null === y.map) {
									var T = {
										minFilter: Ma,
										magFilter: Ma,
										format: Ga
									};
									y.map = new l(d.x, d.y, T), y.map.texture.name = g.name + ".shadowMap", b.updateProjectionMatrix()
								}
								y.isSpotLightShadow && y.update(g);
								var P = y.map,
									A = y.matrix;
								p.setFromMatrixPosition(g.matrixWorld), b.position.copy(p), x ? (a = 6, A.makeTranslation(-p.x, -p.y, -p.z)) : (a = 1, v.setFromMatrixPosition(g.target.matrixWorld), b.lookAt(v), b.updateMatrixWorld(), A.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), A.multiply(b.projectionMatrix), A.multiply(b.matrixWorldInverse)), e.setRenderTarget(P), e.clear();
								for (var L = 0; L < a; L++) {
									if (x) {
										v.copy(b.position), v.add(M[L]), b.up.copy(_[L]), b.lookAt(v), b.updateMatrixWorld();
										var z = S[L];
										o.viewport(z)
									}
									h.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), u.setFromMatrix(h), s(n, i, b, x)
								}
							} else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
						}
						C.needsUpdate = !1
					}
				}
			}

			function ae(e) {
				function t(t, n) {
					var i = t.array,
						r = t.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW,
						o = e.createBuffer();
					e.bindBuffer(n, o), e.bufferData(n, i, r), t.onUploadCallback();
					var a = e.FLOAT;
					return i instanceof Float32Array ? a = e.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = e.UNSIGNED_SHORT : i instanceof Int16Array ? a = e.SHORT : i instanceof Uint32Array ? a = e.UNSIGNED_INT : i instanceof Int32Array ? a = e.INT : i instanceof Int8Array ? a = e.BYTE : i instanceof Uint8Array && (a = e.UNSIGNED_BYTE), {
						buffer: o,
						type: a,
						bytesPerElement: i.BYTES_PER_ELEMENT,
						version: t.version
					}
				}

				function n(t, n, i) {
					var r = n.array,
						o = n.updateRange;
					e.bindBuffer(i, t), !1 === n.dynamic ? e.bufferData(i, r, e.STATIC_DRAW) : -1 === o.count ? e.bufferSubData(i, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
				}
				var i = {};
				return {
					get: function(e) {
						return e.isInterleavedBufferAttribute && (e = e.data), i[e.uuid]
					},
					remove: function(t) {
						t.isInterleavedBufferAttribute && (t = t.data);
						var n = i[t.uuid];
						n && (e.deleteBuffer(n.buffer), delete i[t.uuid])
					},
					update: function(e, r) {
						e.isInterleavedBufferAttribute && (e = e.data);
						var o = i[e.uuid];
						void 0 === o ? i[e.uuid] = t(e, r) : o.version < e.version && (n(o.buffer, e, r), o.version = e.version)
					}
				}
			}

			function se(e, t, n, i) {
				this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = i || se.DefaultOrder
			}

			function ce() {
				this.mask = 1
			}

			function le() {
				Object.defineProperty(this, "id", {
					value: Rs++
				}), this.uuid = gs.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = le.DefaultUp.clone();
				var e = new o,
					t = new se,
					n = new r,
					s = new o(1, 1, 1);
				t.onChange(function() {
					n.setFromEuler(t, !1)
				}), n.onChange(function() {
					t.setFromQuaternion(n, void 0, !1)
				}), Object.defineProperties(this, {
					position: {
						enumerable: !0,
						value: e
					},
					rotation: {
						enumerable: !0,
						value: t
					},
					quaternion: {
						enumerable: !0,
						value: n
					},
					scale: {
						enumerable: !0,
						value: s
					},
					modelViewMatrix: {
						value: new i
					},
					normalMatrix: {
						value: new a
					}
				}), this.matrix = new i, this.matrixWorld = new i, this.matrixAutoUpdate = le.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ce, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
			}

			function ue() {
				le.call(this), this.type = "Camera", this.matrixWorldInverse = new i, this.projectionMatrix = new i
			}

			function he(e, t, n, i, r, o) {
				ue.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
			}

			function de(e, t, n, i, r, a) {
				this.a = e, this.b = t, this.c = n, this.normal = i && i.isVector3 ? i : new o, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new X, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
			}

			function fe() {
				Object.defineProperty(this, "id", {
					value: Is += 2
				}), this.uuid = gs.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
			}

			function ve(e, t, n) {
				if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
				this.uuid = gs.generateUUID(), this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
					offset: 0,
					count: -1
				}, this.onUploadCallback = function() {}, this.version = 0
			}

			function pe(e, t, n) {
				ve.call(this, new Int8Array(e), t, n)
			}

			function me(e, t, n) {
				ve.call(this, new Uint8Array(e), t, n)
			}

			function ge(e, t, n) {
				ve.call(this, new Uint8ClampedArray(e), t, n)
			}

			function ye(e, t, n) {
				ve.call(this, new Int16Array(e), t, n)
			}

			function xe(e, t, n) {
				ve.call(this, new Uint16Array(e), t, n)
			}

			function be(e, t, n) {
				ve.call(this, new Int32Array(e), t, n)
			}

			function we(e, t, n) {
				ve.call(this, new Uint32Array(e), t, n)
			}

			function Me(e, t, n) {
				ve.call(this, new Float32Array(e), t, n)
			}

			function _e(e, t, n) {
				ve.call(this, new Float64Array(e), t, n)
			}

			function Se() {
				this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
			}

			function Ee(e) {
				if (0 === e.length) return -1 / 0;
				for (var t = e[0], n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
				return t
			}

			function Te() {
				Object.defineProperty(this, "id", {
					value: js += 2
				}), this.uuid = gs.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
					start: 0,
					count: 1 / 0
				}
			}

			function Pe(e, t, n, i, r, o) {
				fe.call(this), this.type = "BoxGeometry", this.parameters = {
					width: e,
					height: t,
					depth: n,
					widthSegments: i,
					heightSegments: r,
					depthSegments: o
				}, this.fromBufferGeometry(new Ae(e, t, n, i, r, o)), this.mergeVertices()
			}

			function Ae(e, t, n, i, r, a) {
				function s(e, t, n, i, r, a, s, p, m, g, y) {
					var x, b, w = a / m,
						M = s / g,
						_ = a / 2,
						S = s / 2,
						E = p / 2,
						T = m + 1,
						P = g + 1,
						A = 0,
						L = 0,
						C = new o;
					for (b = 0; b < P; b++) {
						var z = b * M - S;
						for (x = 0; x < T; x++) {
							var R = x * w - _;
							C[e] = R * i, C[t] = z * r, C[n] = E, u.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[n] = p > 0 ? 1 : -1, h.push(C.x, C.y, C.z), d.push(x / m), d.push(1 - b / g), A += 1
						}
					}
					for (b = 0; b < g; b++)
						for (x = 0; x < m; x++) {
							var I = f + x + T * b,
								j = f + x + T * (b + 1),
								O = f + (x + 1) + T * (b + 1),
								D = f + (x + 1) + T * b;
							l.push(I, j, D), l.push(j, O, D), L += 6
						}
					c.addGroup(v, L, y), v += L, f += A
				}
				Te.call(this), this.type = "BoxBufferGeometry", this.parameters = {
					width: e,
					height: t,
					depth: n,
					widthSegments: i,
					heightSegments: r,
					depthSegments: a
				};
				var c = this;
				e = e || 1, t = t || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1;
				var l = [],
					u = [],
					h = [],
					d = [],
					f = 0,
					v = 0;
				s("z", "y", "x", -1, -1, n, t, e, a = Math.floor(a) || 1, r, 0), s("z", "y", "x", 1, -1, n, t, -e, a, r, 1), s("x", "z", "y", 1, 1, e, n, t, i, a, 2), s("x", "z", "y", 1, -1, e, n, -t, i, a, 3), s("x", "y", "z", 1, -1, e, t, n, i, r, 4), s("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.addAttribute("position", new Me(u, 3)), this.addAttribute("normal", new Me(h, 3)), this.addAttribute("uv", new Me(d, 2))
			}

			function Le(e, t, n, i) {
				fe.call(this), this.type = "PlaneGeometry", this.parameters = {
					width: e,
					height: t,
					widthSegments: n,
					heightSegments: i
				}, this.fromBufferGeometry(new Ce(e, t, n, i)), this.mergeVertices()
			}

			function Ce(e, t, n, i) {
				Te.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
					width: e,
					height: t,
					widthSegments: n,
					heightSegments: i
				};
				var r, o, a = (e = e || 1) / 2,
					s = (t = t || 1) / 2,
					c = Math.floor(n) || 1,
					l = Math.floor(i) || 1,
					u = c + 1,
					h = l + 1,
					d = e / c,
					f = t / l,
					v = [],
					p = [],
					m = [],
					g = [];
				for (o = 0; o < h; o++) {
					var y = o * f - s;
					for (r = 0; r < u; r++) {
						var x = r * d - a;
						p.push(x, -y, 0), m.push(0, 0, 1), g.push(r / c), g.push(1 - o / l)
					}
				}
				for (o = 0; o < l; o++)
					for (r = 0; r < c; r++) {
						var b = r + u * o,
							w = r + u * (o + 1),
							M = r + 1 + u * (o + 1),
							_ = r + 1 + u * o;
						v.push(b, w, _), v.push(w, M, _)
					}
				this.setIndex(v), this.addAttribute("position", new Me(p, 3)), this.addAttribute("normal", new Me(m, 3)), this.addAttribute("uv", new Me(g, 2))
			}

			function ze(e) {
				Q.call(this), this.type = "MeshBasicMaterial", this.color = new X(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ra, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e)
			}

			function Re(e) {
				Q.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
					derivatives: !1,
					fragDepth: !1,
					drawBuffers: !1,
					shaderTextureLOD: !1
				}, this.defaultAttributeValues = {
					color: [1, 1, 1],
					uv: [0, 0],
					uv2: [0, 0]
				}, this.index0AttributeName = void 0, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
			}

			function Ie(e, t) {
				this.origin = void 0 !== e ? e : new o, this.direction = void 0 !== t ? t : new o
			}

			function je(e, t) {
				this.start = void 0 !== e ? e : new o, this.end = void 0 !== t ? t : new o
			}

			function Oe(e, t, n) {
				this.a = void 0 !== e ? e : new o, this.b = void 0 !== t ? t : new o, this.c = void 0 !== n ? n : new o
			}

			function De(e, t) {
				le.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Te, this.material = void 0 !== t ? t : new ze({
					color: 16777215 * Math.random()
				}), this.drawMode = os, this.updateMorphTargets()
			}

			function Fe(e, t, n, i) {
				function r(e, n) {
					t.buffers.color.setClear(e.r, e.g, e.b, n, i)
				}
				var o, a, s, c = new X(0),
					l = 0;
				return {
					getClearColor: function() {
						return c
					},
					setClearColor: function(e, t) {
						c.set(e), r(c, l = void 0 !== t ? t : 1)
					},
					getClearAlpha: function() {
						return l
					},
					setClearAlpha: function(e) {
						r(c, l = e)
					},
					render: function(t, i, u, h) {
						var d = i.background;
						null === d ? r(c, l) : d && d.isColor && (r(d, 1), h = !0), (e.autoClear || h) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), d && d.isCubeTexture ? (void 0 === s && ((s = new De(new Ae(1, 1, 1), new Re({
							uniforms: Cs.cube.uniforms,
							vertexShader: Cs.cube.vertexShader,
							fragmentShader: Cs.cube.fragmentShader,
							side: _o,
							depthTest: !0,
							depthWrite: !1,
							fog: !1
						}))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function(e, t, n) {
							this.matrixWorld.copyPosition(n.matrixWorld)
						}, n.update(s.geometry)), s.material.uniforms.tCube.value = d, t.push(s, s.geometry, s.material, 0, null)) : d && d.isTexture && (void 0 === o && (o = new he(-1, 1, 1, -1, 0, 1), a = new De(new Ce(2, 2), new ze({
							depthTest: !1,
							depthWrite: !1,
							fog: !1
						})), n.update(a.geometry)), a.material.map = d, e.renderBufferDirect(o, null, a.geometry, a.material, a, null))
					}
				}
			}

			function Ue(e, t) {
				return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
			}

			function ke(e, t) {
				return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
			}

			function Ne() {
				var e = [],
					t = 0,
					n = [],
					i = [];
				return {
					opaque: n,
					transparent: i,
					init: function() {
						t = 0, n.length = 0, i.length = 0
					},
					push: function(r, o, a, s, c) {
						var l = e[t];
						void 0 === l ? (l = {
							id: r.id,
							object: r,
							geometry: o,
							material: a,
							program: a.program,
							renderOrder: r.renderOrder,
							z: s,
							group: c
						}, e[t] = l) : (l.id = r.id, l.object = r, l.geometry = o, l.material = a, l.program = a.program, l.renderOrder = r.renderOrder, l.z = s, l.group = c), (!0 === a.transparent ? i : n).push(l), t++
					},
					sort: function() {
						n.length > 1 && n.sort(Ue), i.length > 1 && i.sort(ke)
					}
				}
			}

			function Be() {
				var e = {};
				return {
					get: function(t, n) {
						var i = t.id + "," + n.id,
							r = e[i];
						return void 0 === r && (r = new Ne, e[i] = r), r
					},
					dispose: function() {
						e = {}
					}
				}
			}

			function Ge(e, t) {
				return Math.abs(t[1]) - Math.abs(e[1])
			}

			function He(e) {
				var t = {},
					n = new Float32Array(8);
				return {
					update: function(i, r, o, a) {
						var s = i.morphTargetInfluences,
							c = s.length,
							l = t[r.id];
						if (void 0 === l) {
							for (l = [], d = 0; d < c; d++) l[d] = [d, 0];
							t[r.id] = l
						}
						for (var u = o.morphTargets && r.morphAttributes.position, h = o.morphNormals && r.morphAttributes.normal, d = 0; d < c; d++) 0 !== (f = l[d])[1] && (u && r.removeAttribute("morphTarget" + d), h && r.removeAttribute("morphNormal" + d));
						for (d = 0; d < c; d++)(f = l[d])[0] = d, f[1] = s[d];
						l.sort(Ge);
						for (d = 0; d < 8; d++) {
							var f = l[d];
							if (f) {
								var v = f[0],
									p = f[1];
								if (p) {
									u && r.addAttribute("morphTarget" + d, u[v]), h && r.addAttribute("morphNormal" + d, h[v]), n[d] = p;
									continue
								}
							}
							n[d] = 0
						}
						a.getUniforms().setValue(e, "morphTargetInfluences", n)
					}
				}
			}

			function Ve(e, t, n) {
				var i, r, o;
				this.setMode = function(e) {
					i = e
				}, this.setIndex = function(e) {
					r = e.type, o = e.bytesPerElement
				}, this.render = function(t, a) {
					e.drawElements(i, a, r, t * o), n.calls++, n.vertices += a, i === e.TRIANGLES ? n.faces += a / 3 : i === e.POINTS && (n.points += a)
				}, this.renderInstances = function(a, s, c) {
					var l = t.get("ANGLE_instanced_arrays");
					null !== l ? (l.drawElementsInstancedANGLE(i, c, r, s * o, a.maxInstancedCount), n.calls++, n.vertices += c * a.maxInstancedCount, i === e.TRIANGLES ? n.faces += a.maxInstancedCount * c / 3 : i === e.POINTS && (n.points += a.maxInstancedCount * c)) : console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
				}
			}

			function We(e, t, n) {
				var i;
				this.setMode = function(e) {
					i = e
				}, this.render = function(t, r) {
					e.drawArrays(i, t, r), n.calls++, n.vertices += r, i === e.TRIANGLES ? n.faces += r / 3 : i === e.POINTS && (n.points += r)
				}, this.renderInstances = function(r, o, a) {
					var s = t.get("ANGLE_instanced_arrays");
					if (null !== s) {
						var c = r.attributes.position;
						c.isInterleavedBufferAttribute ? (a = c.data.count, s.drawArraysInstancedANGLE(i, 0, a, r.maxInstancedCount)) : s.drawArraysInstancedANGLE(i, o, a, r.maxInstancedCount), n.calls++, n.vertices += a * r.maxInstancedCount, i === e.TRIANGLES ? n.faces += r.maxInstancedCount * a / 3 : i === e.POINTS && (n.points += r.maxInstancedCount * a)
					} else console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
				}
			}

			function Ye(e, t, n) {
				function i(e) {
					var a = e.target,
						s = r[a.id];
					null !== s.index && t.remove(s.index);
					for (var c in s.attributes) t.remove(s.attributes[c]);
					a.removeEventListener("dispose", i), delete r[a.id];
					var l = o[a.id];
					l && (t.remove(l), delete o[a.id]), (l = o[s.id]) && (t.remove(l), delete o[s.id]), n.geometries--
				}
				var r = {},
					o = {};
				return {
					get: function(e, t) {
						var o = r[t.id];
						return o || (t.addEventListener("dispose", i), t.isBufferGeometry ? o = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Te).setFromObject(e)), o = t._bufferGeometry), r[t.id] = o, n.geometries++, o)
					},
					update: function(n) {
						var i = n.index,
							r = n.attributes;
						null !== i && t.update(i, e.ELEMENT_ARRAY_BUFFER);
						for (var o in r) t.update(r[o], e.ARRAY_BUFFER);
						var a = n.morphAttributes;
						for (var o in a)
							for (var s = a[o], c = 0, l = s.length; c < l; c++) t.update(s[c], e.ARRAY_BUFFER)
					},
					getWireframeAttribute: function(n) {
						var i = o[n.id];
						if (i) return i;
						var r = [],
							a = n.index,
							s = n.attributes;
						if (null !== a)
							for (var c = 0, l = (f = a.array).length; c < l; c += 3) {
								var u = f[c + 0],
									h = f[c + 1],
									d = f[c + 2];
								r.push(u, h, h, d, d, u)
							} else
								for (var f = s.position.array, c = 0, l = f.length / 3 - 1; c < l; c += 3) {
									var u = c + 0,
										h = c + 1,
										d = c + 2;
									r.push(u, h, h, d, d, u)
								}
						return i = new(Ee(r) > 65535 ? we : xe)(r, 1), t.update(i, e.ELEMENT_ARRAY_BUFFER), o[n.id] = i, i
					}
				}
			}

			function Xe() {
				var e = {};
				return {
					get: function(t) {
						if (void 0 !== e[t.id]) return e[t.id];
						var i;
						switch (t.type) {
							case "DirectionalLight":
								i = {
									direction: new o,
									color: new X,
									shadow: !1,
									shadowBias: 0,
									shadowRadius: 1,
									shadowMapSize: new n
								};
								break;
							case "SpotLight":
								i = {
									position: new o,
									direction: new o,
									color: new X,
									distance: 0,
									coneCos: 0,
									penumbraCos: 0,
									decay: 0,
									shadow: !1,
									shadowBias: 0,
									shadowRadius: 1,
									shadowMapSize: new n
								};
								break;
							case "PointLight":
								i = {
									position: new o,
									color: new X,
									distance: 0,
									decay: 0,
									shadow: !1,
									shadowBias: 0,
									shadowRadius: 1,
									shadowMapSize: new n,
									shadowCameraNear: 1,
									shadowCameraFar: 1e3
								};
								break;
							case "HemisphereLight":
								i = {
									direction: new o,
									skyColor: new X,
									groundColor: new X
								};
								break;
							case "RectAreaLight":
								i = {
									color: new X,
									position: new o,
									halfWidth: new o,
									halfHeight: new o
								}
						}
						return e[t.id] = i, i
					}
				}
			}

			function qe() {
				var e = new Xe,
					t = {
						hash: "",
						ambient: [0, 0, 0],
						directional: [],
						directionalShadowMap: [],
						directionalShadowMatrix: [],
						spot: [],
						spotShadowMap: [],
						spotShadowMatrix: [],
						rectArea: [],
						point: [],
						pointShadowMap: [],
						pointShadowMatrix: [],
						hemi: []
					},
					n = new o,
					r = new i,
					a = new i;
				return {
					setup: function(i, o, s) {
						for (var c = 0, l = 0, u = 0, h = 0, d = 0, f = 0, v = 0, p = 0, m = s.matrixWorldInverse, g = 0, y = i.length; g < y; g++) {
							var x = i[g],
								b = x.color,
								w = x.intensity,
								M = x.distance,
								_ = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
							if (x.isAmbientLight) c += b.r * w, l += b.g * w, u += b.b * w;
							else if (x.isDirectionalLight)(E = e.get(x)).color.copy(x.color).multiplyScalar(x.intensity), E.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(m), E.shadow = x.castShadow, x.castShadow && (S = x.shadow, E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize), t.directionalShadowMap[h] = _, t.directionalShadowMatrix[h] = x.shadow.matrix, t.directional[h] = E, h++;
							else if (x.isSpotLight)(E = e.get(x)).position.setFromMatrixPosition(x.matrixWorld), E.position.applyMatrix4(m), E.color.copy(b).multiplyScalar(w), E.distance = M, E.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(m), E.coneCos = Math.cos(x.angle), E.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), E.decay = 0 === x.distance ? 0 : x.decay, E.shadow = x.castShadow, x.castShadow && (S = x.shadow, E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize), t.spotShadowMap[f] = _, t.spotShadowMatrix[f] = x.shadow.matrix, t.spot[f] = E, f++;
							else if (x.isRectAreaLight)(E = e.get(x)).color.copy(b).multiplyScalar(w / (x.width * x.height)), E.position.setFromMatrixPosition(x.matrixWorld), E.position.applyMatrix4(m), a.identity(), r.copy(x.matrixWorld), r.premultiply(m), a.extractRotation(r), E.halfWidth.set(.5 * x.width, 0, 0), E.halfHeight.set(0, .5 * x.height, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), t.rectArea[v] = E, v++;
							else if (x.isPointLight) {
								if ((E = e.get(x)).position.setFromMatrixPosition(x.matrixWorld), E.position.applyMatrix4(m), E.color.copy(x.color).multiplyScalar(x.intensity), E.distance = x.distance, E.decay = 0 === x.distance ? 0 : x.decay, E.shadow = x.castShadow, x.castShadow) {
									var S = x.shadow;
									E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize, E.shadowCameraNear = S.camera.near, E.shadowCameraFar = S.camera.far
								}
								t.pointShadowMap[d] = _, t.pointShadowMatrix[d] = x.shadow.matrix, t.point[d] = E, d++
							} else if (x.isHemisphereLight) {
								var E = e.get(x);
								E.direction.setFromMatrixPosition(x.matrixWorld), E.direction.transformDirection(m), E.direction.normalize(), E.skyColor.copy(x.color).multiplyScalar(w), E.groundColor.copy(x.groundColor).multiplyScalar(w), t.hemi[p] = E, p++
							}
						}
						t.ambient[0] = c, t.ambient[1] = l, t.ambient[2] = u, t.directional.length = h, t.spot.length = f, t.rectArea.length = v, t.point.length = d, t.hemi.length = p, t.hash = h + "," + d + "," + f + "," + v + "," + p + "," + o.length
					},
					state: t
				}
			}

			function Ze(e, t) {
				var n = {};
				return {
					update: function(i) {
						var r = t.frame,
							o = i.geometry,
							a = e.get(i, o);
						return n[a.id] !== r && (o.isGeometry && a.updateFromObject(i), e.update(a), n[a.id] = r), a
					},
					clear: function() {
						n = {}
					}
				}
			}

			function Ke(e) {
				for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
				return t.join("\n")
			}

			function Je(e, t, n) {
				var i = e.createShader(t);
				return e.shaderSource(i, n), e.compileShader(i), !1 === e.getShaderParameter(i, e.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(i), Ke(n)), i
			}

			function Qe(e) {
				switch (e) {
					case cs:
						return ["Linear", "( value )"];
					case ls:
						return ["sRGB", "( value )"];
					case hs:
						return ["RGBE", "( value )"];
					case ds:
						return ["RGBM", "( value, 7.0 )"];
					case fs:
						return ["RGBM", "( value, 16.0 )"];
					case vs:
						return ["RGBD", "( value, 256.0 )"];
					case us:
						return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
					default:
						throw new Error("unsupported encoding: " + e)
				}
			}

			function $e(e, t) {
				var n = Qe(t);
				return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
			}

			function et(e, t) {
				var n = Qe(t);
				return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
			}

			function tt(e, t) {
				var n;
				switch (t) {
					case ca:
						n = "Linear";
						break;
					case la:
						n = "Reinhard";
						break;
					case ua:
						n = "Uncharted2";
						break;
					case ha:
						n = "OptimizedCineon";
						break;
					default:
						throw new Error("unsupported toneMapping: " + t)
				}
				return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
			}

			function nt(e, t, n) {
				return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ot).join("\n")
			}

			function it(e) {
				var t = [];
				for (var n in e) {
					var i = e[n];
					!1 !== i && t.push("#define " + n + " " + i)
				}
				return t.join("\n")
			}

			function rt(e, t) {
				for (var n = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), r = 0; r < i; r++) {
					var o = e.getActiveAttrib(t, r).name;
					n[o] = e.getAttribLocation(t, o)
				}
				return n
			}

			function ot(e) {
				return "" !== e
			}

			function at(e, t) {
				return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
			}

			function st(e) {
				var t = /^[ \t]*#include +<([\w\d.]+)>/gm;
				return e.replace(t, function(e, t) {
					var n = Ls[t];
					if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
					return st(n)
				})
			}

			function ct(e) {
				var t = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
				return e.replace(t, function(e, t, n, i) {
					for (var r = "", o = parseInt(t); o < parseInt(n); o++) r += i.replace(/\[ i \]/g, "[ " + o + " ]");
					return r
				})
			}

			function lt(e, t, n, i, r, o) {
				var a = e.context,
					s = i.defines,
					c = r.vertexShader,
					l = r.fragmentShader,
					u = "SHADOWMAP_TYPE_BASIC";
				o.shadowMapType === bo ? u = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === wo && (u = "SHADOWMAP_TYPE_PCF_SOFT");
				var h = "ENVMAP_TYPE_CUBE",
					d = "ENVMAP_MODE_REFLECTION",
					f = "ENVMAP_BLENDING_MULTIPLY";
				if (o.envMap) {
					switch (i.envMap.mapping) {
						case da:
						case fa:
							h = "ENVMAP_TYPE_CUBE";
							break;
						case ga:
						case ya:
							h = "ENVMAP_TYPE_CUBE_UV";
							break;
						case va:
						case pa:
							h = "ENVMAP_TYPE_EQUIREC";
							break;
						case ma:
							h = "ENVMAP_TYPE_SPHERE"
					}
					switch (i.envMap.mapping) {
						case fa:
						case pa:
							d = "ENVMAP_MODE_REFRACTION"
					}
					switch (i.combine) {
						case ra:
							f = "ENVMAP_BLENDING_MULTIPLY";
							break;
						case oa:
							f = "ENVMAP_BLENDING_MIX";
							break;
						case aa:
							f = "ENVMAP_BLENDING_ADD"
					}
				}
				var v, p, m = e.gammaFactor > 0 ? e.gammaFactor : 1,
					g = nt(i.extensions, o, t),
					y = it(s),
					x = a.createProgram();
				i.isRawShaderMaterial ? ((v = [y].filter(ot).join("\n")).length > 0 && (v += "\n"), (p = [g, y].filter(ot).join("\n")).length > 0 && (p += "\n")) : (v = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, y, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes, o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ot).join("\n"), p = [g, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, y, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + m, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + h : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (o.numClippingPlanes - o.numClipIntersection), o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && t.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== sa ? "#define TONE_MAPPING" : "", o.toneMapping !== sa ? Ls.tonemapping_pars_fragment : "", o.toneMapping !== sa ? tt("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? Ls.encodings_pars_fragment : "", o.mapEncoding ? $e("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? $e("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? $e("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? et("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(ot).join("\n")), c = at(c = st(c), o), l = at(l = st(l), o), i.isShaderMaterial || (c = ct(c), l = ct(l));
				var b = v + c,
					w = p + l,
					M = Je(a, a.VERTEX_SHADER, b),
					_ = Je(a, a.FRAGMENT_SHADER, w);
				a.attachShader(x, M), a.attachShader(x, _), void 0 !== i.index0AttributeName ? a.bindAttribLocation(x, 0, i.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(x, 0, "position"), a.linkProgram(x);
				var S = a.getProgramInfoLog(x),
					E = a.getShaderInfoLog(M),
					T = a.getShaderInfoLog(_),
					P = !0,
					A = !0;
				!1 === a.getProgramParameter(x, a.LINK_STATUS) ? (P = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(x, a.VALIDATE_STATUS), "gl.getProgramInfoLog", S, E, T)) : "" !== S ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", S) : "" !== E && "" !== T || (A = !1), A && (this.diagnostics = {
					runnable: P,
					material: i,
					programLog: S,
					vertexShader: {
						log: E,
						prefix: v
					},
					fragmentShader: {
						log: T,
						prefix: p
					}
				}), a.deleteShader(M), a.deleteShader(_);
				var L;
				this.getUniforms = function() {
					return void 0 === L && (L = new Y(a, x, e)), L
				};
				var C;
				return this.getAttributes = function() {
					return void 0 === C && (C = rt(a, x)), C
				}, this.destroy = function() {
					a.deleteProgram(x), this.program = void 0
				}, Object.defineProperties(this, {
					uniforms: {
						get: function() {
							return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
						}
					},
					attributes: {
						get: function() {
							return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
						}
					}
				}), this.id = Os++, this.code = n, this.usedTimes = 1, this.program = x, this.vertexShader = M, this.fragmentShader = _, this
			}

			function ut(e, t, n) {
				function i(e) {
					var t = e.skeleton.bones;
					if (n.floatVertexTextures) return 1024;
					var i = n.maxVertexUniforms,
						r = Math.floor((i - 20) / 4),
						o = Math.min(r, t.length);
					return o < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + o + "."), 0) : o
				}

				function r(e, t) {
					var n;
					return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = cs, n === cs && t && (n = us), n
				}
				var o = [],
					a = {
						MeshDepthMaterial: "depth",
						MeshDistanceMaterial: "distanceRGBA",
						MeshNormalMaterial: "normal",
						MeshBasicMaterial: "basic",
						MeshLambertMaterial: "lambert",
						MeshPhongMaterial: "phong",
						MeshToonMaterial: "phong",
						MeshStandardMaterial: "physical",
						MeshPhysicalMaterial: "physical",
						LineBasicMaterial: "basic",
						LineDashedMaterial: "dashed",
						PointsMaterial: "points",
						ShadowMaterial: "shadow"
					},
					s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
				this.getParameters = function(t, o, s, c, l, u, h) {
					var d = a[t.type],
						f = h.isSkinnedMesh ? i(h) : 0,
						v = n.precision;
					null !== t.precision && (v = n.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", v, "instead.");
					var p = e.getRenderTarget();
					return {
						shaderID: d,
						precision: v,
						supportsVertexTextures: n.vertexTextures,
						outputEncoding: r(p ? p.texture : null, e.gammaOutput),
						map: !!t.map,
						mapEncoding: r(t.map, e.gammaInput),
						envMap: !!t.envMap,
						envMapMode: t.envMap && t.envMap.mapping,
						envMapEncoding: r(t.envMap, e.gammaInput),
						envMapCubeUV: !!t.envMap && (t.envMap.mapping === ga || t.envMap.mapping === ya),
						lightMap: !!t.lightMap,
						aoMap: !!t.aoMap,
						emissiveMap: !!t.emissiveMap,
						emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
						bumpMap: !!t.bumpMap,
						normalMap: !!t.normalMap,
						displacementMap: !!t.displacementMap,
						roughnessMap: !!t.roughnessMap,
						metalnessMap: !!t.metalnessMap,
						specularMap: !!t.specularMap,
						alphaMap: !!t.alphaMap,
						gradientMap: !!t.gradientMap,
						combine: t.combine,
						vertexColors: t.vertexColors,
						fog: !!c,
						useFog: t.fog,
						fogExp: c && c.isFogExp2,
						flatShading: t.flatShading,
						sizeAttenuation: t.sizeAttenuation,
						logarithmicDepthBuffer: n.logarithmicDepthBuffer,
						skinning: t.skinning && f > 0,
						maxBones: f,
						useVertexTexture: n.floatVertexTextures,
						morphTargets: t.morphTargets,
						morphNormals: t.morphNormals,
						maxMorphTargets: e.maxMorphTargets,
						maxMorphNormals: e.maxMorphNormals,
						numDirLights: o.directional.length,
						numPointLights: o.point.length,
						numSpotLights: o.spot.length,
						numRectAreaLights: o.rectArea.length,
						numHemiLights: o.hemi.length,
						numClippingPlanes: l,
						numClipIntersection: u,
						dithering: t.dithering,
						shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && s.length > 0,
						shadowMapType: e.shadowMap.type,
						toneMapping: e.toneMapping,
						physicallyCorrectLights: e.physicallyCorrectLights,
						premultipliedAlpha: t.premultipliedAlpha,
						alphaTest: t.alphaTest,
						doubleSided: t.side === So,
						flipSided: t.side === _o,
						depthPacking: void 0 !== t.depthPacking && t.depthPacking
					}
				}, this.getProgramCode = function(t, n) {
					var i = [];
					if (n.shaderID ? i.push(n.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines)
						for (var r in t.defines) i.push(r), i.push(t.defines[r]);
					for (var o = 0; o < s.length; o++) i.push(n[s[o]]);
					return i.push(t.onBeforeCompile.toString()), i.push(e.gammaOutput), i.join()
				}, this.acquireProgram = function(n, i, r, a) {
					for (var s, c = 0, l = o.length; c < l; c++) {
						var u = o[c];
						if (u.code === a) {
							++(s = u).usedTimes;
							break
						}
					}
					return void 0 === s && (s = new lt(e, t, a, n, i, r), o.push(s)), s
				}, this.releaseProgram = function(e) {
					if (0 == --e.usedTimes) {
						var t = o.indexOf(e);
						o[t] = o[o.length - 1], o.pop(), e.destroy()
					}
				}, this.programs = o
			}

			function ht(e, t, n, i, r, o, a) {
				function s(e, t) {
					if (e.width > t || e.height > t) {
						var n = t / Math.max(e.width, e.height),
							i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
						return i.width = Math.floor(e.width * n), i.height = Math.floor(e.height * n), i.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + i.width + "x" + i.height, e), i
					}
					return e
				}

				function c(e) {
					return gs.isPowerOfTwo(e.width) && gs.isPowerOfTwo(e.height)
				}

				function l(e) {
					if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap) {
						var t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
						return t.width = gs.floorPowerOfTwo(e.width), t.height = gs.floorPowerOfTwo(e.height), t.getContext("2d").drawImage(e, 0, 0, t.width, t.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + t.width + "x" + t.height, e), t
					}
					return e
				}

				function u(e) {
					return e.wrapS !== ba || e.wrapT !== ba || e.minFilter !== Ma && e.minFilter !== Ea
				}

				function h(e, t) {
					return e.generateMipmaps && t && e.minFilter !== Ma && e.minFilter !== Ea
				}

				function d(t) {
					return t === Ma || t === _a || t === Sa ? e.NEAREST : e.LINEAR
				}

				function f(e) {
					var t = e.target;
					t.removeEventListener("dispose", f), p(t), t.isVideoTexture && delete E[t.id], a.textures--
				}

				function v(e) {
					var t = e.target;
					t.removeEventListener("dispose", v), m(t), a.textures--
				}

				function p(t) {
					var n = i.get(t);
					if (t.image && n.__image__webglTextureCube) e.deleteTexture(n.__image__webglTextureCube);
					else {
						if (void 0 === n.__webglInit) return;
						e.deleteTexture(n.__webglTexture)
					}
					i.remove(t)
				}

				function m(t) {
					var n = i.get(t),
						r = i.get(t.texture);
					if (t) {
						if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
							for (var o = 0; o < 6; o++) e.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[o]);
						else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
						i.remove(t.texture), i.remove(t)
					}
				}

				function g(t, r) {
					var o = i.get(t);
					if (t.version > 0 && o.__version !== t.version) {
						var a = t.image;
						if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
						else {
							if (!1 !== a.complete) return void x(o, t, r);
							console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t)
						}
					}
					n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_2D, o.__webglTexture)
				}

				function y(n, a, s) {
					var c;
					if (s ? (e.texParameteri(n, e.TEXTURE_WRAP_S, o.convert(a.wrapS)), e.texParameteri(n, e.TEXTURE_WRAP_T, o.convert(a.wrapT)), e.texParameteri(n, e.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), a.wrapS === ba && a.wrapT === ba || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), e.texParameteri(n, e.TEXTURE_MAG_FILTER, d(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, d(a.minFilter)), a.minFilter !== Ma && a.minFilter !== Ea && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), c = t.get("EXT_texture_filter_anisotropic")) {
						if (a.type === ja && null === t.get("OES_texture_float_linear")) return;
						if (a.type === Oa && null === t.get("OES_texture_half_float_linear")) return;
						(a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
					}
				}

				function x(t, i, d) {
					void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), i.isVideoTexture && (E[i.id] = i), a.textures++), n.activeTexture(e.TEXTURE0 + d), n.bindTexture(e.TEXTURE_2D, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment);
					var v = s(i.image, r.maxTextureSize);
					u(i) && !1 === c(v) && (v = l(v));
					var p = c(v),
						m = o.convert(i.format),
						g = o.convert(i.type);
					y(e.TEXTURE_2D, i, p);
					var x, b = i.mipmaps;
					if (i.isDepthTexture) {
						var w = e.DEPTH_COMPONENT;
						if (i.type === ja) {
							if (!S) throw new Error("Float Depth Texture only supported in WebGL2.0");
							w = e.DEPTH_COMPONENT32F
						} else S && (w = e.DEPTH_COMPONENT16);
						i.format === Ya && w === e.DEPTH_COMPONENT && i.type !== za && i.type !== Ia && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = za, g = o.convert(i.type)), i.format === Xa && (w = e.DEPTH_STENCIL, i.type !== ka && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = ka, g = o.convert(i.type))), n.texImage2D(e.TEXTURE_2D, 0, w, v.width, v.height, 0, m, g, null)
					} else if (i.isDataTexture)
						if (b.length > 0 && p) {
							for (var M = 0, _ = b.length; M < _; M++) x = b[M], n.texImage2D(e.TEXTURE_2D, M, m, x.width, x.height, 0, m, g, x.data);
							i.generateMipmaps = !1
						} else n.texImage2D(e.TEXTURE_2D, 0, m, v.width, v.height, 0, m, g, v.data);
					else if (i.isCompressedTexture)
						for (var M = 0, _ = b.length; M < _; M++) x = b[M], i.format !== Ga && i.format !== Ba ? n.getCompressedTextureFormats().indexOf(m) > -1 ? n.compressedTexImage2D(e.TEXTURE_2D, M, m, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(e.TEXTURE_2D, M, m, x.width, x.height, 0, m, g, x.data);
					else if (b.length > 0 && p) {
						for (var M = 0, _ = b.length; M < _; M++) x = b[M], n.texImage2D(e.TEXTURE_2D, M, m, m, g, x);
						i.generateMipmaps = !1
					} else n.texImage2D(e.TEXTURE_2D, 0, m, m, g, v);
					h(i, p) && e.generateMipmap(e.TEXTURE_2D), t.__version = i.version, i.onUpdate && i.onUpdate(i)
				}

				function b(t, r, a, s) {
					var c = o.convert(r.texture.format),
						l = o.convert(r.texture.type);
					n.texImage2D(s, 0, c, r.width, r.height, 0, c, l, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, a, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null)
				}

				function w(t, n) {
					e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)) : n.depthBuffer && n.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, n.width, n.height), e.bindRenderbuffer(e.RENDERBUFFER, null)
				}

				function M(t, n) {
					if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
					if (e.bindFramebuffer(e.FRAMEBUFFER, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
					i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
					var r = i.get(n.depthTexture).__webglTexture;
					if (n.depthTexture.format === Ya) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, r, 0);
					else {
						if (n.depthTexture.format !== Xa) throw new Error("Unknown depthTexture format");
						e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, r, 0)
					}
				}

				function _(t) {
					var n = i.get(t),
						r = !0 === t.isWebGLRenderTargetCube;
					if (t.depthTexture) {
						if (r) throw new Error("target.depthTexture not supported in Cube render targets");
						M(n.__webglFramebuffer, t)
					} else if (r) {
						n.__webglDepthbuffer = [];
						for (var o = 0; o < 6; o++) e.bindFramebuffer(e.FRAMEBUFFER, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = e.createRenderbuffer(), w(n.__webglDepthbuffer[o], t)
					} else e.bindFramebuffer(e.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), w(n.__webglDepthbuffer, t);
					e.bindFramebuffer(e.FRAMEBUFFER, null)
				}
				var S = "undefined" != typeof WebGL2RenderingContext && e instanceof window.WebGL2RenderingContext,
					E = {};
				this.setTexture2D = g, this.setTextureCube = function(t, l) {
					var u = i.get(t);
					if (6 === t.image.length)
						if (t.version > 0 && u.__version !== t.version) {
							u.__image__webglTextureCube || (t.addEventListener("dispose", f), u.__image__webglTextureCube = e.createTexture(), a.textures++), n.activeTexture(e.TEXTURE0 + l), n.bindTexture(e.TEXTURE_CUBE_MAP, u.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY);
							for (var d = t && t.isCompressedTexture, v = t.image[0] && t.image[0].isDataTexture, p = [], m = 0; m < 6; m++) p[m] = d || v ? v ? t.image[m].image : t.image[m] : s(t.image[m], r.maxCubemapSize);
							var g = c(p[0]),
								x = o.convert(t.format),
								b = o.convert(t.type);
							for (y(e.TEXTURE_CUBE_MAP, t, g), m = 0; m < 6; m++)
								if (d)
									for (var w, M = p[m].mipmaps, _ = 0, S = M.length; _ < S; _++) w = M[_], t.format !== Ga && t.format !== Ba ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, _, x, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, _, x, w.width, w.height, 0, x, b, w.data);
								else v ? n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, x, p[m].width, p[m].height, 0, x, b, p[m].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, x, x, b, p[m]);
							h(t, g) && e.generateMipmap(e.TEXTURE_CUBE_MAP), u.__version = t.version, t.onUpdate && t.onUpdate(t)
						} else n.activeTexture(e.TEXTURE0 + l), n.bindTexture(e.TEXTURE_CUBE_MAP, u.__image__webglTextureCube)
				}, this.setTextureCubeDynamic = function(t, r) {
					n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_CUBE_MAP, i.get(t).__webglTexture)
				}, this.setupRenderTarget = function(t) {
					var r = i.get(t),
						o = i.get(t.texture);
					t.addEventListener("dispose", v), o.__webglTexture = e.createTexture(), a.textures++;
					var s = !0 === t.isWebGLRenderTargetCube,
						l = c(t);
					if (s)
						for (r.__webglFramebuffer = [], u = 0; u < 6; u++) r.__webglFramebuffer[u] = e.createFramebuffer();
					else r.__webglFramebuffer = e.createFramebuffer();
					if (s) {
						n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture), y(e.TEXTURE_CUBE_MAP, t.texture, l);
						for (var u = 0; u < 6; u++) b(r.__webglFramebuffer[u], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + u);
						h(t.texture, l) && e.generateMipmap(e.TEXTURE_CUBE_MAP), n.bindTexture(e.TEXTURE_CUBE_MAP, null)
					} else n.bindTexture(e.TEXTURE_2D, o.__webglTexture), y(e.TEXTURE_2D, t.texture, l), b(r.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), h(t.texture, l) && e.generateMipmap(e.TEXTURE_2D), n.bindTexture(e.TEXTURE_2D, null);
					t.depthBuffer && _(t)
				}, this.updateRenderTargetMipmap = function(t) {
					var r = t.texture;
					if (h(r, c(t))) {
						var o = t.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
							a = i.get(r).__webglTexture;
						n.bindTexture(o, a), e.generateMipmap(o), n.bindTexture(o, null)
					}
				}, this.updateVideoTextures = function() {
					for (var e in E) E[e].update()
				}
			}

			function dt() {
				var e = {};
				return {
					get: function(t) {
						var n = t.uuid,
							i = e[n];
						return void 0 === i && (i = {}, e[n] = i), i
					},
					remove: function(t) {
						delete e[t.uuid]
					},
					clear: function() {
						e = {}
					}
				}
			}

			function ft(e, t, n) {
				function i(t, n, i) {
					var r = new Uint8Array(4),
						o = e.createTexture();
					e.bindTexture(t, o), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
					for (var a = 0; a < i; a++) e.texImage2D(n + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, r);
					return o
				}

				function r(t) {
					!0 !== x[t] && (e.enable(t), x[t] = !0)
				}

				function o(t) {
					!1 !== x[t] && (e.disable(t), x[t] = !1)
				}

				function a(t, i, a, s, c, l, u, h) {
					if (t !== Ao ? r(e.BLEND) : o(e.BLEND), t !== Io) {
						if (t !== M || h !== L) switch (t) {
							case Co:
								h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE));
								break;
							case zo:
								h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR));
								break;
							case Ro:
								h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR));
								break;
							default:
								h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA))
						}
						_ = null, S = null, E = null, T = null, P = null, A = null
					} else c = c || i, l = l || a, u = u || s, i === _ && c === T || (e.blendEquationSeparate(n.convert(i), n.convert(c)), _ = i, T = c), a === S && s === E && l === P && u === A || (e.blendFuncSeparate(n.convert(a), n.convert(s), n.convert(l), n.convert(u)), S = a, E = s, P = l, A = u);
					M = t, L = h
				}

				function s(t) {
					C !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), C = t)
				}

				function l(t) {
					t !== mo ? (r(e.CULL_FACE), t !== z && (t === go ? e.cullFace(e.BACK) : t === yo ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : o(e.CULL_FACE), z = t
				}

				function u(t, n, i) {
					t ? (r(e.POLYGON_OFFSET_FILL), I === n && j === i || (e.polygonOffset(n, i), I = n, j = i)) : o(e.POLYGON_OFFSET_FILL)
				}

				function h(t) {
					void 0 === t && (t = e.TEXTURE0 + O - 1), U !== t && (e.activeTexture(t), U = t)
				}
				var d = new function() {
						var t = !1,
							n = new c,
							i = null,
							r = new c(0, 0, 0, 0);
						return {
							setMask: function(n) {
								i === n || t || (e.colorMask(n, n, n, n), i = n)
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t, i, o, a, s) {
								!0 === s && (t *= a, i *= a, o *= a), n.set(t, i, o, a), !1 === r.equals(n) && (e.clearColor(t, i, o, a), r.copy(n))
							},
							reset: function() {
								t = !1, i = null, r.set(-1, 0, 0, 0)
							}
						}
					},
					f = new function() {
						var t = !1,
							n = null,
							i = null,
							a = null;
						return {
							setTest: function(t) {
								t ? r(e.DEPTH_TEST) : o(e.DEPTH_TEST)
							},
							setMask: function(i) {
								n === i || t || (e.depthMask(i), n = i)
							},
							setFunc: function(t) {
								if (i !== t) {
									if (t) switch (t) {
										case Ko:
											e.depthFunc(e.NEVER);
											break;
										case Jo:
											e.depthFunc(e.ALWAYS);
											break;
										case Qo:
											e.depthFunc(e.LESS);
											break;
										case $o:
											e.depthFunc(e.LEQUAL);
											break;
										case ea:
											e.depthFunc(e.EQUAL);
											break;
										case ta:
											e.depthFunc(e.GEQUAL);
											break;
										case na:
											e.depthFunc(e.GREATER);
											break;
										case ia:
											e.depthFunc(e.NOTEQUAL);
											break;
										default:
											e.depthFunc(e.LEQUAL)
									} else e.depthFunc(e.LEQUAL);
									i = t
								}
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t) {
								a !== t && (e.clearDepth(t), a = t)
							},
							reset: function() {
								t = !1, n = null, i = null, a = null
							}
						}
					},
					v = new function() {
						var t = !1,
							n = null,
							i = null,
							a = null,
							s = null,
							c = null,
							l = null,
							u = null,
							h = null;
						return {
							setTest: function(t) {
								t ? r(e.STENCIL_TEST) : o(e.STENCIL_TEST)
							},
							setMask: function(i) {
								n === i || t || (e.stencilMask(i), n = i)
							},
							setFunc: function(t, n, r) {
								i === t && a === n && s === r || (e.stencilFunc(t, n, r), i = t, a = n, s = r)
							},
							setOp: function(t, n, i) {
								c === t && l === n && u === i || (e.stencilOp(t, n, i), c = t, l = n, u = i)
							},
							setLocked: function(e) {
								t = e
							},
							setClear: function(t) {
								h !== t && (e.clearStencil(t), h = t)
							},
							reset: function() {
								t = !1, n = null, i = null, a = null, s = null, c = null, l = null, u = null, h = null
							}
						}
					},
					p = e.getParameter(e.MAX_VERTEX_ATTRIBS),
					m = new Uint8Array(p),
					g = new Uint8Array(p),
					y = new Uint8Array(p),
					x = {},
					b = null,
					w = null,
					M = null,
					_ = null,
					S = null,
					E = null,
					T = null,
					P = null,
					A = null,
					L = !1,
					C = null,
					z = null,
					R = null,
					I = null,
					j = null,
					O = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
					D = parseFloat(/^WebGL\ ([0-9])/.exec(e.getParameter(e.VERSION))[1]),
					F = parseFloat(D) >= 1,
					U = null,
					k = {},
					N = new c,
					B = new c,
					G = {};
				return G[e.TEXTURE_2D] = i(e.TEXTURE_2D, e.TEXTURE_2D, 1), G[e.TEXTURE_CUBE_MAP] = i(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), d.setClear(0, 0, 0, 1), f.setClear(1), v.setClear(0), r(e.DEPTH_TEST), f.setFunc($o), s(!1), l(go), r(e.CULL_FACE), r(e.BLEND), a(Lo), {
					buffers: {
						color: d,
						depth: f,
						stencil: v
					},
					initAttributes: function() {
						for (var e = 0, t = m.length; e < t; e++) m[e] = 0
					},
					enableAttribute: function(n) {
						m[n] = 1, 0 === g[n] && (e.enableVertexAttribArray(n), g[n] = 1), 0 !== y[n] && (t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, 0), y[n] = 0)
					},
					enableAttributeAndDivisor: function(n, i) {
						m[n] = 1, 0 === g[n] && (e.enableVertexAttribArray(n), g[n] = 1), y[n] !== i && (t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, i), y[n] = i)
					},
					disableUnusedAttributes: function() {
						for (var t = 0, n = g.length; t !== n; ++t) g[t] !== m[t] && (e.disableVertexAttribArray(t), g[t] = 0)
					},
					enable: r,
					disable: o,
					getCompressedTextureFormats: function() {
						if (null === b && (b = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1")))
							for (var n = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++) b.push(n[i]);
						return b
					},
					useProgram: function(t) {
						return w !== t && (e.useProgram(t), w = t, !0)
					},
					setBlending: a,
					setMaterial: function(t, n) {
						t.side === So ? o(e.CULL_FACE) : r(e.CULL_FACE);
						var i = t.side === _o;
						n && (i = !i), s(i), !0 === t.transparent ? a(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : a(Ao), f.setFunc(t.depthFunc), f.setTest(t.depthTest), f.setMask(t.depthWrite), d.setMask(t.colorWrite), u(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
					},
					setFlipSided: s,
					setCullFace: l,
					setLineWidth: function(t) {
						t !== R && (F && e.lineWidth(t), R = t)
					},
					setPolygonOffset: u,
					setScissorTest: function(t) {
						t ? r(e.SCISSOR_TEST) : o(e.SCISSOR_TEST)
					},
					activeTexture: h,
					bindTexture: function(t, n) {
						null === U && h();
						var i = k[U];
						void 0 === i && (i = {
							type: void 0,
							texture: void 0
						}, k[U] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || G[t]), i.type = t, i.texture = n)
					},
					compressedTexImage2D: function() {
						try {
							e.compressedTexImage2D.apply(e, arguments)
						} catch (e) {
							console.error("THREE.WebGLState:", e)
						}
					},
					texImage2D: function() {
						try {
							e.texImage2D.apply(e, arguments)
						} catch (e) {
							console.error("THREE.WebGLState:", e)
						}
					},
					scissor: function(t) {
						!1 === N.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), N.copy(t))
					},
					viewport: function(t) {
						!1 === B.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), B.copy(t))
					},
					reset: function() {
						for (var t = 0; t < g.length; t++) 1 === g[t] && (e.disableVertexAttribArray(t), g[t] = 0);
						x = {}, b = null, U = null, k = {}, w = null, M = null, C = null, z = null, d.reset(), f.reset(), v.reset()
					}
				}
			}

			function vt(e, t, n) {
				function i(t) {
					if ("highp" === t) {
						if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
						t = "mediump"
					}
					return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
				}
				var r, o = void 0 !== n.precision ? n.precision : "highp",
					a = i(o);
				a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
				var s = !0 === n.logarithmicDepthBuffer,
					c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
					l = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
					u = e.getParameter(e.MAX_TEXTURE_SIZE),
					h = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
					d = e.getParameter(e.MAX_VERTEX_ATTRIBS),
					f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
					v = e.getParameter(e.MAX_VARYING_VECTORS),
					p = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
					m = l > 0,
					g = !!t.get("OES_texture_float");
				return {
					getMaxAnisotropy: function() {
						if (void 0 !== r) return r;
						var n = t.get("EXT_texture_filter_anisotropic");
						return r = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
					},
					getMaxPrecision: i,
					precision: o,
					logarithmicDepthBuffer: s,
					maxTextures: c,
					maxVertexTextures: l,
					maxTextureSize: u,
					maxCubemapSize: h,
					maxAttributes: d,
					maxVertexUniforms: f,
					maxVaryings: v,
					maxFragmentUniforms: p,
					vertexTextures: m,
					floatFragmentTextures: g,
					floatVertexTextures: m && g
				}
			}

			function pt(e, t, n, i) {
				ue.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
			}

			function mt(e) {
				pt.call(this), this.cameras = e || []
			}

			function gt(e) {
				function t() {
					if (null !== r && r.isPresenting) {
						var t = r.getEyeParameters("left"),
							i = t.renderWidth,
							o = t.renderHeight;
						f = e.getPixelRatio(), d = e.getSize(), e.setDrawingBufferSize(2 * i, o, 1)
					} else n.enabled && e.setDrawingBufferSize(d.width, d.height, f)
				}
				var n = this,
					r = null,
					o = null,
					a = null;
				"undefined" != typeof window && "VRFrameData" in window && (o = new window.VRFrameData);
				var s = new i,
					l = new pt;
				l.bounds = new c(0, 0, .5, 1), l.layers.enable(1);
				var u = new pt;
				u.bounds = new c(.5, 0, .5, 1), u.layers.enable(2);
				var h = new mt([l, u]);
				h.layers.enable(1), h.layers.enable(2);
				var d, f;
				"undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", t, !1), this.enabled = !1, this.getDevice = function() {
					return r
				}, this.setDevice = function(e) {
					void 0 !== e && (r = e)
				}, this.setPoseTarget = function(e) {
					void 0 !== e && (a = e)
				}, this.getCamera = function(e) {
					if (null === r) return e;
					r.depthNear = e.near, r.depthFar = e.far, r.getFrameData(o);
					var t = o.pose,
						n = null !== a ? a : e;
					if (null !== t.position ? n.position.fromArray(t.position) : n.position.set(0, 0, 0), null !== t.orientation && n.quaternion.fromArray(t.orientation), n.updateMatrixWorld(), !1 === r.isPresenting) return e;
					l.near = e.near, u.near = e.near, l.far = e.far, u.far = e.far, h.matrixWorld.copy(e.matrixWorld), h.matrixWorldInverse.copy(e.matrixWorldInverse), l.matrixWorldInverse.fromArray(o.leftViewMatrix), u.matrixWorldInverse.fromArray(o.rightViewMatrix);
					var i = n.parent;
					null !== i && (s.getInverse(i.matrixWorld), l.matrixWorldInverse.multiply(s), u.matrixWorldInverse.multiply(s)), l.matrixWorld.getInverse(l.matrixWorldInverse), u.matrixWorld.getInverse(u.matrixWorldInverse), l.projectionMatrix.fromArray(o.leftProjectionMatrix), u.projectionMatrix.fromArray(o.rightProjectionMatrix), h.projectionMatrix.copy(l.projectionMatrix);
					var c = r.getLayers();
					if (c.length) {
						var d = c[0];
						null !== d.leftBounds && 4 === d.leftBounds.length && l.bounds.fromArray(d.leftBounds), null !== d.rightBounds && 4 === d.rightBounds.length && u.bounds.fromArray(d.rightBounds)
					}
					return h
				}, this.submitFrame = function() {
					r && r.isPresenting && r.submitFrame()
				}, this.dispose = function() {
					"undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", t)
				}
			}

			function yt(e) {
				var t = {};
				return {
					get: function(n) {
						if (void 0 !== t[n]) return t[n];
						var i;
						switch (n) {
							case "WEBGL_depth_texture":
								i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
								break;
							case "EXT_texture_filter_anisotropic":
								i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
								break;
							case "WEBGL_compressed_texture_s3tc":
								i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
								break;
							case "WEBGL_compressed_texture_pvrtc":
								i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
								break;
							case "WEBGL_compressed_texture_etc1":
								i = e.getExtension("WEBGL_compressed_texture_etc1");
								break;
							default:
								i = e.getExtension(n)
						}
						return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = i, i
					}
				}
			}

			function xt() {
				function e() {
					u.value !== i && (u.value = i, u.needsUpdate = r > 0), n.numPlanes = r, n.numIntersection = 0
				}

				function t(e, t, i, r) {
					var o = null !== e ? e.length : 0,
						a = null;
					if (0 !== o) {
						if (a = u.value, !0 !== r || null === a) {
							var s = i + 4 * o,
								h = t.matrixWorldInverse;
							l.getNormalMatrix(h), (null === a || a.length < s) && (a = new Float32Array(s));
							for (var d = 0, f = i; d !== o; ++d, f += 4) c.copy(e[d]).applyMatrix4(h, l), c.normal.toArray(a, f), a[f + 3] = c.constant
						}
						u.value = a, u.needsUpdate = !0
					}
					return n.numPlanes = o, a
				}
				var n = this,
					i = null,
					r = 0,
					o = !1,
					s = !1,
					c = new ie,
					l = new a,
					u = {
						value: null,
						needsUpdate: !1
					};
				this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, n, a) {
					var s = 0 !== e.length || n || 0 !== r || o;
					return o = n, i = t(e, a, 0), r = e.length, s
				}, this.beginShadows = function() {
					s = !0, t(null)
				}, this.endShadows = function() {
					s = !1, e()
				}, this.setState = function(n, a, c, l, h, d) {
					if (!o || null === n || 0 === n.length || s && !c) s ? t(null) : e();
					else {
						var f = s ? 0 : r,
							v = 4 * f,
							p = h.clippingState || null;
						u.value = p, p = t(n, l, v, d);
						for (var m = 0; m !== v; ++m) p[m] = i[m];
						h.clippingState = p, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += f
					}
				}
			}

			function bt(e, t) {
				return {
					convert: function(n) {
						var i;
						if (n === xa) return e.REPEAT;
						if (n === ba) return e.CLAMP_TO_EDGE;
						if (n === wa) return e.MIRRORED_REPEAT;
						if (n === Ma) return e.NEAREST;
						if (n === _a) return e.NEAREST_MIPMAP_NEAREST;
						if (n === Sa) return e.NEAREST_MIPMAP_LINEAR;
						if (n === Ea) return e.LINEAR;
						if (n === Ta) return e.LINEAR_MIPMAP_NEAREST;
						if (n === Pa) return e.LINEAR_MIPMAP_LINEAR;
						if (n === Aa) return e.UNSIGNED_BYTE;
						if (n === Da) return e.UNSIGNED_SHORT_4_4_4_4;
						if (n === Fa) return e.UNSIGNED_SHORT_5_5_5_1;
						if (n === Ua) return e.UNSIGNED_SHORT_5_6_5;
						if (n === La) return e.BYTE;
						if (n === Ca) return e.SHORT;
						if (n === za) return e.UNSIGNED_SHORT;
						if (n === Ra) return e.INT;
						if (n === Ia) return e.UNSIGNED_INT;
						if (n === ja) return e.FLOAT;
						if (n === Oa && null !== (i = t.get("OES_texture_half_float"))) return i.HALF_FLOAT_OES;
						if (n === Na) return e.ALPHA;
						if (n === Ba) return e.RGB;
						if (n === Ga) return e.RGBA;
						if (n === Ha) return e.LUMINANCE;
						if (n === Va) return e.LUMINANCE_ALPHA;
						if (n === Ya) return e.DEPTH_COMPONENT;
						if (n === Xa) return e.DEPTH_STENCIL;
						if (n === jo) return e.FUNC_ADD;
						if (n === Oo) return e.FUNC_SUBTRACT;
						if (n === Do) return e.FUNC_REVERSE_SUBTRACT;
						if (n === ko) return e.ZERO;
						if (n === No) return e.ONE;
						if (n === Bo) return e.SRC_COLOR;
						if (n === Go) return e.ONE_MINUS_SRC_COLOR;
						if (n === Ho) return e.SRC_ALPHA;
						if (n === Vo) return e.ONE_MINUS_SRC_ALPHA;
						if (n === Wo) return e.DST_ALPHA;
						if (n === Yo) return e.ONE_MINUS_DST_ALPHA;
						if (n === Xo) return e.DST_COLOR;
						if (n === qo) return e.ONE_MINUS_DST_COLOR;
						if (n === Zo) return e.SRC_ALPHA_SATURATE;
						if ((n === qa || n === Za || n === Ka || n === Ja) && null !== (i = t.get("WEBGL_compressed_texture_s3tc"))) {
							if (n === qa) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
							if (n === Za) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
							if (n === Ka) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
							if (n === Ja) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
						}
						if ((n === Qa || n === $a || n === es || n === ts) && null !== (i = t.get("WEBGL_compressed_texture_pvrtc"))) {
							if (n === Qa) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
							if (n === $a) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
							if (n === es) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
							if (n === ts) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (n === ns && null !== (i = t.get("WEBGL_compressed_texture_etc1"))) return i.COMPRESSED_RGB_ETC1_WEBGL;
						if ((n === Fo || n === Uo) && null !== (i = t.get("EXT_blend_minmax"))) {
							if (n === Fo) return i.MIN_EXT;
							if (n === Uo) return i.MAX_EXT
						}
						return n === ka && null !== (i = t.get("WEBGL_depth_texture")) ? i.UNSIGNED_INT_24_8_WEBGL : 0
					}
				}
			}

			function wt(e) {
				function t() {
					return null === ee ? pe : 1
				}

				function n() {
					(Le = new yt(Pe)).get("WEBGL_depth_texture"), Le.get("OES_texture_float"), Le.get("OES_texture_float_linear"), Le.get("OES_texture_half_float"), Le.get("OES_texture_half_float_linear"), Le.get("OES_standard_derivatives"), Le.get("OES_element_index_uint"), Le.get("ANGLE_instanced_arrays"), et = new bt(Pe, Le), Ce = new vt(Pe, Le, e), (ze = new ft(Pe, Le, et)).scissor(ue.copy(ge).multiplyScalar(pe)), ze.viewport(le.copy(me).multiplyScalar(pe)), Re = new dt, Ie = new ht(Pe, Le, ze, Re, Ce, et, Ee), je = new ae(Pe), Oe = new Ye(Pe, je, Ee), De = new Ze(Oe, Te), Xe = new He(Pe), ke = new ut(Q, Le, Ce), Ue = new qe, Ne = new Be, Ge = new Fe(Q, ze, Oe, B), Ke = new We(Pe, Le, Te), Je = new Ve(Pe, Le, Te), Qe = new Z(Q, Pe, ze, Ie, Ce), $e = new J(Q, Pe, ze, Ie, Ce), Q.info.programs = ke.programs, Q.context = Pe, Q.capabilities = Ce, Q.extensions = Le, Q.properties = Re, Q.renderLists = Ne, Q.state = ze
				}

				function r(e) {
					e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $ = !0
				}

				function a() {
					console.log("THREE.WebGLRenderer: Context Restored."), $ = !1, n()
				}

				function s(e) {
					var t = e.target;
					t.removeEventListener("dispose", s), l(t)
				}

				function l(e) {
					u(e), Re.remove(e)
				}

				function u(e) {
					var t = Re.get(e).program;
					e.program = void 0, void 0 !== t && ke.releaseProgram(t)
				}

				function d(e, t, n) {
					e.render(function(e) {
						Q.renderBufferImmediate(e, t, n)
					})
				}

				function f(e, t, n, i) {
					if (n && n.isInstancedBufferGeometry && null === Le.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
					else {
						void 0 === i && (i = 0), ze.initAttributes();
						var r = n.attributes,
							o = t.getAttributes(),
							a = e.defaultAttributeValues;
						for (var s in o) {
							var c = o[s];
							if (c >= 0) {
								var l = r[s];
								if (void 0 !== l) {
									var u = l.normalized,
										h = l.itemSize,
										d = je.get(l);
									if (void 0 === d) continue;
									var f = d.buffer,
										v = d.type,
										p = d.bytesPerElement;
									if (l.isInterleavedBufferAttribute) {
										var m = l.data,
											g = m.stride,
											y = l.offset;
										m && m.isInstancedInterleavedBuffer ? (ze.enableAttributeAndDivisor(c, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : ze.enableAttribute(c), Pe.bindBuffer(Pe.ARRAY_BUFFER, f), Pe.vertexAttribPointer(c, h, v, u, g * p, (i * g + y) * p)
									} else l.isInstancedBufferAttribute ? (ze.enableAttributeAndDivisor(c, l.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = l.meshPerAttribute * l.count)) : ze.enableAttribute(c), Pe.bindBuffer(Pe.ARRAY_BUFFER, f), Pe.vertexAttribPointer(c, h, v, u, 0, i * h * p)
								} else if (void 0 !== a) {
									var x = a[s];
									if (void 0 !== x) switch (x.length) {
										case 2:
											Pe.vertexAttrib2fv(c, x);
											break;
										case 3:
											Pe.vertexAttrib3fv(c, x);
											break;
										case 4:
											Pe.vertexAttrib4fv(c, x);
											break;
										default:
											Pe.vertexAttrib1fv(c, x)
									}
								}
							}
						}
						ze.disableUnusedAttributes()
					}
				}

				function v() {
					if (!it) {
						var e = tt.getDevice();
						e && e.isPresenting ? e.requestAnimationFrame(p) : window.requestAnimationFrame(p), it = !0
					}
				}

				function p(e) {
					null !== rt && rt(e);
					var t = tt.getDevice();
					t && t.isPresenting ? t.requestAnimationFrame(p) : window.requestAnimationFrame(p)
				}

				function m(e, t, n) {
					if (!1 !== e.visible) {
						if (e.layers.test(t.layers))
							if (e.isLight) V.push(e), e.castShadow && W.push(e);
							else if (e.isSprite) e.frustumCulled && !xe.intersectsSprite(e) || q.push(e);
						else if (e.isLensFlare) K.push(e);
						else if (e.isImmediateRenderObject) n && Se.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_e), X.push(e, null, e.material, Se.z, null);
						else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || xe.intersectsObject(e))) {
							n && Se.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_e);
							var i = De.update(e),
								r = e.material;
							if (Array.isArray(r))
								for (var o = i.groups, a = 0, s = o.length; a < s; a++) {
									var c = o[a],
										l = r[c.materialIndex];
									l && l.visible && X.push(e, i, l, Se.z, c)
								} else r.visible && X.push(e, i, r, Se.z, null)
						}
						for (var u = e.children, a = 0, s = u.length; a < s; a++) m(u[a], t, n)
					}
				}

				function g(e, t, n, i) {
					for (var r = 0, o = e.length; r < o; r++) {
						var a = e[r],
							s = a.object,
							c = a.geometry,
							l = void 0 === i ? a.material : i,
							u = a.group;
						if (n.isArrayCamera) {
							ce = n;
							for (var h = n.cameras, d = 0, f = h.length; d < f; d++) {
								var v = h[d];
								if (s.layers.test(v.layers)) {
									var p = v.bounds,
										m = p.x * fe,
										g = p.y * ve,
										x = p.z * fe,
										b = p.w * ve;
									ze.viewport(le.set(m, g, x, b).multiplyScalar(pe)), y(s, t, v, c, l, u)
								}
							}
						} else ce = null, y(s, t, n, c, l, u)
					}
				}

				function y(e, t, n, i, r, o) {
					if (e.onBeforeRender(Q, t, n, i, r, o), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
						var a = e.isMesh && e.matrixWorld.determinant() < 0;
						ze.setMaterial(r, a);
						var s = b(n, t.fog, r, e);
						ie = "", d(e, s, r)
					} else Q.renderBufferDirect(n, t.fog, i, r, e, o);
					e.onAfterRender(Q, t, n, i, r, o)
				}

				function x(e, t, n) {
					var i = Re.get(e),
						r = ke.getParameters(e, Ue.state, W, t, be.numPlanes, be.numIntersection, n),
						o = ke.getProgramCode(e, r),
						a = i.program,
						c = !0;
					if (void 0 === a) e.addEventListener("dispose", s);
					else if (a.code !== o) u(e);
					else {
						if (void 0 !== r.shaderID) return;
						c = !1
					}
					if (c) {
						if (r.shaderID) {
							var l = Cs[r.shaderID];
							i.shader = {
								name: e.type,
								uniforms: As.clone(l.uniforms),
								vertexShader: l.vertexShader,
								fragmentShader: l.fragmentShader
							}
						} else i.shader = {
							name: e.type,
							uniforms: e.uniforms,
							vertexShader: e.vertexShader,
							fragmentShader: e.fragmentShader
						};
						e.onBeforeCompile(i.shader), a = ke.acquireProgram(e, i.shader, r, o), i.program = a, e.program = a
					}
					var h = a.getAttributes();
					if (e.morphTargets) {
						e.numSupportedMorphTargets = 0;
						for (d = 0; d < Q.maxMorphTargets; d++) h["morphTarget" + d] >= 0 && e.numSupportedMorphTargets++
					}
					if (e.morphNormals) {
						e.numSupportedMorphNormals = 0;
						for (var d = 0; d < Q.maxMorphNormals; d++) h["morphNormal" + d] >= 0 && e.numSupportedMorphNormals++
					}
					var f = i.shader.uniforms;
					(e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = be.numPlanes, i.numIntersection = be.numIntersection, f.clippingPlanes = be.uniform), i.fog = t, i.lightsHash = Ue.state.hash, e.lights && (f.ambientLightColor.value = Ue.state.ambient, f.directionalLights.value = Ue.state.directional, f.spotLights.value = Ue.state.spot, f.rectAreaLights.value = Ue.state.rectArea, f.pointLights.value = Ue.state.point, f.hemisphereLights.value = Ue.state.hemi, f.directionalShadowMap.value = Ue.state.directionalShadowMap, f.directionalShadowMatrix.value = Ue.state.directionalShadowMatrix, f.spotShadowMap.value = Ue.state.spotShadowMap, f.spotShadowMatrix.value = Ue.state.spotShadowMatrix, f.pointShadowMap.value = Ue.state.pointShadowMap, f.pointShadowMatrix.value = Ue.state.pointShadowMatrix);
					var v = i.program.getUniforms(),
						p = Y.seqWithValue(v.seq, f);
					i.uniformsList = p
				}

				function b(e, t, n, i) {
					de = 0;
					var r = Re.get(n);
					if (we && (Me || e !== se)) {
						var o = e === se && n.id === ne;
						be.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, r, o)
					}!1 === n.needsUpdate && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== t ? n.needsUpdate = !0 : n.lights && r.lightsHash !== Ue.state.hash ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === be.numPlanes && r.numIntersection === be.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (x(n, t, i), n.needsUpdate = !1);
					var a = !1,
						s = !1,
						c = !1,
						l = r.program,
						u = l.getUniforms(),
						d = r.shader.uniforms;
					if (ze.useProgram(l.program) && (a = !0, s = !0, c = !0), n.id !== ne && (ne = n.id, s = !0), a || e !== se) {
						if (u.setValue(Pe, "projectionMatrix", e.projectionMatrix), Ce.logarithmicDepthBuffer && u.setValue(Pe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), se !== (ce || e) && (se = ce || e, s = !0, c = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
							var f = u.map.cameraPosition;
							void 0 !== f && f.setValue(Pe, Se.setFromMatrixPosition(e.matrixWorld))
						}(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && u.setValue(Pe, "viewMatrix", e.matrixWorldInverse)
					}
					if (n.skinning) {
						u.setOptional(Pe, i, "bindMatrix"), u.setOptional(Pe, i, "bindMatrixInverse");
						var v = i.skeleton;
						if (v) {
							var p = v.bones;
							if (Ce.floatVertexTextures) {
								if (void 0 === v.boneTexture) {
									var m = Math.sqrt(4 * p.length);
									m = gs.ceilPowerOfTwo(m), m = Math.max(m, 4);
									var g = new Float32Array(m * m * 4);
									g.set(v.boneMatrices);
									var y = new h(g, m, m, Ga, ja);
									v.boneMatrices = g, v.boneTexture = y, v.boneTextureSize = m
								}
								u.setValue(Pe, "boneTexture", v.boneTexture), u.setValue(Pe, "boneTextureSize", v.boneTextureSize)
							} else u.setOptional(Pe, v, "boneMatrices")
						}
					}
					return s && (u.setValue(Pe, "toneMappingExposure", Q.toneMappingExposure), u.setValue(Pe, "toneMappingWhitePoint", Q.toneMappingWhitePoint), n.lights && j(d, c), t && n.fog && E(d, t), n.isMeshBasicMaterial ? w(d, n) : n.isMeshLambertMaterial ? (w(d, n), T(d, n)) : n.isMeshPhongMaterial ? (w(d, n), n.isMeshToonMaterial ? A(d, n) : P(d, n)) : n.isMeshStandardMaterial ? (w(d, n), n.isMeshPhysicalMaterial ? C(d, n) : L(d, n)) : n.isMeshDepthMaterial ? (w(d, n), z(d, n)) : n.isMeshDistanceMaterial ? (w(d, n), R(d, n)) : n.isMeshNormalMaterial ? (w(d, n), I(d, n)) : n.isLineBasicMaterial ? (M(d, n), n.isLineDashedMaterial && _(d, n)) : n.isPointsMaterial ? S(d, n) : n.isShadowMaterial && (d.color.value = n.color, d.opacity.value = n.opacity), void 0 !== d.ltcMat && (d.ltcMat.value = Ps.LTC_MAT_TEXTURE), void 0 !== d.ltcMag && (d.ltcMag.value = Ps.LTC_MAG_TEXTURE), Y.upload(Pe, r.uniformsList, d, Q)), u.setValue(Pe, "modelViewMatrix", i.modelViewMatrix), u.setValue(Pe, "normalMatrix", i.normalMatrix), u.setValue(Pe, "modelMatrix", i.matrixWorld), l
				}

				function w(e, t) {
					e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity);
					var n;
					if (t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n) {
						if (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate) {
							var i = n.offset,
								r = n.repeat,
								o = n.rotation,
								a = n.center;
							n.matrix.setUvTransform(i.x, i.y, r.x, r.y, o, a.x, a.y)
						}
						e.uvTransform.value.copy(n.matrix)
					}
				}

				function M(e, t) {
					e.diffuse.value = t.color, e.opacity.value = t.opacity
				}

				function _(e, t) {
					e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
				}

				function S(e, t) {
					if (e.diffuse.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size * pe, e.scale.value = .5 * ve, e.map.value = t.map, null !== t.map) {
						if (!0 === t.map.matrixAutoUpdate) {
							var n = t.map.offset,
								i = t.map.repeat,
								r = t.map.rotation,
								o = t.map.center;
							t.map.matrix.setUvTransform(n.x, n.y, i.x, i.y, r, o.x, o.y)
						}
						e.uvTransform.value.copy(t.map.matrix)
					}
				}

				function E(e, t) {
					e.fogColor.value = t.color, t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
				}

				function T(e, t) {
					t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
				}

				function P(e, t) {
					e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
				}

				function A(e, t) {
					P(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap)
				}

				function L(e, t) {
					e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
				}

				function C(e, t) {
					e.clearCoat.value = t.clearCoat, e.clearCoatRoughness.value = t.clearCoatRoughness, L(e, t)
				}

				function z(e, t) {
					t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
				}

				function R(e, t) {
					t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
				}

				function I(e, t) {
					t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
				}

				function j(e, t) {
					e.ambientLightColor.needsUpdate = t, e.directionalLights.needsUpdate = t, e.pointLights.needsUpdate = t, e.spotLights.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
				}
				console.log("THREE.WebGLRenderer", vo);
				var O = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
					D = void 0 !== e.context ? e.context : null,
					F = void 0 !== e.alpha && e.alpha,
					U = void 0 === e.depth || e.depth,
					k = void 0 === e.stencil || e.stencil,
					N = void 0 !== e.antialias && e.antialias,
					B = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
					G = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
					H = void 0 !== e.powerPreference ? e.powerPreference : "default",
					V = [],
					W = [],
					X = null,
					q = [],
					K = [];
				this.domElement = O, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = ca, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
				var Q = this,
					$ = !1,
					ee = null,
					te = null,
					ne = -1,
					ie = "",
					se = null,
					ce = null,
					le = new c,
					ue = new c,
					he = null,
					de = 0,
					fe = O.width,
					ve = O.height,
					pe = 1,
					me = new c(0, 0, fe, ve),
					ge = new c(0, 0, fe, ve),
					ye = !1,
					xe = new re,
					be = new xt,
					we = !1,
					Me = !1,
					_e = new i,
					Se = new o,
					Ee = {
						geometries: 0,
						textures: 0
					},
					Te = {
						frame: 0,
						calls: 0,
						vertices: 0,
						faces: 0,
						points: 0
					};
				this.info = {
					render: Te,
					memory: Ee,
					programs: null
				};
				var Pe;
				try {
					var Ae = {
						alpha: F,
						depth: U,
						stencil: k,
						antialias: N,
						premultipliedAlpha: B,
						preserveDrawingBuffer: G,
						powerPreference: H
					};
					if (O.addEventListener("webglcontextlost", r, !1), O.addEventListener("webglcontextrestored", a, !1), null === (Pe = D || O.getContext("webgl", Ae) || O.getContext("experimental-webgl", Ae))) throw null !== O.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
					void 0 === Pe.getShaderPrecisionFormat && (Pe.getShaderPrecisionFormat = function() {
						return {
							rangeMin: 1,
							rangeMax: 1,
							precision: 1
						}
					})
				} catch (e) {
					console.error("THREE.WebGLRenderer: " + e.message)
				}
				var Le, Ce, ze, Re, Ie, je, Oe, De, Ue, ke, Ne, Ge, Xe, Ke, Je, Qe, $e, et;
				n();
				var tt = new gt(Q);
				this.vr = tt;
				var nt = new oe(Q, De, Ce.maxTextureSize);
				this.shadowMap = nt, this.getContext = function() {
					return Pe
				}, this.getContextAttributes = function() {
					return Pe.getContextAttributes()
				}, this.forceContextLoss = function() {
					var e = Le.get("WEBGL_lose_context");
					e && e.loseContext()
				}, this.forceContextRestore = function() {
					var e = Le.get("WEBGL_lose_context");
					e && e.restoreContext()
				}, this.getPixelRatio = function() {
					return pe
				}, this.setPixelRatio = function(e) {
					void 0 !== e && (pe = e, this.setSize(fe, ve, !1))
				}, this.getSize = function() {
					return {
						width: fe,
						height: ve
					}
				}, this.setSize = function(e, t, n) {
					var i = tt.getDevice();
					i && i.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (fe = e, ve = t, O.width = e * pe, O.height = t * pe, !1 !== n && (O.style.width = e + "px", O.style.height = t + "px"), this.setViewport(0, 0, e, t))
				}, this.getDrawingBufferSize = function() {
					return {
						width: fe * pe,
						height: ve * pe
					}
				}, this.setDrawingBufferSize = function(e, t, n) {
					fe = e, ve = t, pe = n, O.width = e * n, O.height = t * n, this.setViewport(0, 0, e, t)
				}, this.setViewport = function(e, t, n, i) {
					me.set(e, ve - t - i, n, i), ze.viewport(le.copy(me).multiplyScalar(pe))
				}, this.setScissor = function(e, t, n, i) {
					ge.set(e, ve - t - i, n, i), ze.scissor(ue.copy(ge).multiplyScalar(pe))
				}, this.setScissorTest = function(e) {
					ze.setScissorTest(ye = e)
				}, this.getClearColor = function() {
					return Ge.getClearColor()
				}, this.setClearColor = function() {
					Ge.setClearColor.apply(Ge, arguments)
				}, this.getClearAlpha = function() {
					return Ge.getClearAlpha()
				}, this.setClearAlpha = function() {
					Ge.setClearAlpha.apply(Ge, arguments)
				}, this.clear = function(e, t, n) {
					var i = 0;
					(void 0 === e || e) && (i |= Pe.COLOR_BUFFER_BIT), (void 0 === t || t) && (i |= Pe.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= Pe.STENCIL_BUFFER_BIT), Pe.clear(i)
				}, this.clearColor = function() {
					this.clear(!0, !1, !1)
				}, this.clearDepth = function() {
					this.clear(!1, !0, !1)
				}, this.clearStencil = function() {
					this.clear(!1, !1, !0)
				}, this.clearTarget = function(e, t, n, i) {
					this.setRenderTarget(e), this.clear(t, n, i)
				}, this.dispose = function() {
					O.removeEventListener("webglcontextlost", r, !1), O.removeEventListener("webglcontextrestored", a, !1), Ne.dispose(), tt.dispose()
				}, this.renderBufferImmediate = function(e, t, n) {
					ze.initAttributes();
					var i = Re.get(e);
					e.hasPositions && !i.position && (i.position = Pe.createBuffer()), e.hasNormals && !i.normal && (i.normal = Pe.createBuffer()), e.hasUvs && !i.uv && (i.uv = Pe.createBuffer()), e.hasColors && !i.color && (i.color = Pe.createBuffer());
					var r = t.getAttributes();
					if (e.hasPositions && (Pe.bindBuffer(Pe.ARRAY_BUFFER, i.position), Pe.bufferData(Pe.ARRAY_BUFFER, e.positionArray, Pe.DYNAMIC_DRAW), ze.enableAttribute(r.position), Pe.vertexAttribPointer(r.position, 3, Pe.FLOAT, !1, 0, 0)), e.hasNormals) {
						if (Pe.bindBuffer(Pe.ARRAY_BUFFER, i.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && !0 === n.flatShading)
							for (var o = 0, a = 3 * e.count; o < a; o += 9) {
								var s = e.normalArray,
									c = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
									l = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
									u = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
								s[o + 0] = c, s[o + 1] = l, s[o + 2] = u, s[o + 3] = c, s[o + 4] = l, s[o + 5] = u, s[o + 6] = c, s[o + 7] = l, s[o + 8] = u
							}
						Pe.bufferData(Pe.ARRAY_BUFFER, e.normalArray, Pe.DYNAMIC_DRAW), ze.enableAttribute(r.normal), Pe.vertexAttribPointer(r.normal, 3, Pe.FLOAT, !1, 0, 0)
					}
					e.hasUvs && n.map && (Pe.bindBuffer(Pe.ARRAY_BUFFER, i.uv), Pe.bufferData(Pe.ARRAY_BUFFER, e.uvArray, Pe.DYNAMIC_DRAW), ze.enableAttribute(r.uv), Pe.vertexAttribPointer(r.uv, 2, Pe.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== Eo && (Pe.bindBuffer(Pe.ARRAY_BUFFER, i.color), Pe.bufferData(Pe.ARRAY_BUFFER, e.colorArray, Pe.DYNAMIC_DRAW), ze.enableAttribute(r.color), Pe.vertexAttribPointer(r.color, 3, Pe.FLOAT, !1, 0, 0)), ze.disableUnusedAttributes(), Pe.drawArrays(Pe.TRIANGLES, 0, e.count), e.count = 0
				}, this.renderBufferDirect = function(e, n, i, r, o, a) {
					var s = o.isMesh && o.matrixWorld.determinant() < 0;
					ze.setMaterial(r, s);
					var c = b(e, n, r, o),
						l = i.id + "_" + c.id + "_" + (!0 === r.wireframe),
						u = !1;
					l !== ie && (ie = l, u = !0), o.morphTargetInfluences && (Xe.update(o, i, r, c), u = !0);
					var h = i.index,
						d = i.attributes.position,
						v = 1;
					!0 === r.wireframe && (h = Oe.getWireframeAttribute(i), v = 2);
					var p, m = Ke;
					null !== h && (p = je.get(h), (m = Je).setIndex(p)), u && (f(r, c, i), null !== h && Pe.bindBuffer(Pe.ELEMENT_ARRAY_BUFFER, p.buffer));
					var g = 0;
					null !== h ? g = h.count : void 0 !== d && (g = d.count);
					var y = i.drawRange.start * v,
						x = i.drawRange.count * v,
						w = null !== a ? a.start * v : 0,
						M = null !== a ? a.count * v : 1 / 0,
						_ = Math.max(y, w),
						S = Math.min(g, y + x, w + M) - 1,
						E = Math.max(0, S - _ + 1);
					if (0 !== E) {
						if (o.isMesh)
							if (!0 === r.wireframe) ze.setLineWidth(r.wireframeLinewidth * t()), m.setMode(Pe.LINES);
							else switch (o.drawMode) {
								case os:
									m.setMode(Pe.TRIANGLES);
									break;
								case as:
									m.setMode(Pe.TRIANGLE_STRIP);
									break;
								case ss:
									m.setMode(Pe.TRIANGLE_FAN)
							} else if (o.isLine) {
								var T = r.linewidth;
								void 0 === T && (T = 1), ze.setLineWidth(T * t()), o.isLineSegments ? m.setMode(Pe.LINES) : o.isLineLoop ? m.setMode(Pe.LINE_LOOP) : m.setMode(Pe.LINE_STRIP)
							} else o.isPoints && m.setMode(Pe.POINTS);
						i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && m.renderInstances(i, _, E) : m.render(_, E)
					}
				}, this.compile = function(e, t) {
					V.length = 0, W.length = 0, e.traverse(function(e) {
						e.isLight && (V.push(e), e.castShadow && W.push(e))
					}), Ue.setup(V, W, t), e.traverse(function(t) {
						if (t.material)
							if (Array.isArray(t.material))
								for (var n = 0; n < t.material.length; n++) x(t.material[n], e.fog, t);
							else x(t.material, e.fog, t)
					})
				};
				var it = !1,
					rt = null;
				this.animate = function(e) {
					rt = e, v()
				}, this.render = function(e, t, n, i) {
					if (t && t.isCamera) {
						if (!$) {
							ie = "", ne = -1, se = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), tt.enabled && (t = tt.getCamera(t)), _e.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), xe.setFromMatrix(_e), V.length = 0, W.length = 0, q.length = 0, K.length = 0, Me = this.localClippingEnabled, we = be.init(this.clippingPlanes, Me, t), (X = Ne.get(e, t)).init(), m(e, t, Q.sortObjects), !0 === Q.sortObjects && X.sort(), Ie.updateVideoTextures(), we && be.beginShadows(), nt.render(W, e, t), Ue.setup(V, W, t), we && be.endShadows(), Te.frame++, Te.calls = 0, Te.vertices = 0, Te.faces = 0, Te.points = 0, void 0 === n && (n = null), this.setRenderTarget(n), Ge.render(X, e, t, i);
							var r = X.opaque,
								o = X.transparent;
							if (e.overrideMaterial) {
								var a = e.overrideMaterial;
								r.length && g(r, e, t, a), o.length && g(o, e, t, a)
							} else r.length && g(r, e, t), o.length && g(o, e, t);
							$e.render(q, e, t), Qe.render(K, e, t, le), n && Ie.updateRenderTargetMipmap(n), ze.buffers.depth.setTest(!0), ze.buffers.depth.setMask(!0), ze.buffers.color.setMask(!0), ze.setPolygonOffset(!1), tt.enabled && tt.submitFrame()
						}
					} else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
				}, this.setFaceCulling = function(e, t) {
					ze.setCullFace(e), ze.setFlipSided(t === xo)
				}, this.allocTextureUnit = function() {
					var e = de;
					return e >= Ce.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + Ce.maxTextures), de += 1, e
				}, this.setTexture2D = function() {
					var e = !1;
					return function(t, n) {
						t && t.isWebGLRenderTarget && (e || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), Ie.setTexture2D(t, n)
					}
				}(), this.setTexture = function() {
					var e = !1;
					return function(t, n) {
						e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e = !0), Ie.setTexture2D(t, n)
					}
				}(), this.setTextureCube = function() {
					var e = !1;
					return function(t, n) {
						t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? Ie.setTextureCube(t, n) : Ie.setTextureCubeDynamic(t, n)
					}
				}(), this.getRenderTarget = function() {
					return ee
				}, this.setRenderTarget = function(e) {
					ee = e, e && void 0 === Re.get(e).__webglFramebuffer && Ie.setupRenderTarget(e);
					var t = null,
						n = !1;
					if (e) {
						var i = Re.get(e).__webglFramebuffer;
						e.isWebGLRenderTargetCube ? (t = i[e.activeCubeFace], n = !0) : t = i, le.copy(e.viewport), ue.copy(e.scissor), he = e.scissorTest
					} else le.copy(me).multiplyScalar(pe), ue.copy(ge).multiplyScalar(pe), he = ye;
					if (te !== t && (Pe.bindFramebuffer(Pe.FRAMEBUFFER, t), te = t), ze.viewport(le), ze.scissor(ue), ze.setScissorTest(he), n) {
						var r = Re.get(e.texture);
						Pe.framebufferTexture2D(Pe.FRAMEBUFFER, Pe.COLOR_ATTACHMENT0, Pe.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, r.__webglTexture, e.activeMipMapLevel)
					}
				}, this.readRenderTargetPixels = function(e, t, n, i, r, o) {
					if (e && e.isWebGLRenderTarget) {
						var a = Re.get(e).__webglFramebuffer;
						if (a) {
							var s = !1;
							a !== te && (Pe.bindFramebuffer(Pe.FRAMEBUFFER, a), s = !0);
							try {
								var c = e.texture,
									l = c.format,
									u = c.type;
								if (l !== Ga && et.convert(l) !== Pe.getParameter(Pe.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
								if (!(u === Aa || et.convert(u) === Pe.getParameter(Pe.IMPLEMENTATION_COLOR_READ_TYPE) || u === ja && (Le.get("OES_texture_float") || Le.get("WEBGL_color_buffer_float")) || u === Oa && Le.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
								Pe.checkFramebufferStatus(Pe.FRAMEBUFFER) === Pe.FRAMEBUFFER_COMPLETE ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Pe.readPixels(t, n, i, r, et.convert(l), et.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
							} finally {
								s && Pe.bindFramebuffer(Pe.FRAMEBUFFER, te)
							}
						}
					} else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
				}
			}

			function Mt(e, t) {
				this.name = "", this.color = new X(e), this.density = void 0 !== t ? t : 25e-5
			}

			function _t(e, t, n) {
				this.name = "", this.color = new X(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
			}

			function St() {
				le.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
			}

			function Et(e, t, n, i, r) {
				le.call(this), this.lensFlares = [], this.positionScreen = new o, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, n, i, r)
			}

			function Tt(e) {
				Q.call(this), this.type = "SpriteMaterial", this.color = new X(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(e)
			}

			function Pt(e) {
				le.call(this), this.type = "Sprite", this.material = void 0 !== e ? e : new Tt
			}

			function At() {
				le.call(this), this.type = "LOD", Object.defineProperties(this, {
					levels: {
						enumerable: !0,
						value: []
					}
				})
			}

			function Lt(e, t) {
				if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
				else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
				else {
					console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
					for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new i)
				}
			}

			function Ct() {
				le.call(this), this.type = "Bone"
			}

			function zt(e, t) {
				De.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new i, this.bindMatrixInverse = new i;
				var n = new Lt(this.initBones());
				this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
			}

			function Rt(e) {
				Q.call(this), this.type = "LineBasicMaterial", this.color = new X(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e)
			}

			function It(e, t, n) {
				if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new jt(e, t);
				le.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Te, this.material = void 0 !== t ? t : new Rt({
					color: 16777215 * Math.random()
				})
			}

			function jt(e, t) {
				It.call(this, e, t), this.type = "LineSegments"
			}

			function Ot(e, t) {
				It.call(this, e, t), this.type = "LineLoop"
			}

			function Dt(e) {
				Q.call(this), this.type = "PointsMaterial", this.color = new X(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(e)
			}

			function Ft(e, t) {
				le.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Te, this.material = void 0 !== t ? t : new Dt({
					color: 16777215 * Math.random()
				})
			}

			function Ut() {
				le.call(this), this.type = "Group"
			}

			function kt(e, t, n, i, r, o, a, c, l) {
				function u() {
					e.removeEventListener("loadeddata", u, !1), h.needsUpdate = !0
				}
				s.call(this, e, t, n, i, r, o, a, c, l), this.generateMipmaps = !1;
				var h = this;
				e.addEventListener("loadeddata", u, !1)
			}

			function Nt(e, t, n, i, r, o, a, c, l, u, h, d) {
				s.call(this, null, o, a, c, l, u, i, r, h, d), this.image = {
					width: t,
					height: n
				}, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
			}

			function Bt(e, t, n, i, r, o, a, c, l, u) {
				if ((u = void 0 !== u ? u : Ya) !== Ya && u !== Xa) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
				void 0 === n && u === Ya && (n = za), void 0 === n && u === Xa && (n = ka), s.call(this, null, i, r, o, a, c, u, n, l), this.image = {
					width: e,
					height: t
				}, this.magFilter = void 0 !== a ? a : Ma, this.minFilter = void 0 !== c ? c : Ma, this.flipY = !1, this.generateMipmaps = !1
			}

			function Gt(e) {
				Te.call(this), this.type = "WireframeGeometry";
				var t, n, i, r, a, s, c, l, u, h, d = [],
					f = [0, 0],
					v = {},
					p = ["a", "b", "c"];
				if (e && e.isGeometry) {
					var m = e.faces;
					for (t = 0, i = m.length; t < i; t++) {
						var g = m[t];
						for (n = 0; n < 3; n++) c = g[p[n]], l = g[p[(n + 1) % 3]], f[0] = Math.min(c, l), f[1] = Math.max(c, l), void 0 === v[u = f[0] + "," + f[1]] && (v[u] = {
							index1: f[0],
							index2: f[1]
						})
					}
					for (u in v) s = v[u], h = e.vertices[s.index1], d.push(h.x, h.y, h.z), h = e.vertices[s.index2], d.push(h.x, h.y, h.z)
				} else if (e && e.isBufferGeometry) {
					var y, x, b, w, M, _, S;
					if (h = new o, null !== e.index) {
						for (y = e.attributes.position, x = e.index, 0 === (b = e.groups).length && (b = [{
								start: 0,
								count: x.count,
								materialIndex: 0
							}]), r = 0, a = b.length; r < a; ++r)
							for (t = M = (w = b[r]).start, i = M + w.count; t < i; t += 3)
								for (n = 0; n < 3; n++) c = x.getX(t + n), l = x.getX(t + (n + 1) % 3), f[0] = Math.min(c, l), f[1] = Math.max(c, l), void 0 === v[u = f[0] + "," + f[1]] && (v[u] = {
									index1: f[0],
									index2: f[1]
								});
						for (u in v) s = v[u], h.fromBufferAttribute(y, s.index1), d.push(h.x, h.y, h.z), h.fromBufferAttribute(y, s.index2), d.push(h.x, h.y, h.z)
					} else
						for (t = 0, i = (y = e.attributes.position).count / 3; t < i; t++)
							for (n = 0; n < 3; n++) _ = 3 * t + n, h.fromBufferAttribute(y, _), d.push(h.x, h.y, h.z), S = 3 * t + (n + 1) % 3, h.fromBufferAttribute(y, S), d.push(h.x, h.y, h.z)
				}
				this.addAttribute("position", new Me(d, 3))
			}

			function Ht(e, t, n) {
				fe.call(this), this.type = "ParametricGeometry", this.parameters = {
					func: e,
					slices: t,
					stacks: n
				}, this.fromBufferGeometry(new Vt(e, t, n)), this.mergeVertices()
			}

			function Vt(e, t, n) {
				Te.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
					func: e,
					slices: t,
					stacks: n
				};
				var i, r, a = [],
					s = [],
					c = [],
					l = [],
					u = new o,
					h = new o,
					d = new o,
					f = new o,
					v = new o,
					p = t + 1;
				for (i = 0; i <= n; i++) {
					var m = i / n;
					for (r = 0; r <= t; r++) {
						var g = r / t;
						h = e(g, m, h), s.push(h.x, h.y, h.z), g - 1e-5 >= 0 ? (d = e(g - 1e-5, m, d), f.subVectors(h, d)) : (d = e(g + 1e-5, m, d), f.subVectors(d, h)), m - 1e-5 >= 0 ? (d = e(g, m - 1e-5, d), v.subVectors(h, d)) : (d = e(g, m + 1e-5, d), v.subVectors(d, h)), u.crossVectors(f, v).normalize(), c.push(u.x, u.y, u.z), l.push(g, m)
					}
				}
				for (i = 0; i < n; i++)
					for (r = 0; r < t; r++) {
						var y = i * p + r,
							x = i * p + r + 1,
							b = (i + 1) * p + r + 1,
							w = (i + 1) * p + r;
						a.push(y, x, w), a.push(x, b, w)
					}
				this.setIndex(a), this.addAttribute("position", new Me(s, 3)), this.addAttribute("normal", new Me(c, 3)), this.addAttribute("uv", new Me(l, 2))
			}

			function Wt(e, t, n, i) {
				fe.call(this), this.type = "PolyhedronGeometry", this.parameters = {
					vertices: e,
					indices: t,
					radius: n,
					detail: i
				}, this.fromBufferGeometry(new Yt(e, t, n, i)), this.mergeVertices()
			}

			function Yt(e, t, i, r) {
				function a(e, t, n, i) {
					var r, o, a = Math.pow(2, i),
						s = [];
					for (r = 0; r <= a; r++) {
						s[r] = [];
						var l = e.clone().lerp(n, r / a),
							u = t.clone().lerp(n, r / a),
							h = a - r;
						for (o = 0; o <= h; o++) s[r][o] = 0 === o && r === a ? l : l.clone().lerp(u, o / h)
					}
					for (r = 0; r < a; r++)
						for (o = 0; o < 2 * (a - r) - 1; o++) {
							var d = Math.floor(o / 2);
							o % 2 == 0 ? (c(s[r][d + 1]), c(s[r + 1][d]), c(s[r][d])) : (c(s[r][d + 1]), c(s[r + 1][d + 1]), c(s[r + 1][d]))
						}
				}

				function s() {
					for (var e = 0; e < p.length; e += 6) {
						var t = p[e + 0],
							n = p[e + 2],
							i = p[e + 4],
							r = Math.max(t, n, i),
							o = Math.min(t, n, i);
						r > .9 && o < .1 && (t < .2 && (p[e + 0] += 1), n < .2 && (p[e + 2] += 1), i < .2 && (p[e + 4] += 1))
					}
				}

				function c(e) {
					v.push(e.x, e.y, e.z)
				}

				function l(t, n) {
					var i = 3 * t;
					n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
				}

				function u() {
					for (var e = new o, t = new o, i = new o, r = new o, a = new n, s = new n, c = new n, l = 0, u = 0; l < v.length; l += 9, u += 6) {
						e.set(v[l + 0], v[l + 1], v[l + 2]), t.set(v[l + 3], v[l + 4], v[l + 5]), i.set(v[l + 6], v[l + 7], v[l + 8]), a.set(p[u + 0], p[u + 1]), s.set(p[u + 2], p[u + 3]), c.set(p[u + 4], p[u + 5]), r.copy(e).add(t).add(i).divideScalar(3);
						var f = d(r);
						h(a, u + 0, e, f), h(s, u + 2, t, f), h(c, u + 4, i, f)
					}
				}

				function h(e, t, n, i) {
					i < 0 && 1 === e.x && (p[t] = e.x - 1), 0 === n.x && 0 === n.z && (p[t] = i / 2 / Math.PI + .5)
				}

				function d(e) {
					return Math.atan2(e.z, -e.x)
				}

				function f(e) {
					return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
				}
				Te.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
					vertices: e,
					indices: t,
					radius: i,
					detail: r
				}, i = i || 1;
				var v = [],
					p = [];
				! function(e) {
					for (var n = new o, i = new o, r = new o, s = 0; s < t.length; s += 3) l(t[s + 0], n), l(t[s + 1], i), l(t[s + 2], r), a(n, i, r, e)
				}(r = r || 0),
				function(e) {
					for (var t = new o, n = 0; n < v.length; n += 3) t.x = v[n + 0], t.y = v[n + 1], t.z = v[n + 2], t.normalize().multiplyScalar(e), v[n + 0] = t.x, v[n + 1] = t.y, v[n + 2] = t.z
				}(i),
				function() {
					for (var e = new o, t = 0; t < v.length; t += 3) {
						e.x = v[t + 0], e.y = v[t + 1], e.z = v[t + 2];
						var n = d(e) / 2 / Math.PI + .5,
							i = f(e) / Math.PI + .5;
						p.push(n, 1 - i)
					}
					u(), s()
				}(), this.addAttribute("position", new Me(v, 3)), this.addAttribute("normal", new Me(v.slice(), 3)), this.addAttribute("uv", new Me(p, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
			}

			function Xt(e, t) {
				fe.call(this), this.type = "TetrahedronGeometry", this.parameters = {
					radius: e,
					detail: t
				}, this.fromBufferGeometry(new qt(e, t)), this.mergeVertices()
			}

			function qt(e, t) {
				var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
					i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
				Yt.call(this, n, i, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
					radius: e,
					detail: t
				}
			}

			function Zt(e, t) {
				fe.call(this), this.type = "OctahedronGeometry", this.parameters = {
					radius: e,
					detail: t
				}, this.fromBufferGeometry(new Kt(e, t)), this.mergeVertices()
			}

			function Kt(e, t) {
				var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
					i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
				Yt.call(this, n, i, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
					radius: e,
					detail: t
				}
			}

			function Jt(e, t) {
				fe.call(this), this.type = "IcosahedronGeometry", this.parameters = {
					radius: e,
					detail: t
				}, this.fromBufferGeometry(new Qt(e, t)), this.mergeVertices()
			}

			function Qt(e, t) {
				var n = (1 + Math.sqrt(5)) / 2,
					i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
					r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
				Yt.call(this, i, r, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
					radius: e,
					detail: t
				}
			}

			function $t(e, t) {
				fe.call(this), this.type = "DodecahedronGeometry", this.parameters = {
					radius: e,
					detail: t
				}, this.fromBufferGeometry(new en(e, t)), this.mergeVertices()
			}

			function en(e, t) {
				var n = (1 + Math.sqrt(5)) / 2,
					i = 1 / n,
					r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i],
					o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
				Yt.call(this, r, o, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
					radius: e,
					detail: t
				}
			}

			function tn(e, t, n, i, r, o) {
				fe.call(this), this.type = "TubeGeometry", this.parameters = {
					path: e,
					tubularSegments: t,
					radius: n,
					radialSegments: i,
					closed: r
				}, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
				var a = new nn(e, t, n, i, r);
				this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
			}

			function nn(e, t, i, r, a) {
				function s(n) {
					m = e.getPointAt(n / t, m);
					var o = u.normals[n],
						a = u.binormals[n];
					for (d = 0; d <= r; d++) {
						var s = d / r * Math.PI * 2,
							c = Math.sin(s),
							l = -Math.cos(s);
						v.x = l * o.x + c * a.x, v.y = l * o.y + c * a.y, v.z = l * o.z + c * a.z, v.normalize(), y.push(v.x, v.y, v.z), f.x = m.x + i * v.x, f.y = m.y + i * v.y, f.z = m.z + i * v.z, g.push(f.x, f.y, f.z)
					}
				}

				function c() {
					for (d = 1; d <= t; d++)
						for (h = 1; h <= r; h++) {
							var e = (r + 1) * (d - 1) + (h - 1),
								n = (r + 1) * d + (h - 1),
								i = (r + 1) * d + h,
								o = (r + 1) * (d - 1) + h;
							b.push(e, n, o), b.push(n, i, o)
						}
				}

				function l() {
					for (h = 0; h <= t; h++)
						for (d = 0; d <= r; d++) p.x = h / t, p.y = d / r, x.push(p.x, p.y)
				}
				Te.call(this), this.type = "TubeBufferGeometry", this.parameters = {
					path: e,
					tubularSegments: t,
					radius: i,
					radialSegments: r,
					closed: a
				}, t = t || 64, i = i || 1, r = r || 8, a = a || !1;
				var u = e.computeFrenetFrames(t, a);
				this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
				var h, d, f = new o,
					v = new o,
					p = new n,
					m = new o,
					g = [],
					y = [],
					x = [],
					b = [];
				! function() {
					for (h = 0; h < t; h++) s(h);
					s(!1 === a ? t : 0), l(), c()
				}(), this.setIndex(b), this.addAttribute("position", new Me(g, 3)), this.addAttribute("normal", new Me(y, 3)), this.addAttribute("uv", new Me(x, 2))
			}

			function rn(e, t, n, i, r, o, a) {
				fe.call(this), this.type = "TorusKnotGeometry", this.parameters = {
					radius: e,
					tube: t,
					tubularSegments: n,
					radialSegments: i,
					p: r,
					q: o
				}, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new on(e, t, n, i, r, o)), this.mergeVertices()
			}

			function on(e, t, n, i, r, a) {
				function s(e, t, n, i, r) {
					var o = Math.cos(e),
						a = Math.sin(e),
						s = n / t * e,
						c = Math.cos(s);
					r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * a * .5, r.z = i * Math.sin(s) * .5
				}
				Te.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
					radius: e,
					tube: t,
					tubularSegments: n,
					radialSegments: i,
					p: r,
					q: a
				}, e = e || 1, t = t || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, a = a || 3;
				var c, l, u = [],
					h = [],
					d = [],
					f = [],
					v = new o,
					p = new o,
					m = new o,
					g = new o,
					y = new o,
					x = new o,
					b = new o;
				for (c = 0; c <= n; ++c) {
					var w = c / n * r * Math.PI * 2;
					for (s(w, r, a, e, m), s(w + .01, r, a, e, g), x.subVectors(g, m), b.addVectors(g, m), y.crossVectors(x, b), b.crossVectors(y, x), y.normalize(), b.normalize(), l = 0; l <= i; ++l) {
						var M = l / i * Math.PI * 2,
							_ = -t * Math.cos(M),
							S = t * Math.sin(M);
						v.x = m.x + (_ * b.x + S * y.x), v.y = m.y + (_ * b.y + S * y.y), v.z = m.z + (_ * b.z + S * y.z), h.push(v.x, v.y, v.z), p.subVectors(v, m).normalize(), d.push(p.x, p.y, p.z), f.push(c / n), f.push(l / i)
					}
				}
				for (l = 1; l <= n; l++)
					for (c = 1; c <= i; c++) {
						var E = (i + 1) * (l - 1) + (c - 1),
							T = (i + 1) * l + (c - 1),
							P = (i + 1) * l + c,
							A = (i + 1) * (l - 1) + c;
						u.push(E, T, A), u.push(T, P, A)
					}
				this.setIndex(u), this.addAttribute("position", new Me(h, 3)), this.addAttribute("normal", new Me(d, 3)), this.addAttribute("uv", new Me(f, 2))
			}

			function an(e, t, n, i, r) {
				fe.call(this), this.type = "TorusGeometry", this.parameters = {
					radius: e,
					tube: t,
					radialSegments: n,
					tubularSegments: i,
					arc: r
				}, this.fromBufferGeometry(new sn(e, t, n, i, r)), this.mergeVertices()
			}

			function sn(e, t, n, i, r) {
				Te.call(this), this.type = "TorusBufferGeometry", this.parameters = {
					radius: e,
					tube: t,
					radialSegments: n,
					tubularSegments: i,
					arc: r
				}, e = e || 1, t = t || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
				var a, s, c = [],
					l = [],
					u = [],
					h = [],
					d = new o,
					f = new o,
					v = new o;
				for (a = 0; a <= n; a++)
					for (s = 0; s <= i; s++) {
						var p = s / i * r,
							m = a / n * Math.PI * 2;
						f.x = (e + t * Math.cos(m)) * Math.cos(p), f.y = (e + t * Math.cos(m)) * Math.sin(p), f.z = t * Math.sin(m), l.push(f.x, f.y, f.z), d.x = e * Math.cos(p), d.y = e * Math.sin(p), v.subVectors(f, d).normalize(), u.push(v.x, v.y, v.z), h.push(s / i), h.push(a / n)
					}
				for (a = 1; a <= n; a++)
					for (s = 1; s <= i; s++) {
						var g = (i + 1) * a + s - 1,
							y = (i + 1) * (a - 1) + s - 1,
							x = (i + 1) * (a - 1) + s,
							b = (i + 1) * a + s;
						c.push(g, y, b), c.push(y, x, b)
					}
				this.setIndex(c), this.addAttribute("position", new Me(l, 3)), this.addAttribute("normal", new Me(u, 3)), this.addAttribute("uv", new Me(h, 2))
			}

			function cn(e, t, n, i, r) {
				var o, a;
				if (r === On(e, t, n, i) > 0)
					for (o = t; o < n; o += i) a = Rn(o, e[o], e[o + 1], a);
				else
					for (o = n - i; o >= t; o -= i) a = Rn(o, e[o], e[o + 1], a);
				return a && Tn(a, a.next) && (In(a), a = a.next), a
			}

			function ln(e, t) {
				if (!e) return e;
				t || (t = e);
				var n, i = e;
				do {
					if (n = !1, i.steiner || !Tn(i, i.next) && 0 !== En(i.prev, i, i.next)) i = i.next;
					else {
						if (In(i), (i = t = i.prev) === i.next) break;
						n = !0
					}
				} while (n || i !== t);
				return t
			}

			function un(e, t, n, i, r, o, a) {
				if (e) {
					!a && o && xn(e, i, r, o);
					for (var s, c, l = e; e.prev !== e.next;)
						if (s = e.prev, c = e.next, o ? dn(e, i, r, o) : hn(e)) t.push(s.i / n), t.push(e.i / n), t.push(c.i / n), In(e), e = c.next, l = c.next;
						else if ((e = c) === l) {
						a ? 1 === a ? un(e = fn(e, t, n), t, n, i, r, o, 2) : 2 === a && vn(e, t, n, i, r, o) : un(ln(e), t, n, i, r, o, 1);
						break
					}
				}
			}

			function hn(e) {
				var t = e.prev,
					n = e,
					i = e.next;
				if (En(t, n, i) >= 0) return !1;
				for (var r = e.next.next; r !== e.prev;) {
					if (_n(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && En(r.prev, r, r.next) >= 0) return !1;
					r = r.next
				}
				return !0
			}

			function dn(e, t, n, i) {
				var r = e.prev,
					o = e,
					a = e.next;
				if (En(r, o, a) >= 0) return !1;
				for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, c = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, u = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, h = wn(s, c, t, n, i), d = wn(l, u, t, n, i), f = e.nextZ; f && f.z <= d;) {
					if (f !== e.prev && f !== e.next && _n(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && En(f.prev, f, f.next) >= 0) return !1;
					f = f.nextZ
				}
				for (f = e.prevZ; f && f.z >= h;) {
					if (f !== e.prev && f !== e.next && _n(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && En(f.prev, f, f.next) >= 0) return !1;
					f = f.prevZ
				}
				return !0
			}

			function fn(e, t, n) {
				var i = e;
				do {
					var r = i.prev,
						o = i.next.next;
					!Tn(r, o) && Pn(r, i, i.next, o) && Ln(r, o) && Ln(o, r) && (t.push(r.i / n), t.push(i.i / n), t.push(o.i / n), In(i), In(i.next), i = e = o), i = i.next
				} while (i !== e);
				return i
			}

			function vn(e, t, n, i, r, o) {
				var a = e;
				do {
					for (var s = a.next.next; s !== a.prev;) {
						if (a.i !== s.i && Sn(a, s)) {
							var c = zn(a, s);
							return a = ln(a, a.next), c = ln(c, c.next), un(a, t, n, i, r, o), void un(c, t, n, i, r, o)
						}
						s = s.next
					}
					a = a.next
				} while (a !== e)
			}

			function pn(e, t, n, i) {
				var r, o, a, s = [];
				for (r = 0, o = t.length; r < o; r++)(a = cn(e, t[r] * i, r < o - 1 ? t[r + 1] * i : e.length, i, !1)) === a.next && (a.steiner = !0), s.push(Mn(a));
				for (s.sort(mn), r = 0; r < s.length; r++) gn(s[r], n), n = ln(n, n.next);
				return n
			}

			function mn(e, t) {
				return e.x - t.x
			}

			function gn(e, t) {
				if (t = yn(e, t)) {
					var n = zn(t, e);
					ln(n, n.next)
				}
			}

			function yn(e, t) {
				var n, i = t,
					r = e.x,
					o = e.y,
					a = -1 / 0;
				do {
					if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
						var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
						if (s <= r && s > a) {
							if (a = s, s === r) {
								if (o === i.y) return i;
								if (o === i.next.y) return i.next
							}
							n = i.x < i.next.x ? i : i.next
						}
					}
					i = i.next
				} while (i !== t);
				if (!n) return null;
				if (r === a) return n.prev;
				var c, l = n,
					u = n.x,
					h = n.y,
					d = 1 / 0;
				for (i = n.next; i !== l;) r >= i.x && i.x >= u && r !== i.x && _n(o < h ? r : a, o, u, h, o < h ? a : r, o, i.x, i.y) && ((c = Math.abs(o - i.y) / (r - i.x)) < d || c === d && i.x > n.x) && Ln(i, e) && (n = i, d = c), i = i.next;
				return n
			}

			function xn(e, t, n, i) {
				var r = e;
				do {
					null === r.z && (r.z = wn(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
				} while (r !== e);
				r.prevZ.nextZ = null, r.prevZ = null, bn(r)
			}

			function bn(e) {
				var t, n, i, r, o, a, s, c, l = 1;
				do {
					for (n = e, e = null, o = null, a = 0; n;) {
						for (a++, i = n, s = 0, t = 0; t < l && (s++, i = i.nextZ); t++);
						for (c = l; s > 0 || c > 0 && i;) 0 !== s && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : e = r, r.prevZ = o, o = r;
						n = i
					}
					o.nextZ = null, l *= 2
				} while (a > 1);
				return e
			}

			function wn(e, t, n, i, r) {
				return e = 32767 * (e - n) * r, t = 32767 * (t - i) * r, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e | t << 1
			}

			function Mn(e) {
				var t = e,
					n = e;
				do {
					t.x < n.x && (n = t), t = t.next
				} while (t !== e);
				return n
			}

			function _n(e, t, n, i, r, o, a, s) {
				return (r - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (i - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
			}

			function Sn(e, t) {
				return e.next.i !== t.i && e.prev.i !== t.i && !An(e, t) && Ln(e, t) && Ln(t, e) && Cn(e, t)
			}

			function En(e, t, n) {
				return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
			}

			function Tn(e, t) {
				return e.x === t.x && e.y === t.y
			}

			function Pn(e, t, n, i) {
				return !!(Tn(e, t) && Tn(n, i) || Tn(e, i) && Tn(n, t)) || En(e, t, n) > 0 != En(e, t, i) > 0 && En(n, i, e) > 0 != En(n, i, t) > 0
			}

			function An(e, t) {
				var n = e;
				do {
					if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Pn(n, n.next, e, t)) return !0;
					n = n.next
				} while (n !== e);
				return !1
			}

			function Ln(e, t) {
				return En(e.prev, e, e.next) < 0 ? En(e, t, e.next) >= 0 && En(e, e.prev, t) >= 0 : En(e, t, e.prev) < 0 || En(e, e.next, t) < 0
			}

			function Cn(e, t) {
				var n = e,
					i = !1,
					r = (e.x + t.x) / 2,
					o = (e.y + t.y) / 2;
				do {
					n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
				} while (n !== e);
				return i
			}

			function zn(e, t) {
				var n = new jn(e.i, e.x, e.y),
					i = new jn(t.i, t.x, t.y),
					r = e.next,
					o = t.prev;
				return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
			}

			function Rn(e, t, n, i) {
				var r = new jn(e, t, n);
				return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
			}

			function In(e) {
				e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
			}

			function jn(e, t, n) {
				this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
			}

			function On(e, t, n, i) {
				for (var r = 0, o = t, a = n - i; o < n; o += i) r += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
				return r
			}

			function Dn(e, t) {
				fe.call(this), this.type = "ExtrudeGeometry", this.parameters = {
					shapes: e,
					options: t
				}, this.fromBufferGeometry(new Fn(e, t)), this.mergeVertices()
			}

			function Fn(e, t) {
				void 0 !== e && (Te.call(this), this.type = "ExtrudeBufferGeometry", e = Array.isArray(e) ? e : [e], this.addShapeList(e, t), this.computeVertexNormals())
			}

			function Un(e, t) {
				fe.call(this), this.type = "TextGeometry", this.parameters = {
					text: e,
					parameters: t
				}, this.fromBufferGeometry(new kn(e, t)), this.mergeVertices()
			}

			function kn(e, t) {
				var n = (t = t || {}).font;
				if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new fe;
				var i = n.generateShapes(e, t.size, t.curveSegments);
				t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Fn.call(this, i, t), this.type = "TextBufferGeometry"
			}

			function Nn(e, t, n, i, r, o, a) {
				fe.call(this), this.type = "SphereGeometry", this.parameters = {
					radius: e,
					widthSegments: t,
					heightSegments: n,
					phiStart: i,
					phiLength: r,
					thetaStart: o,
					thetaLength: a
				}, this.fromBufferGeometry(new Bn(e, t, n, i, r, o, a)), this.mergeVertices()
			}

			function Bn(e, t, n, i, r, a, s) {
				Te.call(this), this.type = "SphereBufferGeometry", this.parameters = {
					radius: e,
					widthSegments: t,
					heightSegments: n,
					phiStart: i,
					phiLength: r,
					thetaStart: a,
					thetaLength: s
				}, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
				var c, l, u = (a = void 0 !== a ? a : 0) + (s = void 0 !== s ? s : Math.PI),
					h = 0,
					d = [],
					f = new o,
					v = new o,
					p = [],
					m = [],
					g = [],
					y = [];
				for (l = 0; l <= n; l++) {
					var x = [],
						b = l / n;
					for (c = 0; c <= t; c++) {
						var w = c / t;
						f.x = -e * Math.cos(i + w * r) * Math.sin(a + b * s), f.y = e * Math.cos(a + b * s), f.z = e * Math.sin(i + w * r) * Math.sin(a + b * s), m.push(f.x, f.y, f.z), v.set(f.x, f.y, f.z).normalize(), g.push(v.x, v.y, v.z), y.push(w, 1 - b), x.push(h++)
					}
					d.push(x)
				}
				for (l = 0; l < n; l++)
					for (c = 0; c < t; c++) {
						var M = d[l][c + 1],
							_ = d[l][c],
							S = d[l + 1][c],
							E = d[l + 1][c + 1];
						(0 !== l || a > 0) && p.push(M, _, E), (l !== n - 1 || u < Math.PI) && p.push(_, S, E)
					}
				this.setIndex(p), this.addAttribute("position", new Me(m, 3)), this.addAttribute("normal", new Me(g, 3)), this.addAttribute("uv", new Me(y, 2))
			}

			function Gn(e, t, n, i, r, o) {
				fe.call(this), this.type = "RingGeometry", this.parameters = {
					innerRadius: e,
					outerRadius: t,
					thetaSegments: n,
					phiSegments: i,
					thetaStart: r,
					thetaLength: o
				}, this.fromBufferGeometry(new Hn(e, t, n, i, r, o)), this.mergeVertices()
			}

			function Hn(e, t, i, r, a, s) {
				Te.call(this), this.type = "RingBufferGeometry", this.parameters = {
					innerRadius: e,
					outerRadius: t,
					thetaSegments: i,
					phiSegments: r,
					thetaStart: a,
					thetaLength: s
				}, e = e || .5, t = t || 1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
				var c, l, u, h = [],
					d = [],
					f = [],
					v = [],
					p = e,
					m = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
					g = new o,
					y = new n;
				for (l = 0; l <= r; l++) {
					for (u = 0; u <= i; u++) c = a + u / i * s, g.x = p * Math.cos(c), g.y = p * Math.sin(c), d.push(g.x, g.y, g.z), f.push(0, 0, 1), y.x = (g.x / t + 1) / 2, y.y = (g.y / t + 1) / 2, v.push(y.x, y.y);
					p += m
				}
				for (l = 0; l < r; l++) {
					var x = l * (i + 1);
					for (u = 0; u < i; u++) {
						var b = c = u + x,
							w = c + i + 1,
							M = c + i + 2,
							_ = c + 1;
						h.push(b, w, _), h.push(w, M, _)
					}
				}
				this.setIndex(h), this.addAttribute("position", new Me(d, 3)), this.addAttribute("normal", new Me(f, 3)), this.addAttribute("uv", new Me(v, 2))
			}

			function Vn(e, t, n, i) {
				fe.call(this), this.type = "LatheGeometry", this.parameters = {
					points: e,
					segments: t,
					phiStart: n,
					phiLength: i
				}, this.fromBufferGeometry(new Wn(e, t, n, i)), this.mergeVertices()
			}

			function Wn(e, t, i, r) {
				Te.call(this), this.type = "LatheBufferGeometry", this.parameters = {
					points: e,
					segments: t,
					phiStart: i,
					phiLength: r
				}, t = Math.floor(t) || 12, i = i || 0, r = r || 2 * Math.PI, r = gs.clamp(r, 0, 2 * Math.PI);
				var a, s, c, l = [],
					u = [],
					h = [],
					d = 1 / t,
					f = new o,
					v = new n;
				for (s = 0; s <= t; s++) {
					var p = i + s * d * r,
						m = Math.sin(p),
						g = Math.cos(p);
					for (c = 0; c <= e.length - 1; c++) f.x = e[c].x * m, f.y = e[c].y, f.z = e[c].x * g, u.push(f.x, f.y, f.z), v.x = s / t, v.y = c / (e.length - 1), h.push(v.x, v.y)
				}
				for (s = 0; s < t; s++)
					for (c = 0; c < e.length - 1; c++) {
						var y = a = c + s * e.length,
							x = a + e.length,
							b = a + e.length + 1,
							w = a + 1;
						l.push(y, x, w), l.push(x, b, w)
					}
				if (this.setIndex(l), this.addAttribute("position", new Me(u, 3)), this.addAttribute("uv", new Me(h, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
					var M = this.attributes.normal.array,
						_ = new o,
						S = new o,
						E = new o;
					for (a = t * e.length * 3, s = 0, c = 0; s < e.length; s++, c += 3) _.x = M[c + 0], _.y = M[c + 1], _.z = M[c + 2], S.x = M[a + c + 0], S.y = M[a + c + 1], S.z = M[a + c + 2], E.addVectors(_, S).normalize(), M[c + 0] = M[a + c + 0] = E.x, M[c + 1] = M[a + c + 1] = E.y, M[c + 2] = M[a + c + 2] = E.z
				}
			}

			function Yn(e, t) {
				fe.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
					shapes: e,
					curveSegments: t
				}, this.fromBufferGeometry(new Xn(e, t)), this.mergeVertices()
			}

			function Xn(e, t) {
				function n(e) {
					var n, s, l, u = r.length / 3,
						h = e.extractPoints(t),
						d = h.shape,
						f = h.holes;
					if (!1 === Fs.isClockWise(d))
						for (d = d.reverse(), n = 0, s = f.length; n < s; n++) l = f[n], !0 === Fs.isClockWise(l) && (f[n] = l.reverse());
					var v = Fs.triangulateShape(d, f);
					for (n = 0, s = f.length; n < s; n++) l = f[n], d = d.concat(l);
					for (n = 0, s = d.length; n < s; n++) {
						var p = d[n];
						r.push(p.x, p.y, 0), o.push(0, 0, 1), a.push(p.x, p.y)
					}
					for (n = 0, s = v.length; n < s; n++) {
						var m = v[n],
							g = m[0] + u,
							y = m[1] + u,
							x = m[2] + u;
						i.push(g, y, x), c += 3
					}
				}
				Te.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
					shapes: e,
					curveSegments: t
				}, t = t || 12;
				var i = [],
					r = [],
					o = [],
					a = [],
					s = 0,
					c = 0;
				if (!1 === Array.isArray(e)) n(e);
				else
					for (var l = 0; l < e.length; l++) n(e[l]), this.addGroup(s, c, l), s += c, c = 0;
				this.setIndex(i), this.addAttribute("position", new Me(r, 3)), this.addAttribute("normal", new Me(o, 3)), this.addAttribute("uv", new Me(a, 2))
			}

			function qn(e, t) {
				if (t.shapes = [], Array.isArray(e))
					for (var n = 0, i = e.length; n < i; n++) {
						var r = e[n];
						t.shapes.push(r.uuid)
					} else t.shapes.push(e.uuid);
				return t
			}

			function Zn(e, t) {
				Te.call(this), this.type = "EdgesGeometry", this.parameters = {
					thresholdAngle: t
				}, t = void 0 !== t ? t : 1;
				var n, i, r, o, a = [],
					s = Math.cos(gs.DEG2RAD * t),
					c = [0, 0],
					l = {},
					u = ["a", "b", "c"];
				e.isBufferGeometry ? (o = new fe).fromBufferGeometry(e) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
				for (var h = o.vertices, d = o.faces, f = 0, v = d.length; f < v; f++)
					for (var p = d[f], m = 0; m < 3; m++) n = p[u[m]], i = p[u[(m + 1) % 3]], c[0] = Math.min(n, i), c[1] = Math.max(n, i), void 0 === l[r = c[0] + "," + c[1]] ? l[r] = {
						index1: c[0],
						index2: c[1],
						face1: f,
						face2: void 0
					} : l[r].face2 = f;
				for (r in l) {
					var g = l[r];
					if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
						var y = h[g.index1];
						a.push(y.x, y.y, y.z), y = h[g.index2], a.push(y.x, y.y, y.z)
					}
				}
				this.addAttribute("position", new Me(a, 3))
			}

			function Kn(e, t, n, i, r, o, a, s) {
				fe.call(this), this.type = "CylinderGeometry", this.parameters = {
					radiusTop: e,
					radiusBottom: t,
					height: n,
					radialSegments: i,
					heightSegments: r,
					openEnded: o,
					thetaStart: a,
					thetaLength: s
				}, this.fromBufferGeometry(new Jn(e, t, n, i, r, o, a, s)), this.mergeVertices()
			}

			function Jn(e, t, i, r, a, s, c, l) {
				function u(i) {
					var a, s, u, g = new n,
						b = new o,
						w = 0,
						M = !0 === i ? e : t,
						_ = !0 === i ? 1 : -1;
					for (s = m, a = 1; a <= r; a++) f.push(0, y * _, 0), v.push(0, _, 0), p.push(.5, .5), m++;
					for (u = m, a = 0; a <= r; a++) {
						var S = a / r * l + c,
							E = Math.cos(S),
							T = Math.sin(S);
						b.x = M * T, b.y = y * _, b.z = M * E, f.push(b.x, b.y, b.z), v.push(0, _, 0), g.x = .5 * E + .5, g.y = .5 * T * _ + .5, p.push(g.x, g.y), m++
					}
					for (a = 0; a < r; a++) {
						var P = s + a,
							A = u + a;
						!0 === i ? d.push(A, A + 1, P) : d.push(A + 1, A, P), w += 3
					}
					h.addGroup(x, w, !0 === i ? 1 : 2), x += w
				}
				Te.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
					radiusTop: e,
					radiusBottom: t,
					height: i,
					radialSegments: r,
					heightSegments: a,
					openEnded: s,
					thetaStart: c,
					thetaLength: l
				};
				var h = this;
				e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, i = i || 1, r = Math.floor(r) || 8, a = Math.floor(a) || 1, s = void 0 !== s && s, c = void 0 !== c ? c : 0, l = void 0 !== l ? l : 2 * Math.PI;
				var d = [],
					f = [],
					v = [],
					p = [],
					m = 0,
					g = [],
					y = i / 2,
					x = 0;
				! function() {
					var n, s, u = new o,
						b = new o,
						w = 0,
						M = (t - e) / i;
					for (s = 0; s <= a; s++) {
						var _ = [],
							S = s / a,
							E = S * (t - e) + e;
						for (n = 0; n <= r; n++) {
							var T = n / r,
								P = T * l + c,
								A = Math.sin(P),
								L = Math.cos(P);
							b.x = E * A, b.y = -S * i + y, b.z = E * L, f.push(b.x, b.y, b.z), u.set(A, M, L).normalize(), v.push(u.x, u.y, u.z), p.push(T, 1 - S), _.push(m++)
						}
						g.push(_)
					}
					for (n = 0; n < r; n++)
						for (s = 0; s < a; s++) {
							var C = g[s][n],
								z = g[s + 1][n],
								R = g[s + 1][n + 1],
								I = g[s][n + 1];
							d.push(C, z, I), d.push(z, R, I), w += 6
						}
					h.addGroup(x, w, 0), x += w
				}(), !1 === s && (e > 0 && u(!0), t > 0 && u(!1)), this.setIndex(d), this.addAttribute("position", new Me(f, 3)), this.addAttribute("normal", new Me(v, 3)), this.addAttribute("uv", new Me(p, 2))
			}

			function Qn(e, t, n, i, r, o, a) {
				Kn.call(this, 0, e, t, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
					radius: e,
					height: t,
					radialSegments: n,
					heightSegments: i,
					openEnded: r,
					thetaStart: o,
					thetaLength: a
				}
			}

			function $n(e, t, n, i, r, o, a) {
				Jn.call(this, 0, e, t, n, i, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
					radius: e,
					height: t,
					radialSegments: n,
					heightSegments: i,
					openEnded: r,
					thetaStart: o,
					thetaLength: a
				}
			}

			function ei(e, t, n, i) {
				fe.call(this), this.type = "CircleGeometry", this.parameters = {
					radius: e,
					segments: t,
					thetaStart: n,
					thetaLength: i
				}, this.fromBufferGeometry(new ti(e, t, n, i)), this.mergeVertices()
			}

			function ti(e, t, i, r) {
				Te.call(this), this.type = "CircleBufferGeometry", this.parameters = {
					radius: e,
					segments: t,
					thetaStart: i,
					thetaLength: r
				}, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
				var a, s, c = [],
					l = [],
					u = [],
					h = [],
					d = new o,
					f = new n;
				for (l.push(0, 0, 0), u.push(0, 0, 1), h.push(.5, .5), s = 0, a = 3; s <= t; s++, a += 3) {
					var v = i + s / t * r;
					d.x = e * Math.cos(v), d.y = e * Math.sin(v), l.push(d.x, d.y, d.z), u.push(0, 0, 1), f.x = (l[a] / e + 1) / 2, f.y = (l[a + 1] / e + 1) / 2, h.push(f.x, f.y)
				}
				for (a = 1; a <= t; a++) c.push(a, a + 1, 0);
				this.setIndex(c), this.addAttribute("position", new Me(l, 3)), this.addAttribute("normal", new Me(u, 3)), this.addAttribute("uv", new Me(h, 2))
			}

			function ni(e) {
				Q.call(this), this.type = "ShadowMaterial", this.color = new X(0), this.opacity = 1, this.lights = !0, this.transparent = !0, this.setValues(e)
			}

			function ii(e) {
				Re.call(this, e), this.type = "RawShaderMaterial"
			}

			function ri(e) {
				Q.call(this), this.defines = {
					STANDARD: ""
				}, this.type = "MeshStandardMaterial", this.color = new X(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new X(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
			}

			function oi(e) {
				ri.call(this), this.defines = {
					PHYSICAL: ""
				}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e)
			}

			function ai(e) {
				Q.call(this), this.type = "MeshPhongMaterial", this.color = new X(16777215), this.specular = new X(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new X(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ra, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
			}

			function si(e) {
				ai.call(this), this.defines = {
					TOON: ""
				}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
			}

			function ci(e) {
				Q.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
			}

			function li(e) {
				Q.call(this), this.type = "MeshLambertMaterial", this.color = new X(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new X(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ra, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
			}

			function ui(e) {
				Rt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
			}

			function hi(e, t, n) {
				var i = this,
					r = !1,
					o = 0,
					a = 0,
					s = void 0;
				this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
					a++, !1 === r && void 0 !== i.onStart && i.onStart(e, o, a), r = !0
				}, this.itemEnd = function(e) {
					o++, void 0 !== i.onProgress && i.onProgress(e, o, a), o === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
				}, this.itemError = function(e) {
					void 0 !== i.onError && i.onError(e)
				}, this.resolveURL = function(e) {
					return s ? s(e) : e
				}, this.setURLModifier = function(e) {
					return s = e, this
				}
			}

			function di(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function fi(e) {
				this.manager = void 0 !== e ? e : Bs, this._parser = null
			}

			function vi(e) {
				this.manager = void 0 !== e ? e : Bs, this._parser = null
			}

			function pi(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function mi(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function gi(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function yi() {
				this.type = "Curve", this.arcLengthDivisions = 200
			}

			function xi(e, t, n, i, r, o, a, s) {
				yi.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
			}

			function bi(e, t, n, i, r, o) {
				xi.call(this, e, t, n, n, i, r, o), this.type = "ArcCurve"
			}

			function wi() {
				function e(e, o, a, s) {
					t = e, n = a, i = -3 * e + 3 * o - 2 * a - s, r = 2 * e - 2 * o + a + s
				}
				var t = 0,
					n = 0,
					i = 0,
					r = 0;
				return {
					initCatmullRom: function(t, n, i, r, o) {
						e(n, i, o * (i - t), o * (r - n))
					},
					initNonuniformCatmullRom: function(t, n, i, r, o, a, s) {
						var c = (n - t) / o - (i - t) / (o + a) + (i - n) / a,
							l = (i - n) / a - (r - n) / (a + s) + (r - i) / s;
						e(n, i, c *= a, l *= a)
					},
					calc: function(e) {
						var o = e * e;
						return t + n * e + i * o + r * (o * e)
					}
				}
			}

			function Mi(e, t, n, i) {
				yi.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = i || .5
			}

			function _i(e, t, n, i, r) {
				var o = .5 * (i - t),
					a = .5 * (r - n),
					s = e * e;
				return (2 * n - 2 * i + o + a) * (e * s) + (-3 * n + 3 * i - 2 * o - a) * s + o * e + n
			}

			function Si(e, t) {
				var n = 1 - e;
				return n * n * t
			}

			function Ei(e, t) {
				return 2 * (1 - e) * e * t
			}

			function Ti(e, t) {
				return e * e * t
			}

			function Pi(e, t, n, i) {
				return Si(e, t) + Ei(e, n) + Ti(e, i)
			}

			function Ai(e, t) {
				var n = 1 - e;
				return n * n * n * t
			}

			function Li(e, t) {
				var n = 1 - e;
				return 3 * n * n * e * t
			}

			function Ci(e, t) {
				return 3 * (1 - e) * e * e * t
			}

			function zi(e, t) {
				return e * e * e * t
			}

			function Ri(e, t, n, i, r) {
				return Ai(e, t) + Li(e, n) + Ci(e, i) + zi(e, r)
			}

			function Ii(e, t, i, r) {
				yi.call(this), this.type = "CubicBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n, this.v3 = r || new n
			}

			function ji(e, t, n, i) {
				yi.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new o, this.v1 = t || new o, this.v2 = n || new o, this.v3 = i || new o
			}

			function Oi(e, t) {
				yi.call(this), this.type = "LineCurve", this.v1 = e || new n, this.v2 = t || new n
			}

			function Di(e, t) {
				yi.call(this), this.type = "LineCurve3", this.v1 = e || new o, this.v2 = t || new o
			}

			function Fi(e, t, i) {
				yi.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n
			}

			function Ui(e, t, n) {
				yi.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new o, this.v1 = t || new o, this.v2 = n || new o
			}

			function ki(e) {
				yi.call(this), this.type = "SplineCurve", this.points = e || []
			}

			function Ni() {
				yi.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
			}

			function Bi(e) {
				Ni.call(this), this.type = "Path", this.currentPoint = new n, e && this.setFromPoints(e)
			}

			function Gi(e) {
				Bi.call(this, e), this.uuid = gs.generateUUID(), this.type = "Shape", this.holes = []
			}

			function Hi(e, t) {
				le.call(this), this.type = "Light", this.color = new X(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
			}

			function Vi(e, t, n) {
				Hi.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(le.DefaultUp), this.updateMatrix(), this.groundColor = new X(t)
			}

			function Wi(e) {
				this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.map = null, this.matrix = new i
			}

			function Yi() {
				Wi.call(this, new pt(50, 1, .5, 500))
			}

			function Xi(e, t, n, i, r, o) {
				Hi.call(this, e, t), this.type = "SpotLight", this.position.copy(le.DefaultUp), this.updateMatrix(), this.target = new le, Object.defineProperty(this, "power", {
					get: function() {
						return this.intensity * Math.PI
					},
					set: function(e) {
						this.intensity = e / Math.PI
					}
				}), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Yi
			}

			function qi(e, t, n, i) {
				Hi.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
					get: function() {
						return 4 * this.intensity * Math.PI
					},
					set: function(e) {
						this.intensity = e / (4 * Math.PI)
					}
				}), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Wi(new pt(90, 1, .5, 500))
			}

			function Zi() {
				Wi.call(this, new he(-5, 5, 5, -5, .5, 500))
			}

			function Ki(e, t) {
				Hi.call(this, e, t), this.type = "DirectionalLight", this.position.copy(le.DefaultUp), this.updateMatrix(), this.target = new le, this.shadow = new Zi
			}

			function Ji(e, t) {
				Hi.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
			}

			function Qi(e, t, n, i) {
				Hi.call(this, e, t), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
			}

			function $i(e, t, n, i) {
				lr.call(this, e, t, n, i)
			}

			function er(e, t, n) {
				lr.call(this, e, t, n)
			}

			function tr(e, t, n, i) {
				this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n
			}

			function nr(e, t, n, i) {
				tr.call(this, e, t, n, i)
			}

			function ir(e, t, n, i) {
				lr.call(this, e, t, n, i)
			}

			function rr(e, t, n, i) {
				lr.call(this, e, t, n, i)
			}

			function or(e, t, n, i) {
				lr.call(this, e, t, n, i)
			}

			function ar(e, t, n, i) {
				tr.call(this, e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
			}

			function sr(e, t, n, i) {
				tr.call(this, e, t, n, i)
			}

			function cr(e, t, n, i) {
				tr.call(this, e, t, n, i)
			}

			function lr(e, t, n, i) {
				if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
				if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
				this.name = e, this.times = qs.convertArray(t, this.TimeBufferType), this.values = qs.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation), this.validate(), this.optimize()
			}

			function ur(e, t, n, i) {
				lr.call(this, e, t, n, i)
			}

			function hr(e, t, n) {
				this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = gs.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
			}

			function dr(e) {
				this.manager = void 0 !== e ? e : Bs, this.textures = {}
			}

			function fr(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function vr() {
				this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
			}

			function pr(e) {
				"boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : Bs, this.withCredentials = !1
			}

			function mr(e) {
				this.manager = void 0 !== e ? e : Bs, this.texturePath = ""
			}

			function gr(e) {
				"undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Bs, this.options = void 0
			}

			function yr() {
				this.type = "ShapePath", this.subPaths = [], this.currentPath = null
			}

			function xr(e) {
				this.type = "Font", this.data = e
			}

			function br(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function wr(e) {
				this.manager = void 0 !== e ? e : Bs
			}

			function Mr() {
				this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new pt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new pt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
			}

			function _r(e, t, n) {
				le.call(this), this.type = "CubeCamera";
				var i = new pt(90, 1, e, t);
				i.up.set(0, -1, 0), i.lookAt(new o(1, 0, 0)), this.add(i);
				var r = new pt(90, 1, e, t);
				r.up.set(0, -1, 0), r.lookAt(new o(-1, 0, 0)), this.add(r);
				var a = new pt(90, 1, e, t);
				a.up.set(0, 0, 1), a.lookAt(new o(0, 1, 0)), this.add(a);
				var s = new pt(90, 1, e, t);
				s.up.set(0, 0, -1), s.lookAt(new o(0, -1, 0)), this.add(s);
				var c = new pt(90, 1, e, t);
				c.up.set(0, -1, 0), c.lookAt(new o(0, 0, 1)), this.add(c);
				var l = new pt(90, 1, e, t);
				l.up.set(0, -1, 0), l.lookAt(new o(0, 0, -1)), this.add(l);
				var h = {
					format: Ba,
					magFilter: Ea,
					minFilter: Ea
				};
				this.renderTarget = new u(n, n, h), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
					null === this.parent && this.updateMatrixWorld();
					var n = this.renderTarget,
						o = n.texture.generateMipmaps;
					n.texture.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, i, n), n.activeCubeFace = 1, e.render(t, r, n), n.activeCubeFace = 2, e.render(t, a, n), n.activeCubeFace = 3, e.render(t, s, n), n.activeCubeFace = 4, e.render(t, c, n), n.texture.generateMipmaps = o, n.activeCubeFace = 5, e.render(t, l, n), e.setRenderTarget(null)
				}, this.clear = function(e, t, n, i) {
					for (var r = this.renderTarget, o = 0; o < 6; o++) r.activeCubeFace = o, e.setRenderTarget(r), e.clear(t, n, i);
					e.setRenderTarget(null)
				}
			}

			function Sr() {
				le.call(this), this.type = "AudioListener", this.context = tc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
			}

			function Er(e) {
				le.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
			}

			function Tr(e) {
				Er.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
			}

			function Pr(e, t) {
				this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
			}

			function Ar(e, t, n) {
				this.binding = e, this.valueSize = n;
				var i, r = Float64Array;
				switch (t) {
					case "quaternion":
						i = this._slerp;
						break;
					case "string":
					case "bool":
						r = Array, i = this._select;
						break;
					default:
						i = this._lerp
				}
				this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
			}

			function Lr(e, t, n) {
				var i = n || Cr.parseTrackName(t);
				this._targetGroup = e, this._bindings = e.subscribe_(t, i)
			}

			function Cr(e, t, n) {
				this.path = t, this.parsedPath = n || Cr.parseTrackName(t), this.node = Cr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
			}

			function zr() {
				this.uuid = gs.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
				var e = {};
				this._indicesByUUID = e;
				for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
				this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
				var i = this;
				this.stats = {
					objects: {
						get total() {
							return i._objects.length
						},
						get inUse() {
							return this.total - i.nCachedObjects_
						}
					},
					get bindingsPerObject() {
						return i._bindings.length
					}
				}
			}

			function Rr(e, t, n) {
				this._mixer = e, this._clip = t, this._localRoot = n || null;
				for (var i = t.tracks, r = i.length, o = new Array(r), a = {
						endingStart: rs,
						endingEnd: rs
					}, s = 0; s !== r; ++s) {
					var c = i[s].createInterpolant(null);
					o[s] = c, c.settings = a
				}
				this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = is, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
			}

			function Ir(e) {
				this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
			}

			function jr(e) {
				"string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
			}

			function Or() {
				Te.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
			}

			function Dr(e, t, n, i) {
				this.uuid = gs.generateUUID(), this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
			}

			function Fr(e, t) {
				this.uuid = gs.generateUUID(), this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
					offset: 0,
					count: -1
				}, this.onUploadCallback = function() {}, this.version = 0
			}

			function Ur(e, t, n) {
				Fr.call(this, e, t), this.meshPerAttribute = n || 1
			}

			function kr(e, t, n) {
				ve.call(this, e, t), this.meshPerAttribute = n || 1
			}

			function Nr(e, t, n, i) {
				this.ray = new Ie(e, t), this.near = n || 0, this.far = i || 1 / 0, this.params = {
					Mesh: {},
					Line: {},
					LOD: {},
					Points: {
						threshold: 1
					},
					Sprite: {}
				}, Object.defineProperties(this.params, {
					PointCloud: {
						get: function() {
							return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
						}
					}
				})
			}

			function Br(e, t) {
				return e.distance - t.distance
			}

			function Gr(e, t, n, i) {
				if (!1 !== e.visible && (e.raycast(t, n), !0 === i))
					for (var r = e.children, o = 0, a = r.length; o < a; o++) Gr(r[o], t, n, !0)
			}

			function Hr(e) {
				this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
			}

			function Vr(e, t, n) {
				return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
			}

			function Wr(e, t, n) {
				return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
			}

			function Yr(e) {
				le.call(this), this.material = e, this.render = function() {}
			}

			function Xr(e, t, n, i) {
				this.object = e, this.size = void 0 !== t ? t : 1;
				var r = void 0 !== n ? n : 16711680,
					o = void 0 !== i ? i : 1,
					a = 0,
					s = this.object.geometry;
				s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
				var c = new Te,
					l = new Me(2 * a * 3, 3);
				c.addAttribute("position", l), jt.call(this, c, new Rt({
					color: r,
					linewidth: o
				})), this.matrixAutoUpdate = !1, this.update()
			}

			function qr(e, t) {
				le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
				for (var n = new Te, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
					var a = r / 32 * Math.PI * 2,
						s = o / 32 * Math.PI * 2;
					i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
				}
				n.addAttribute("position", new Me(i, 3));
				var c = new Rt({
					fog: !1
				});
				this.cone = new jt(n, c), this.add(this.cone), this.update()
			}

			function Zr(e) {
				var t = [];
				e && e.isBone && t.push(e);
				for (var n = 0; n < e.children.length; n++) t.push.apply(t, Zr(e.children[n]));
				return t
			}

			function Kr(e) {
				for (var t = Zr(e), n = new Te, i = [], r = [], o = new X(0, 0, 1), a = new X(0, 1, 0), s = 0; s < t.length; s++) {
					var c = t[s];
					c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
				}
				n.addAttribute("position", new Me(i, 3)), n.addAttribute("color", new Me(r, 3));
				var l = new Rt({
					vertexColors: Po,
					depthTest: !1,
					depthWrite: !1,
					transparent: !0
				});
				jt.call(this, n, l), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
			}

			function Jr(e, t, n) {
				this.light = e, this.light.updateMatrixWorld(), this.color = n;
				var i = new Bn(t, 4, 2),
					r = new ze({
						wireframe: !0,
						fog: !1
					});
				De.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
			}

			function Qr(e, t) {
				le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
				var n = new Rt({
						fog: !1
					}),
					i = new Te;
				i.addAttribute("position", new ve(new Float32Array(15), 3)), this.line = new It(i, n), this.add(this.line), this.update()
			}

			function $r(e, t, n) {
				le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
				var i = new Kt(t);
				i.rotateY(.5 * Math.PI), this.material = new ze({
					wireframe: !0,
					fog: !1
				}), void 0 === this.color && (this.material.vertexColors = Po);
				var r = i.getAttribute("position"),
					o = new Float32Array(3 * r.count);
				i.addAttribute("color", new ve(o, 3)), this.add(new De(i, this.material)), this.update()
			}

			function eo(e, t, n, i) {
				e = e || 10, t = t || 10, n = new X(void 0 !== n ? n : 4473924), i = new X(void 0 !== i ? i : 8947848);
				for (var r = t / 2, o = e / t, a = e / 2, s = [], c = [], l = 0, u = 0, h = -a; l <= t; l++, h += o) {
					s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
					var d = l === r ? n : i;
					d.toArray(c, u), u += 3, d.toArray(c, u), u += 3, d.toArray(c, u), u += 3, d.toArray(c, u), u += 3
				}
				var f = new Te;
				f.addAttribute("position", new Me(s, 3)), f.addAttribute("color", new Me(c, 3));
				var v = new Rt({
					vertexColors: Po
				});
				jt.call(this, f, v)
			}

			function to(e, t, n, i, r, o) {
				e = e || 10, t = t || 16, n = n || 8, i = i || 64, r = new X(void 0 !== r ? r : 4473924), o = new X(void 0 !== o ? o : 8947848);
				var a, s, c, l, u, h, d, f = [],
					v = [];
				for (l = 0; l <= t; l++) c = l / t * (2 * Math.PI), a = Math.sin(c) * e, s = Math.cos(c) * e, f.push(0, 0, 0), f.push(a, 0, s), d = 1 & l ? r : o, v.push(d.r, d.g, d.b), v.push(d.r, d.g, d.b);
				for (l = 0; l <= n; l++)
					for (d = 1 & l ? r : o, h = e - e / n * l, u = 0; u < i; u++) c = u / i * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, f.push(a, 0, s), v.push(d.r, d.g, d.b), c = (u + 1) / i * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, f.push(a, 0, s), v.push(d.r, d.g, d.b);
				var p = new Te;
				p.addAttribute("position", new Me(f, 3)), p.addAttribute("color", new Me(v, 3));
				var m = new Rt({
					vertexColors: Po
				});
				jt.call(this, p, m)
			}

			function no(e, t, n, i) {
				this.object = e, this.size = void 0 !== t ? t : 1;
				var r = void 0 !== n ? n : 16776960,
					o = void 0 !== i ? i : 1,
					a = 0,
					s = this.object.geometry;
				s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
				var c = new Te,
					l = new Me(2 * a * 3, 3);
				c.addAttribute("position", l), jt.call(this, c, new Rt({
					color: r,
					linewidth: o
				})), this.matrixAutoUpdate = !1, this.update()
			}

			function io(e, t, n) {
				le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
				var i = new Te;
				i.addAttribute("position", new Me([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
				var r = new Rt({
					fog: !1
				});
				this.lightPlane = new It(i, r), this.add(this.lightPlane), (i = new Te).addAttribute("position", new Me([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new It(i, r), this.add(this.targetLine), this.update()
			}

			function ro(e) {
				function t(e, t, i) {
					n(e, i), n(t, i)
				}

				function n(e, t) {
					o.push(0, 0, 0), a.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(o.length / 3 - 1)
				}
				var i = new Te,
					r = new Rt({
						color: 16777215,
						vertexColors: To
					}),
					o = [],
					a = [],
					s = {},
					c = new X(16755200),
					l = new X(16711680),
					u = new X(43775),
					h = new X(16777215),
					d = new X(3355443);
				t("n1", "n2", c), t("n2", "n4", c), t("n4", "n3", c), t("n3", "n1", c), t("f1", "f2", c), t("f2", "f4", c), t("f4", "f3", c), t("f3", "f1", c), t("n1", "f1", c), t("n2", "f2", c), t("n3", "f3", c), t("n4", "f4", c), t("p", "n1", l), t("p", "n2", l), t("p", "n3", l), t("p", "n4", l), t("u1", "u2", u), t("u2", "u3", u), t("u3", "u1", u), t("c", "t", h), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), i.addAttribute("position", new Me(o, 3)), i.addAttribute("color", new Me(a, 3)), jt.call(this, i, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
			}

			function oo(e, t) {
				this.object = e, void 0 === t && (t = 16776960);
				var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
					i = new Float32Array(24),
					r = new Te;
				r.setIndex(new ve(n, 1)), r.addAttribute("position", new ve(i, 3)), jt.call(this, r, new Rt({
					color: t
				})), this.matrixAutoUpdate = !1, this.update()
			}

			function ao(e, t) {
				this.type = "Box3Helper", this.box = e;
				var n = void 0 !== t ? t : 16776960,
					i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
					r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
					o = new Te;
				o.setIndex(new ve(i, 1)), o.addAttribute("position", new Me(r, 3)), jt.call(this, o, new Rt({
					color: n
				})), this.geometry.computeBoundingSphere()
			}

			function so(e, t, n) {
				this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
				var i = void 0 !== n ? n : 16776960,
					r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
					o = new Te;
				o.addAttribute("position", new Me(r, 3)), o.computeBoundingSphere(), It.call(this, o, new Rt({
					color: i
				}));
				var a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
					s = new Te;
				s.addAttribute("position", new Me(a, 3)), s.computeBoundingSphere(), this.add(new De(s, new ze({
					color: i,
					opacity: .2,
					transparent: !0,
					depthWrite: !1
				})))
			}

			function co(e, t, n, i, r, o) {
				le.call(this), void 0 === i && (i = 16776960), void 0 === n && (n = 1), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === nc && ((nc = new Te).addAttribute("position", new Me([0, 0, 0, 0, 1, 0], 3)), (ic = new Jn(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new It(nc, new Rt({
					color: i
				})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new De(ic, new ze({
					color: i
				})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o)
			}

			function lo(e) {
				var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
					n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
					i = new Te;
				i.addAttribute("position", new Me(t, 3)), i.addAttribute("color", new Me(n, 3));
				var r = new Rt({
					vertexColors: Po
				});
				jt.call(this, i, r)
			}

			function uo(e) {
				console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Mi.call(this, e), this.type = "catmullrom", this.closed = !0
			}

			function ho(e) {
				console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Mi.call(this, e), this.type = "catmullrom"
			}

			function fo(e) {
				console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Mi.call(this, e), this.type = "catmullrom"
			}
			void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
				return "number" == typeof e && isFinite(e) && Math.floor(e) === e
			}), void 0 === Math.sign && (Math.sign = function(e) {
				return e < 0 ? -1 : e > 0 ? 1 : +e
			}), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
				get: function() {
					return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
				}
			}), void 0 === Object.assign && (Object.assign = function(e) {
				if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");
				for (var t = Object(e), n = 1; n < arguments.length; n++) {
					var i = arguments[n];
					if (void 0 !== i && null !== i)
						for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
				}
				return t
			}), Object.assign(t.prototype, {
				addEventListener: function(e, t) {
					void 0 === this._listeners && (this._listeners = {});
					var n = this._listeners;
					void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
				},
				hasEventListener: function(e, t) {
					if (void 0 === this._listeners) return !1;
					var n = this._listeners;
					return void 0 !== n[e] && -1 !== n[e].indexOf(t)
				},
				removeEventListener: function(e, t) {
					if (void 0 !== this._listeners) {
						var n = this._listeners[e];
						if (void 0 !== n) {
							var i = n.indexOf(t); - 1 !== i && n.splice(i, 1)
						}
					}
				},
				dispatchEvent: function(e) {
					if (void 0 !== this._listeners) {
						var t = this._listeners[e.type];
						if (void 0 !== t) {
							e.target = this;
							for (var n = t.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, e)
						}
					}
				}
			});
			var vo = "89",
				po = {
					LEFT: 0,
					MIDDLE: 1,
					RIGHT: 2
				},
				mo = 0,
				go = 1,
				yo = 2,
				xo = 0,
				bo = 1,
				wo = 2,
				Mo = 0,
				_o = 1,
				So = 2,
				Eo = 0,
				To = 1,
				Po = 2,
				Ao = 0,
				Lo = 1,
				Co = 2,
				zo = 3,
				Ro = 4,
				Io = 5,
				jo = 100,
				Oo = 101,
				Do = 102,
				Fo = 103,
				Uo = 104,
				ko = 200,
				No = 201,
				Bo = 202,
				Go = 203,
				Ho = 204,
				Vo = 205,
				Wo = 206,
				Yo = 207,
				Xo = 208,
				qo = 209,
				Zo = 210,
				Ko = 0,
				Jo = 1,
				Qo = 2,
				$o = 3,
				ea = 4,
				ta = 5,
				na = 6,
				ia = 7,
				ra = 0,
				oa = 1,
				aa = 2,
				sa = 0,
				ca = 1,
				la = 2,
				ua = 3,
				ha = 4,
				da = 301,
				fa = 302,
				va = 303,
				pa = 304,
				ma = 305,
				ga = 306,
				ya = 307,
				xa = 1e3,
				ba = 1001,
				wa = 1002,
				Ma = 1003,
				_a = 1004,
				Sa = 1005,
				Ea = 1006,
				Ta = 1007,
				Pa = 1008,
				Aa = 1009,
				La = 1010,
				Ca = 1011,
				za = 1012,
				Ra = 1013,
				Ia = 1014,
				ja = 1015,
				Oa = 1016,
				Da = 1017,
				Fa = 1018,
				Ua = 1019,
				ka = 1020,
				Na = 1021,
				Ba = 1022,
				Ga = 1023,
				Ha = 1024,
				Va = 1025,
				Wa = Ga,
				Ya = 1026,
				Xa = 1027,
				qa = 2001,
				Za = 2002,
				Ka = 2003,
				Ja = 2004,
				Qa = 2100,
				$a = 2101,
				es = 2102,
				ts = 2103,
				ns = 2151,
				is = 2201,
				rs = 2400,
				os = 0,
				as = 1,
				ss = 2,
				cs = 3e3,
				ls = 3001,
				us = 3007,
				hs = 3002,
				ds = 3004,
				fs = 3005,
				vs = 3006,
				ps = 3200,
				ms = 3201,
				gs = {
					DEG2RAD: Math.PI / 180,
					RAD2DEG: 180 / Math.PI,
					generateUUID: function() {
						for (var e = [], t = 0; t < 256; t++) e[t] = (t < 16 ? "0" : "") + t.toString(16).toUpperCase();
						return function() {
							var t = 4294967295 * Math.random() | 0,
								n = 4294967295 * Math.random() | 0,
								i = 4294967295 * Math.random() | 0,
								r = 4294967295 * Math.random() | 0;
							return e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & n] + e[n >> 8 & 255] + "-" + e[n >> 16 & 15 | 64] + e[n >> 24 & 255] + "-" + e[63 & i | 128] + e[i >> 8 & 255] + "-" + e[i >> 16 & 255] + e[i >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]
						}
					}(),
					clamp: function(e, t, n) {
						return Math.max(t, Math.min(n, e))
					},
					euclideanModulo: function(e, t) {
						return (e % t + t) % t
					},
					mapLinear: function(e, t, n, i, r) {
						return i + (e - t) * (r - i) / (n - t)
					},
					lerp: function(e, t, n) {
						return (1 - n) * e + n * t
					},
					smoothstep: function(e, t, n) {
						return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
					},
					smootherstep: function(e, t, n) {
						return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
					},
					randInt: function(e, t) {
						return e + Math.floor(Math.random() * (t - e + 1))
					},
					randFloat: function(e, t) {
						return e + Math.random() * (t - e)
					},
					randFloatSpread: function(e) {
						return e * (.5 - Math.random())
					},
					degToRad: function(e) {
						return e * gs.DEG2RAD
					},
					radToDeg: function(e) {
						return e * gs.RAD2DEG
					},
					isPowerOfTwo: function(e) {
						return 0 == (e & e - 1) && 0 !== e
					},
					ceilPowerOfTwo: function(e) {
						return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
					},
					floorPowerOfTwo: function(e) {
						return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
					}
				};
			Object.defineProperties(n.prototype, {
				width: {
					get: function() {
						return this.x
					},
					set: function(e) {
						this.x = e
					}
				},
				height: {
					get: function() {
						return this.y
					},
					set: function(e) {
						this.y = e
					}
				}
			}), Object.assign(n.prototype, {
				isVector2: !0,
				set: function(e, t) {
					return this.x = e, this.y = t, this
				},
				setScalar: function(e) {
					return this.x = e, this.y = e, this
				},
				setX: function(e) {
					return this.x = e, this
				},
				setY: function(e) {
					return this.y = e, this
				},
				setComponent: function(e, t) {
					switch (e) {
						case 0:
							this.x = t;
							break;
						case 1:
							this.y = t;
							break;
						default:
							throw new Error("index is out of range: " + e)
					}
					return this
				},
				getComponent: function(e) {
					switch (e) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						default:
							throw new Error("index is out of range: " + e)
					}
				},
				clone: function() {
					return new this.constructor(this.x, this.y)
				},
				copy: function(e) {
					return this.x = e.x, this.y = e.y, this
				},
				add: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
				},
				addScalar: function(e) {
					return this.x += e, this.y += e, this
				},
				addVectors: function(e, t) {
					return this.x = e.x + t.x, this.y = e.y + t.y, this
				},
				addScaledVector: function(e, t) {
					return this.x += e.x * t, this.y += e.y * t, this
				},
				sub: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
				},
				subScalar: function(e) {
					return this.x -= e, this.y -= e, this
				},
				subVectors: function(e, t) {
					return this.x = e.x - t.x, this.y = e.y - t.y, this
				},
				multiply: function(e) {
					return this.x *= e.x, this.y *= e.y, this
				},
				multiplyScalar: function(e) {
					return this.x *= e, this.y *= e, this
				},
				divide: function(e) {
					return this.x /= e.x, this.y /= e.y, this
				},
				divideScalar: function(e) {
					return this.multiplyScalar(1 / e)
				},
				applyMatrix3: function(e) {
					var t = this.x,
						n = this.y,
						i = e.elements;
					return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
				},
				min: function(e) {
					return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
				},
				max: function(e) {
					return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
				},
				clamp: function(e, t) {
					return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
				},
				clampScalar: function() {
					var e = new n,
						t = new n;
					return function(n, i) {
						return e.set(n, n), t.set(i, i), this.clamp(e, t)
					}
				}(),
				clampLength: function(e, t) {
					var n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
				},
				floor: function() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
				},
				ceil: function() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
				},
				round: function() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this
				},
				roundToZero: function() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
				},
				negate: function() {
					return this.x = -this.x, this.y = -this.y, this
				},
				dot: function(e) {
					return this.x * e.x + this.y * e.y
				},
				lengthSq: function() {
					return this.x * this.x + this.y * this.y
				},
				length: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y)
				},
				manhattanLength: function() {
					return Math.abs(this.x) + Math.abs(this.y)
				},
				normalize: function() {
					return this.divideScalar(this.length() || 1)
				},
				angle: function() {
					var e = Math.atan2(this.y, this.x);
					return e < 0 && (e += 2 * Math.PI), e
				},
				distanceTo: function(e) {
					return Math.sqrt(this.distanceToSquared(e))
				},
				distanceToSquared: function(e) {
					var t = this.x - e.x,
						n = this.y - e.y;
					return t * t + n * n
				},
				manhattanDistanceTo: function(e) {
					return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
				},
				setLength: function(e) {
					return this.normalize().multiplyScalar(e)
				},
				lerp: function(e, t) {
					return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
				},
				lerpVectors: function(e, t, n) {
					return this.subVectors(t, e).multiplyScalar(n).add(e)
				},
				equals: function(e) {
					return e.x === this.x && e.y === this.y
				},
				fromArray: function(e, t) {
					return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
				},
				toArray: function(e, t) {
					return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
				},
				fromBufferAttribute: function(e, t, n) {
					return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
				},
				rotateAround: function(e, t) {
					var n = Math.cos(t),
						i = Math.sin(t),
						r = this.x - e.x,
						o = this.y - e.y;
					return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this
				}
			}), Object.assign(i.prototype, {
				isMatrix4: !0,
				set: function(e, t, n, i, r, o, a, s, c, l, u, h, d, f, v, p) {
					var m = this.elements;
					return m[0] = e, m[4] = t, m[8] = n, m[12] = i, m[1] = r, m[5] = o, m[9] = a, m[13] = s, m[2] = c, m[6] = l, m[10] = u, m[14] = h, m[3] = d, m[7] = f, m[11] = v, m[15] = p, this
				},
				identity: function() {
					return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				},
				clone: function() {
					return (new i).fromArray(this.elements)
				},
				copy: function(e) {
					var t = this.elements,
						n = e.elements;
					return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
				},
				copyPosition: function(e) {
					var t = this.elements,
						n = e.elements;
					return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
				},
				extractBasis: function(e, t, n) {
					return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
				},
				makeBasis: function(e, t, n) {
					return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
				},
				extractRotation: function() {
					var e = new o;
					return function(t) {
						var n = this.elements,
							i = t.elements,
							r = 1 / e.setFromMatrixColumn(t, 0).length(),
							o = 1 / e.setFromMatrixColumn(t, 1).length(),
							a = 1 / e.setFromMatrixColumn(t, 2).length();
						return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, this
					}
				}(),
				makeRotationFromEuler: function(e) {
					e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
					var t = this.elements,
						n = e.x,
						i = e.y,
						r = e.z,
						o = Math.cos(n),
						a = Math.sin(n),
						s = Math.cos(i),
						c = Math.sin(i),
						l = Math.cos(r),
						u = Math.sin(r);
					if ("XYZ" === e.order) {
						var h = o * l,
							d = o * u,
							f = a * l,
							v = a * u;
						t[0] = s * l, t[4] = -s * u, t[8] = c, t[1] = d + f * c, t[5] = h - v * c, t[9] = -a * s, t[2] = v - h * c, t[6] = f + d * c, t[10] = o * s
					} else if ("YXZ" === e.order) {
						var p = s * l,
							m = s * u,
							g = c * l,
							y = c * u;
						t[0] = p + y * a, t[4] = g * a - m, t[8] = o * c, t[1] = o * u, t[5] = o * l, t[9] = -a, t[2] = m * a - g, t[6] = y + p * a, t[10] = o * s
					} else if ("ZXY" === e.order) {
						var p = s * l,
							m = s * u,
							g = c * l,
							y = c * u;
						t[0] = p - y * a, t[4] = -o * u, t[8] = g + m * a, t[1] = m + g * a, t[5] = o * l, t[9] = y - p * a, t[2] = -o * c, t[6] = a, t[10] = o * s
					} else if ("ZYX" === e.order) {
						var h = o * l,
							d = o * u,
							f = a * l,
							v = a * u;
						t[0] = s * l, t[4] = f * c - d, t[8] = h * c + v, t[1] = s * u, t[5] = v * c + h, t[9] = d * c - f, t[2] = -c, t[6] = a * s, t[10] = o * s
					} else if ("YZX" === e.order) {
						var x = o * s,
							b = o * c,
							w = a * s,
							M = a * c;
						t[0] = s * l, t[4] = M - x * u, t[8] = w * u + b, t[1] = u, t[5] = o * l, t[9] = -a * l, t[2] = -c * l, t[6] = b * u + w, t[10] = x - M * u
					} else if ("XZY" === e.order) {
						var x = o * s,
							b = o * c,
							w = a * s,
							M = a * c;
						t[0] = s * l, t[4] = -u, t[8] = c * l, t[1] = x * u + M, t[5] = o * l, t[9] = b * u - w, t[2] = w * u - b, t[6] = a * l, t[10] = M * u + x
					}
					return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
				},
				makeRotationFromQuaternion: function(e) {
					var t = this.elements,
						n = e._x,
						i = e._y,
						r = e._z,
						o = e._w,
						a = n + n,
						s = i + i,
						c = r + r,
						l = n * a,
						u = n * s,
						h = n * c,
						d = i * s,
						f = i * c,
						v = r * c,
						p = o * a,
						m = o * s,
						g = o * c;
					return t[0] = 1 - (d + v), t[4] = u - g, t[8] = h + m, t[1] = u + g, t[5] = 1 - (l + v), t[9] = f - p, t[2] = h - m, t[6] = f + p, t[10] = 1 - (l + d), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
				},
				lookAt: function() {
					var e = new o,
						t = new o,
						n = new o;
					return function(i, r, o) {
						var a = this.elements;
						return n.subVectors(i, r), 0 === n.lengthSq() && (n.z = 1), n.normalize(), e.crossVectors(o, n), 0 === e.lengthSq() && (1 === Math.abs(o.z) ? n.x += 1e-4 : n.z += 1e-4, n.normalize(), e.crossVectors(o, n)), e.normalize(), t.crossVectors(n, e), a[0] = e.x, a[4] = t.x, a[8] = n.x, a[1] = e.y, a[5] = t.y, a[9] = n.y, a[2] = e.z, a[6] = t.z, a[10] = n.z, this
					}
				}(),
				multiply: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
				},
				premultiply: function(e) {
					return this.multiplyMatrices(e, this)
				},
				multiplyMatrices: function(e, t) {
					var n = e.elements,
						i = t.elements,
						r = this.elements,
						o = n[0],
						a = n[4],
						s = n[8],
						c = n[12],
						l = n[1],
						u = n[5],
						h = n[9],
						d = n[13],
						f = n[2],
						v = n[6],
						p = n[10],
						m = n[14],
						g = n[3],
						y = n[7],
						x = n[11],
						b = n[15],
						w = i[0],
						M = i[4],
						_ = i[8],
						S = i[12],
						E = i[1],
						T = i[5],
						P = i[9],
						A = i[13],
						L = i[2],
						C = i[6],
						z = i[10],
						R = i[14],
						I = i[3],
						j = i[7],
						O = i[11],
						D = i[15];
					return r[0] = o * w + a * E + s * L + c * I, r[4] = o * M + a * T + s * C + c * j, r[8] = o * _ + a * P + s * z + c * O, r[12] = o * S + a * A + s * R + c * D, r[1] = l * w + u * E + h * L + d * I, r[5] = l * M + u * T + h * C + d * j, r[9] = l * _ + u * P + h * z + d * O, r[13] = l * S + u * A + h * R + d * D, r[2] = f * w + v * E + p * L + m * I, r[6] = f * M + v * T + p * C + m * j, r[10] = f * _ + v * P + p * z + m * O, r[14] = f * S + v * A + p * R + m * D, r[3] = g * w + y * E + x * L + b * I, r[7] = g * M + y * T + x * C + b * j, r[11] = g * _ + y * P + x * z + b * O, r[15] = g * S + y * A + x * R + b * D, this
				},
				multiplyScalar: function(e) {
					var t = this.elements;
					return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
				},
				applyToBufferAttribute: function() {
					var e = new o;
					return function(t) {
						for (var n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix4(this), t.setXYZ(n, e.x, e.y, e.z);
						return t
					}
				}(),
				determinant: function() {
					var e = this.elements,
						t = e[0],
						n = e[4],
						i = e[8],
						r = e[12],
						o = e[1],
						a = e[5],
						s = e[9],
						c = e[13],
						l = e[2],
						u = e[6],
						h = e[10],
						d = e[14];
					return e[3] * (+r * s * u - i * c * u - r * a * h + n * c * h + i * a * d - n * s * d) + e[7] * (+t * s * d - t * c * h + r * o * h - i * o * d + i * c * l - r * s * l) + e[11] * (+t * c * u - t * a * d - r * o * u + n * o * d + r * a * l - n * c * l) + e[15] * (-i * a * l - t * s * u + t * a * h + i * o * u - n * o * h + n * s * l)
				},
				transpose: function() {
					var e, t = this.elements;
					return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
				},
				setPosition: function(e) {
					var t = this.elements;
					return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
				},
				getInverse: function(e, t) {
					var n = this.elements,
						i = e.elements,
						r = i[0],
						o = i[1],
						a = i[2],
						s = i[3],
						c = i[4],
						l = i[5],
						u = i[6],
						h = i[7],
						d = i[8],
						f = i[9],
						v = i[10],
						p = i[11],
						m = i[12],
						g = i[13],
						y = i[14],
						x = i[15],
						b = f * y * h - g * v * h + g * u * p - l * y * p - f * u * x + l * v * x,
						w = m * v * h - d * y * h - m * u * p + c * y * p + d * u * x - c * v * x,
						M = d * g * h - m * f * h + m * l * p - c * g * p - d * l * x + c * f * x,
						_ = m * f * u - d * g * u - m * l * v + c * g * v + d * l * y - c * f * y,
						S = r * b + o * w + a * M + s * _;
					if (0 === S) {
						var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
						if (!0 === t) throw new Error(E);
						return console.warn(E), this.identity()
					}
					var T = 1 / S;
					return n[0] = b * T, n[1] = (g * v * s - f * y * s - g * a * p + o * y * p + f * a * x - o * v * x) * T, n[2] = (l * y * s - g * u * s + g * a * h - o * y * h - l * a * x + o * u * x) * T, n[3] = (f * u * s - l * v * s - f * a * h + o * v * h + l * a * p - o * u * p) * T, n[4] = w * T, n[5] = (d * y * s - m * v * s + m * a * p - r * y * p - d * a * x + r * v * x) * T, n[6] = (m * u * s - c * y * s - m * a * h + r * y * h + c * a * x - r * u * x) * T, n[7] = (c * v * s - d * u * s + d * a * h - r * v * h - c * a * p + r * u * p) * T, n[8] = M * T, n[9] = (m * f * s - d * g * s - m * o * p + r * g * p + d * o * x - r * f * x) * T, n[10] = (c * g * s - m * l * s + m * o * h - r * g * h - c * o * x + r * l * x) * T, n[11] = (d * l * s - c * f * s - d * o * h + r * f * h + c * o * p - r * l * p) * T, n[12] = _ * T, n[13] = (d * g * a - m * f * a + m * o * v - r * g * v - d * o * y + r * f * y) * T, n[14] = (m * l * a - c * g * a - m * o * u + r * g * u + c * o * y - r * l * y) * T, n[15] = (c * f * a - d * l * a + d * o * u - r * f * u - c * o * v + r * l * v) * T, this
				},
				scale: function(e) {
					var t = this.elements,
						n = e.x,
						i = e.y,
						r = e.z;
					return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
				},
				getMaxScaleOnAxis: function() {
					var e = this.elements,
						t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
						n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
						i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
					return Math.sqrt(Math.max(t, n, i))
				},
				makeTranslation: function(e, t, n) {
					return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
				},
				makeRotationX: function(e) {
					var t = Math.cos(e),
						n = Math.sin(e);
					return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
				},
				makeRotationY: function(e) {
					var t = Math.cos(e),
						n = Math.sin(e);
					return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
				},
				makeRotationZ: function(e) {
					var t = Math.cos(e),
						n = Math.sin(e);
					return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				},
				makeRotationAxis: function(e, t) {
					var n = Math.cos(t),
						i = Math.sin(t),
						r = 1 - n,
						o = e.x,
						a = e.y,
						s = e.z,
						c = r * o,
						l = r * a;
					return this.set(c * o + n, c * a - i * s, c * s + i * a, 0, c * a + i * s, l * a + n, l * s - i * o, 0, c * s - i * a, l * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this
				},
				makeScale: function(e, t, n) {
					return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
				},
				makeShear: function(e, t, n) {
					return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
				},
				compose: function(e, t, n) {
					return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
				},
				decompose: function() {
					var e = new o,
						t = new i;
					return function(n, i, r) {
						var o = this.elements,
							a = e.set(o[0], o[1], o[2]).length(),
							s = e.set(o[4], o[5], o[6]).length(),
							c = e.set(o[8], o[9], o[10]).length();
						this.determinant() < 0 && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], t.copy(this);
						var l = 1 / a,
							u = 1 / s,
							h = 1 / c;
						return t.elements[0] *= l, t.elements[1] *= l, t.elements[2] *= l, t.elements[4] *= u, t.elements[5] *= u, t.elements[6] *= u, t.elements[8] *= h, t.elements[9] *= h, t.elements[10] *= h, i.setFromRotationMatrix(t), r.x = a, r.y = s, r.z = c, this
					}
				}(),
				makePerspective: function(e, t, n, i, r, o) {
					void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
					var a = this.elements,
						s = 2 * r / (t - e),
						c = 2 * r / (n - i),
						l = (t + e) / (t - e),
						u = (n + i) / (n - i),
						h = -(o + r) / (o - r),
						d = -2 * o * r / (o - r);
					return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
				},
				makeOrthographic: function(e, t, n, i, r, o) {
					var a = this.elements,
						s = 1 / (t - e),
						c = 1 / (n - i),
						l = 1 / (o - r),
						u = (t + e) * s,
						h = (n + i) * c,
						d = (o + r) * l;
					return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
				},
				equals: function(e) {
					for (var t = this.elements, n = e.elements, i = 0; i < 16; i++)
						if (t[i] !== n[i]) return !1;
					return !0
				},
				fromArray: function(e, t) {
					void 0 === t && (t = 0);
					for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
					return this
				},
				toArray: function(e, t) {
					void 0 === e && (e = []), void 0 === t && (t = 0);
					var n = this.elements;
					return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
				}
			}), Object.assign(r, {
				slerp: function(e, t, n, i) {
					return n.copy(e).slerp(t, i)
				},
				slerpFlat: function(e, t, n, i, r, o, a) {
					var s = n[i + 0],
						c = n[i + 1],
						l = n[i + 2],
						u = n[i + 3],
						h = r[o + 0],
						d = r[o + 1],
						f = r[o + 2],
						v = r[o + 3];
					if (u !== v || s !== h || c !== d || l !== f) {
						var p = 1 - a,
							m = s * h + c * d + l * f + u * v,
							g = m >= 0 ? 1 : -1,
							y = 1 - m * m;
						if (y > Number.EPSILON) {
							var x = Math.sqrt(y),
								b = Math.atan2(x, m * g);
							p = Math.sin(p * b) / x, a = Math.sin(a * b) / x
						}
						var w = a * g;
						if (s = s * p + h * w, c = c * p + d * w, l = l * p + f * w, u = u * p + v * w, p === 1 - a) {
							var M = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
							s *= M, c *= M, l *= M, u *= M
						}
					}
					e[t] = s, e[t + 1] = c, e[t + 2] = l, e[t + 3] = u
				}
			}), Object.defineProperties(r.prototype, {
				x: {
					get: function() {
						return this._x
					},
					set: function(e) {
						this._x = e, this.onChangeCallback()
					}
				},
				y: {
					get: function() {
						return this._y
					},
					set: function(e) {
						this._y = e, this.onChangeCallback()
					}
				},
				z: {
					get: function() {
						return this._z
					},
					set: function(e) {
						this._z = e, this.onChangeCallback()
					}
				},
				w: {
					get: function() {
						return this._w
					},
					set: function(e) {
						this._w = e, this.onChangeCallback()
					}
				}
			}), Object.assign(r.prototype, {
				set: function(e, t, n, i) {
					return this._x = e, this._y = t, this._z = n, this._w = i, this.onChangeCallback(), this
				},
				clone: function() {
					return new this.constructor(this._x, this._y, this._z, this._w)
				},
				copy: function(e) {
					return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
				},
				setFromEuler: function(e, t) {
					if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
					var n = e._x,
						i = e._y,
						r = e._z,
						o = e.order,
						a = Math.cos,
						s = Math.sin,
						c = a(n / 2),
						l = a(i / 2),
						u = a(r / 2),
						h = s(n / 2),
						d = s(i / 2),
						f = s(r / 2);
					return "XYZ" === o ? (this._x = h * l * u + c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u - h * d * f) : "YXZ" === o ? (this._x = h * l * u + c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u + h * d * f) : "ZXY" === o ? (this._x = h * l * u - c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u - h * d * f) : "ZYX" === o ? (this._x = h * l * u - c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u + h * d * f) : "YZX" === o ? (this._x = h * l * u + c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u - h * d * f) : "XZY" === o && (this._x = h * l * u - c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u + h * d * f), !1 !== t && this.onChangeCallback(), this
				},
				setFromAxisAngle: function(e, t) {
					var n = t / 2,
						i = Math.sin(n);
					return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
				},
				setFromRotationMatrix: function(e) {
					var t, n = e.elements,
						i = n[0],
						r = n[4],
						o = n[8],
						a = n[1],
						s = n[5],
						c = n[9],
						l = n[2],
						u = n[6],
						h = n[10],
						d = i + s + h;
					return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (u - c) * t, this._y = (o - l) * t, this._z = (a - r) * t) : i > s && i > h ? (t = 2 * Math.sqrt(1 + i - s - h), this._w = (u - c) / t, this._x = .25 * t, this._y = (r + a) / t, this._z = (o + l) / t) : s > h ? (t = 2 * Math.sqrt(1 + s - i - h), this._w = (o - l) / t, this._x = (r + a) / t, this._y = .25 * t, this._z = (c + u) / t) : (t = 2 * Math.sqrt(1 + h - i - s), this._w = (a - r) / t, this._x = (o + l) / t, this._y = (c + u) / t, this._z = .25 * t), this.onChangeCallback(), this
				},
				setFromUnitVectors: function() {
					var e, t = new o;
					return function(n, i) {
						return void 0 === t && (t = new o), (e = n.dot(i) + 1) < 1e-6 ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, i), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
					}
				}(),
				inverse: function() {
					return this.conjugate().normalize()
				},
				conjugate: function() {
					return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
				},
				dot: function(e) {
					return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
				},
				lengthSq: function() {
					return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
				},
				length: function() {
					return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
				},
				normalize: function() {
					var e = this.length();
					return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
				},
				multiply: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
				},
				premultiply: function(e) {
					return this.multiplyQuaternions(e, this)
				},
				multiplyQuaternions: function(e, t) {
					var n = e._x,
						i = e._y,
						r = e._z,
						o = e._w,
						a = t._x,
						s = t._y,
						c = t._z,
						l = t._w;
					return this._x = n * l + o * a + i * c - r * s, this._y = i * l + o * s + r * a - n * c, this._z = r * l + o * c + n * s - i * a, this._w = o * l - n * a - i * s - r * c, this.onChangeCallback(), this
				},
				slerp: function(e, t) {
					if (0 === t) return this;
					if (1 === t) return this.copy(e);
					var n = this._x,
						i = this._y,
						r = this._z,
						o = this._w,
						a = o * e._w + n * e._x + i * e._y + r * e._z;
					if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
					var s = Math.sqrt(1 - a * a);
					if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (n + this._x), this._y = .5 * (i + this._y), this._z = .5 * (r + this._z), this;
					var c = Math.atan2(s, a),
						l = Math.sin((1 - t) * c) / s,
						u = Math.sin(t * c) / s;
					return this._w = o * l + this._w * u, this._x = n * l + this._x * u, this._y = i * l + this._y * u, this._z = r * l + this._z * u, this.onChangeCallback(), this
				},
				equals: function(e) {
					return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
				},
				fromArray: function(e, t) {
					return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
				},
				toArray: function(e, t) {
					return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
				},
				onChange: function(e) {
					return this.onChangeCallback = e, this
				},
				onChangeCallback: function() {}
			}), Object.assign(o.prototype, {
				isVector3: !0,
				set: function(e, t, n) {
					return this.x = e, this.y = t, this.z = n, this
				},
				setScalar: function(e) {
					return this.x = e, this.y = e, this.z = e, this
				},
				setX: function(e) {
					return this.x = e, this
				},
				setY: function(e) {
					return this.y = e, this
				},
				setZ: function(e) {
					return this.z = e, this
				},
				setComponent: function(e, t) {
					switch (e) {
						case 0:
							this.x = t;
							break;
						case 1:
							this.y = t;
							break;
						case 2:
							this.z = t;
							break;
						default:
							throw new Error("index is out of range: " + e)
					}
					return this
				},
				getComponent: function(e) {
					switch (e) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						default:
							throw new Error("index is out of range: " + e)
					}
				},
				clone: function() {
					return new this.constructor(this.x, this.y, this.z)
				},
				copy: function(e) {
					return this.x = e.x, this.y = e.y, this.z = e.z, this
				},
				add: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
				},
				addScalar: function(e) {
					return this.x += e, this.y += e, this.z += e, this
				},
				addVectors: function(e, t) {
					return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
				},
				addScaledVector: function(e, t) {
					return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
				},
				sub: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
				},
				subScalar: function(e) {
					return this.x -= e, this.y -= e, this.z -= e, this
				},
				subVectors: function(e, t) {
					return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
				},
				multiply: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
				},
				multiplyScalar: function(e) {
					return this.x *= e, this.y *= e, this.z *= e, this
				},
				multiplyVectors: function(e, t) {
					return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
				},
				applyEuler: function() {
					var e = new r;
					return function(t) {
						return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(t))
					}
				}(),
				applyAxisAngle: function() {
					var e = new r;
					return function(t, n) {
						return this.applyQuaternion(e.setFromAxisAngle(t, n))
					}
				}(),
				applyMatrix3: function(e) {
					var t = this.x,
						n = this.y,
						i = this.z,
						r = e.elements;
					return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
				},
				applyMatrix4: function(e) {
					var t = this.x,
						n = this.y,
						i = this.z,
						r = e.elements,
						o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
					return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this
				},
				applyQuaternion: function(e) {
					var t = this.x,
						n = this.y,
						i = this.z,
						r = e.x,
						o = e.y,
						a = e.z,
						s = e.w,
						c = s * t + o * i - a * n,
						l = s * n + a * t - r * i,
						u = s * i + r * n - o * t,
						h = -r * t - o * n - a * i;
					return this.x = c * s + h * -r + l * -a - u * -o, this.y = l * s + h * -o + u * -r - c * -a, this.z = u * s + h * -a + c * -o - l * -r, this
				},
				project: function() {
					var e = new i;
					return function(t) {
						return e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)), this.applyMatrix4(e)
					}
				}(),
				unproject: function() {
					var e = new i;
					return function(t) {
						return e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)), this.applyMatrix4(e)
					}
				}(),
				transformDirection: function(e) {
					var t = this.x,
						n = this.y,
						i = this.z,
						r = e.elements;
					return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
				},
				divide: function(e) {
					return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
				},
				divideScalar: function(e) {
					return this.multiplyScalar(1 / e)
				},
				min: function(e) {
					return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
				},
				max: function(e) {
					return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
				},
				clamp: function(e, t) {
					return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
				},
				clampScalar: function() {
					var e = new o,
						t = new o;
					return function(n, i) {
						return e.set(n, n, n), t.set(i, i, i), this.clamp(e, t)
					}
				}(),
				clampLength: function(e, t) {
					var n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
				},
				floor: function() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
				},
				ceil: function() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
				},
				round: function() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
				},
				roundToZero: function() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
				},
				negate: function() {
					return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
				},
				dot: function(e) {
					return this.x * e.x + this.y * e.y + this.z * e.z
				},
				lengthSq: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z
				},
				length: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
				},
				manhattanLength: function() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
				},
				normalize: function() {
					return this.divideScalar(this.length() || 1)
				},
				setLength: function(e) {
					return this.normalize().multiplyScalar(e)
				},
				lerp: function(e, t) {
					return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
				},
				lerpVectors: function(e, t, n) {
					return this.subVectors(t, e).multiplyScalar(n).add(e)
				},
				cross: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
				},
				crossVectors: function(e, t) {
					var n = e.x,
						i = e.y,
						r = e.z,
						o = t.x,
						a = t.y,
						s = t.z;
					return this.x = i * s - r * a, this.y = r * o - n * s, this.z = n * a - i * o, this
				},
				projectOnVector: function(e) {
					var t = e.dot(this) / e.lengthSq();
					return this.copy(e).multiplyScalar(t)
				},
				projectOnPlane: function() {
					var e = new o;
					return function(t) {
						return e.copy(this).projectOnVector(t), this.sub(e)
					}
				}(),
				reflect: function() {
					var e = new o;
					return function(t) {
						return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
					}
				}(),
				angleTo: function(e) {
					var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
					return Math.acos(gs.clamp(t, -1, 1))
				},
				distanceTo: function(e) {
					return Math.sqrt(this.distanceToSquared(e))
				},
				distanceToSquared: function(e) {
					var t = this.x - e.x,
						n = this.y - e.y,
						i = this.z - e.z;
					return t * t + n * n + i * i
				},
				manhattanDistanceTo: function(e) {
					return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
				},
				setFromSpherical: function(e) {
					var t = Math.sin(e.phi) * e.radius;
					return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this
				},
				setFromCylindrical: function(e) {
					return this.x = e.radius * Math.sin(e.theta), this.y = e.y, this.z = e.radius * Math.cos(e.theta), this
				},
				setFromMatrixPosition: function(e) {
					var t = e.elements;
					return this.x = t[12], this.y = t[13], this.z = t[14], this
				},
				setFromMatrixScale: function(e) {
					var t = this.setFromMatrixColumn(e, 0).length(),
						n = this.setFromMatrixColumn(e, 1).length(),
						i = this.setFromMatrixColumn(e, 2).length();
					return this.x = t, this.y = n, this.z = i, this
				},
				setFromMatrixColumn: function(e, t) {
					return this.fromArray(e.elements, 4 * t)
				},
				equals: function(e) {
					return e.x === this.x && e.y === this.y && e.z === this.z
				},
				fromArray: function(e, t) {
					return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
				},
				toArray: function(e, t) {
					return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
				},
				fromBufferAttribute: function(e, t, n) {
					return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
				}
			}), Object.assign(a.prototype, {
				isMatrix3: !0,
				set: function(e, t, n, i, r, o, a, s, c) {
					var l = this.elements;
					return l[0] = e, l[1] = i, l[2] = a, l[3] = t, l[4] = r, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this
				},
				identity: function() {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
				},
				clone: function() {
					return (new this.constructor).fromArray(this.elements)
				},
				copy: function(e) {
					var t = this.elements,
						n = e.elements;
					return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
				},
				setFromMatrix4: function(e) {
					var t = e.elements;
					return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
				},
				applyToBufferAttribute: function() {
					var e = new o;
					return function(t) {
						for (var n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix3(this), t.setXYZ(n, e.x, e.y, e.z);
						return t
					}
				}(),
				multiply: function(e) {
					return this.multiplyMatrices(this, e)
				},
				premultiply: function(e) {
					return this.multiplyMatrices(e, this)
				},
				multiplyMatrices: function(e, t) {
					var n = e.elements,
						i = t.elements,
						r = this.elements,
						o = n[0],
						a = n[3],
						s = n[6],
						c = n[1],
						l = n[4],
						u = n[7],
						h = n[2],
						d = n[5],
						f = n[8],
						v = i[0],
						p = i[3],
						m = i[6],
						g = i[1],
						y = i[4],
						x = i[7],
						b = i[2],
						w = i[5],
						M = i[8];
					return r[0] = o * v + a * g + s * b, r[3] = o * p + a * y + s * w, r[6] = o * m + a * x + s * M, r[1] = c * v + l * g + u * b, r[4] = c * p + l * y + u * w, r[7] = c * m + l * x + u * M, r[2] = h * v + d * g + f * b, r[5] = h * p + d * y + f * w, r[8] = h * m + d * x + f * M, this
				},
				multiplyScalar: function(e) {
					var t = this.elements;
					return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
				},
				determinant: function() {
					var e = this.elements,
						t = e[0],
						n = e[1],
						i = e[2],
						r = e[3],
						o = e[4],
						a = e[5],
						s = e[6],
						c = e[7],
						l = e[8];
					return t * o * l - t * a * c - n * r * l + n * a * s + i * r * c - i * o * s
				},
				getInverse: function(e, t) {
					e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
					var n = e.elements,
						i = this.elements,
						r = n[0],
						o = n[1],
						a = n[2],
						s = n[3],
						c = n[4],
						l = n[5],
						u = n[6],
						h = n[7],
						d = n[8],
						f = d * c - l * h,
						v = l * u - d * s,
						p = h * s - c * u,
						m = r * f + o * v + a * p;
					if (0 === m) {
						var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
						if (!0 === t) throw new Error(g);
						return console.warn(g), this.identity()
					}
					var y = 1 / m;
					return i[0] = f * y, i[1] = (a * h - d * o) * y, i[2] = (l * o - a * c) * y, i[3] = v * y, i[4] = (d * r - a * u) * y, i[5] = (a * s - l * r) * y, i[6] = p * y, i[7] = (o * u - h * r) * y, i[8] = (c * r - o * s) * y, this
				},
				transpose: function() {
					var e, t = this.elements;
					return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
				},
				getNormalMatrix: function(e) {
					return this.setFromMatrix4(e).getInverse(this).transpose()
				},
				transposeIntoArray: function(e) {
					var t = this.elements;
					return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
				},
				setUvTransform: function(e, t, n, i, r, o, a) {
					var s = Math.cos(r),
						c = Math.sin(r);
					this.set(n * s, n * c, -n * (s * o + c * a) + o + e, -i * c, i * s, -i * (-c * o + s * a) + a + t, 0, 0, 1)
				},
				scale: function(e, t) {
					var n = this.elements;
					return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
				},
				rotate: function(e) {
					var t = Math.cos(e),
						n = Math.sin(e),
						i = this.elements,
						r = i[0],
						o = i[3],
						a = i[6],
						s = i[1],
						c = i[4],
						l = i[7];
					return i[0] = t * r + n * s, i[3] = t * o + n * c, i[6] = t * a + n * l, i[1] = -n * r + t * s, i[4] = -n * o + t * c, i[7] = -n * a + t * l, this
				},
				translate: function(e, t) {
					var n = this.elements;
					return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
				},
				equals: function(e) {
					for (var t = this.elements, n = e.elements, i = 0; i < 9; i++)
						if (t[i] !== n[i]) return !1;
					return !0
				},
				fromArray: function(e, t) {
					void 0 === t && (t = 0);
					for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
					return this
				},
				toArray: function(e, t) {
					void 0 === e && (e = []), void 0 === t && (t = 0);
					var n = this.elements;
					return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
				}
			});
			var ys = 0;
			s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, s.prototype = Object.assign(Object.create(t.prototype), {
				constructor: s,
				isTexture: !0,
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
				},
				toJSON: function(e) {
					var t = void 0 === e || "string" == typeof e;
					if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
					var n = {
						metadata: {
							version: 4.5,
							type: "Texture",
							generator: "Texture.toJSON"
						},
						uuid: this.uuid,
						name: this.name,
						mapping: this.mapping,
						repeat: [this.repeat.x, this.repeat.y],
						offset: [this.offset.x, this.offset.y],
						center: [this.center.x, this.center.y],
						rotation: this.rotation,
						wrap: [this.wrapS, this.wrapT],
						minFilter: this.minFilter,
						magFilter: this.magFilter,
						anisotropy: this.anisotropy,
						flipY: this.flipY
					};
					if (void 0 !== this.image) {
						var i = this.image;
						void 0 === i.uuid && (i.uuid = gs.generateUUID()), t || void 0 !== e.images[i.uuid] || (e.images[i.uuid] = {
							uuid: i.uuid,
							url: function(e) {
								var t;
								if (e instanceof HTMLCanvasElement) t = e;
								else {
									(t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = e.width, t.height = e.height;
									var n = t.getContext("2d");
									e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height)
								}
								return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
							}(i)
						}), n.image = i.uuid
					}
					return t || (e.textures[this.uuid] = n), n
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				},
				transformUv: function(e) {
					if (300 === this.mapping) {
						if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
							case xa:
								e.x = e.x - Math.floor(e.x);
								break;
							case ba:
								e.x = e.x < 0 ? 0 : 1;
								break;
							case wa:
								1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
						}
						if (e.y < 0 || e.y > 1) switch (this.wrapT) {
							case xa:
								e.y = e.y - Math.floor(e.y);
								break;
							case ba:
								e.y = e.y < 0 ? 0 : 1;
								break;
							case wa:
								1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
						}
						this.flipY && (e.y = 1 - e.y)
					}
				}
			}), Object.defineProperty(s.prototype, "needsUpdate", {
				set: function(e) {
					!0 === e && this.version++
				}
			}), Object.assign(c.prototype, {
				isVector4: !0,
				set: function(e, t, n, i) {
					return this.x = e, this.y = t, this.z = n, this.w = i, this
				},
				setScalar: function(e) {
					return this.x = e, this.y = e, this.z = e, this.w = e, this
				},
				setX: function(e) {
					return this.x = e, this
				},
				setY: function(e) {
					return this.y = e, this
				},
				setZ: function(e) {
					return this.z = e, this
				},
				setW: function(e) {
					return this.w = e, this
				},
				setComponent: function(e, t) {
					switch (e) {
						case 0:
							this.x = t;
							break;
						case 1:
							this.y = t;
							break;
						case 2:
							this.z = t;
							break;
						case 3:
							this.w = t;
							break;
						default:
							throw new Error("index is out of range: " + e)
					}
					return this
				},
				getComponent: function(e) {
					switch (e) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						case 3:
							return this.w;
						default:
							throw new Error("index is out of range: " + e)
					}
				},
				clone: function() {
					return new this.constructor(this.x, this.y, this.z, this.w)
				},
				copy: function(e) {
					return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
				},
				add: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
				},
				addScalar: function(e) {
					return this.x += e, this.y += e, this.z += e, this.w += e, this
				},
				addVectors: function(e, t) {
					return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
				},
				addScaledVector: function(e, t) {
					return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
				},
				sub: function(e, t) {
					return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
				},
				subScalar: function(e) {
					return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
				},
				subVectors: function(e, t) {
					return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
				},
				multiplyScalar: function(e) {
					return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
				},
				applyMatrix4: function(e) {
					var t = this.x,
						n = this.y,
						i = this.z,
						r = this.w,
						o = e.elements;
					return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this
				},
				divideScalar: function(e) {
					return this.multiplyScalar(1 / e)
				},
				setAxisAngleFromQuaternion: function(e) {
					this.w = 2 * Math.acos(e.w);
					var t = Math.sqrt(1 - e.w * e.w);
					return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
				},
				setAxisAngleFromRotationMatrix: function(e) {
					var t, n, i, r, o = e.elements,
						a = o[0],
						s = o[4],
						c = o[8],
						l = o[1],
						u = o[5],
						h = o[9],
						d = o[2],
						f = o[6],
						v = o[10];
					if (Math.abs(s - l) < .01 && Math.abs(c - d) < .01 && Math.abs(h - f) < .01) {
						if (Math.abs(s + l) < .1 && Math.abs(c + d) < .1 && Math.abs(h + f) < .1 && Math.abs(a + u + v - 3) < .1) return this.set(1, 0, 0, 0), this;
						t = Math.PI;
						var p = (a + 1) / 2,
							m = (u + 1) / 2,
							g = (v + 1) / 2,
							y = (s + l) / 4,
							x = (c + d) / 4,
							b = (h + f) / 4;
						return p > m && p > g ? p < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = y / (n = Math.sqrt(p)), r = x / n) : m > g ? m < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = y / (i = Math.sqrt(m)), r = b / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = x / (r = Math.sqrt(g)), i = b / r), this.set(n, i, r, t), this
					}
					var w = Math.sqrt((f - h) * (f - h) + (c - d) * (c - d) + (l - s) * (l - s));
					return Math.abs(w) < .001 && (w = 1), this.x = (f - h) / w, this.y = (c - d) / w, this.z = (l - s) / w, this.w = Math.acos((a + u + v - 1) / 2), this
				},
				min: function(e) {
					return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
				},
				max: function(e) {
					return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
				},
				clamp: function(e, t) {
					return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
				},
				clampScalar: function() {
					var e, t;
					return function(n, i) {
						return void 0 === e && (e = new c, t = new c), e.set(n, n, n, n), t.set(i, i, i, i), this.clamp(e, t)
					}
				}(),
				clampLength: function(e, t) {
					var n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
				},
				floor: function() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
				},
				ceil: function() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
				},
				round: function() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
				},
				roundToZero: function() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
				},
				negate: function() {
					return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
				},
				dot: function(e) {
					return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
				},
				lengthSq: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				},
				length: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
				},
				manhattanLength: function() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
				},
				normalize: function() {
					return this.divideScalar(this.length() || 1)
				},
				setLength: function(e) {
					return this.normalize().multiplyScalar(e)
				},
				lerp: function(e, t) {
					return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
				},
				lerpVectors: function(e, t, n) {
					return this.subVectors(t, e).multiplyScalar(n).add(e)
				},
				equals: function(e) {
					return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
				},
				fromArray: function(e, t) {
					return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
				},
				toArray: function(e, t) {
					return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
				},
				fromBufferAttribute: function(e, t, n) {
					return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
				}
			}), l.prototype = Object.assign(Object.create(t.prototype), {
				constructor: l,
				isWebGLRenderTarget: !0,
				setSize: function(e, t) {
					this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}), u.prototype = Object.create(l.prototype), u.prototype.constructor = u, u.prototype.isWebGLRenderTargetCube = !0, h.prototype = Object.create(s.prototype), h.prototype.constructor = h, h.prototype.isDataTexture = !0, (d.prototype = Object.create(s.prototype)).constructor = d, d.prototype.isCubeTexture = !0, Object.defineProperty(d.prototype, "images", {
				get: function() {
					return this.image
				},
				set: function(e) {
					this.image = e
				}
			});
			var xs = new s,
				bs = new d,
				ws = [],
				Ms = [],
				_s = new Float32Array(16),
				Ss = new Float32Array(9);
			H.prototype.setValue = function(e, t) {
				for (var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
					var o = n[i];
					o.setValue(e, t[o.id])
				}
			};
			var Es = /([\w\d_]+)(\])?(\[|\.)?/g;
			Y.prototype.setValue = function(e, t, n) {
				var i = this.map[t];
				void 0 !== i && i.setValue(e, n, this.renderer)
			}, Y.prototype.setOptional = function(e, t, n) {
				var i = t[n];
				void 0 !== i && this.setValue(e, n, i)
			}, Y.upload = function(e, t, n, i) {
				for (var r = 0, o = t.length; r !== o; ++r) {
					var a = t[r],
						s = n[a.id];
					!1 !== s.needsUpdate && a.setValue(e, s.value, i)
				}
			}, Y.seqWithValue = function(e, t) {
				for (var n = [], i = 0, r = e.length; i !== r; ++i) {
					var o = e[i];
					o.id in t && n.push(o)
				}
				return n
			};
			var Ts = {
				aliceblue: 15792383,
				antiquewhite: 16444375,
				aqua: 65535,
				aquamarine: 8388564,
				azure: 15794175,
				beige: 16119260,
				bisque: 16770244,
				black: 0,
				blanchedalmond: 16772045,
				blue: 255,
				blueviolet: 9055202,
				brown: 10824234,
				burlywood: 14596231,
				cadetblue: 6266528,
				chartreuse: 8388352,
				chocolate: 13789470,
				coral: 16744272,
				cornflowerblue: 6591981,
				cornsilk: 16775388,
				crimson: 14423100,
				cyan: 65535,
				darkblue: 139,
				darkcyan: 35723,
				darkgoldenrod: 12092939,
				darkgray: 11119017,
				darkgreen: 25600,
				darkgrey: 11119017,
				darkkhaki: 12433259,
				darkmagenta: 9109643,
				darkolivegreen: 5597999,
				darkorange: 16747520,
				darkorchid: 10040012,
				darkred: 9109504,
				darksalmon: 15308410,
				darkseagreen: 9419919,
				darkslateblue: 4734347,
				darkslategray: 3100495,
				darkslategrey: 3100495,
				darkturquoise: 52945,
				darkviolet: 9699539,
				deeppink: 16716947,
				deepskyblue: 49151,
				dimgray: 6908265,
				dimgrey: 6908265,
				dodgerblue: 2003199,
				firebrick: 11674146,
				floralwhite: 16775920,
				forestgreen: 2263842,
				fuchsia: 16711935,
				gainsboro: 14474460,
				ghostwhite: 16316671,
				gold: 16766720,
				goldenrod: 14329120,
				gray: 8421504,
				green: 32768,
				greenyellow: 11403055,
				grey: 8421504,
				honeydew: 15794160,
				hotpink: 16738740,
				indianred: 13458524,
				indigo: 4915330,
				ivory: 16777200,
				khaki: 15787660,
				lavender: 15132410,
				lavenderblush: 16773365,
				lawngreen: 8190976,
				lemonchiffon: 16775885,
				lightblue: 11393254,
				lightcoral: 15761536,
				lightcyan: 14745599,
				lightgoldenrodyellow: 16448210,
				lightgray: 13882323,
				lightgreen: 9498256,
				lightgrey: 13882323,
				lightpink: 16758465,
				lightsalmon: 16752762,
				lightseagreen: 2142890,
				lightskyblue: 8900346,
				lightslategray: 7833753,
				lightslategrey: 7833753,
				lightsteelblue: 11584734,
				lightyellow: 16777184,
				lime: 65280,
				limegreen: 3329330,
				linen: 16445670,
				magenta: 16711935,
				maroon: 8388608,
				mediumaquamarine: 6737322,
				mediumblue: 205,
				mediumorchid: 12211667,
				mediumpurple: 9662683,
				mediumseagreen: 3978097,
				mediumslateblue: 8087790,
				mediumspringgreen: 64154,
				mediumturquoise: 4772300,
				mediumvioletred: 13047173,
				midnightblue: 1644912,
				mintcream: 16121850,
				mistyrose: 16770273,
				moccasin: 16770229,
				navajowhite: 16768685,
				navy: 128,
				oldlace: 16643558,
				olive: 8421376,
				olivedrab: 7048739,
				orange: 16753920,
				orangered: 16729344,
				orchid: 14315734,
				palegoldenrod: 15657130,
				palegreen: 10025880,
				paleturquoise: 11529966,
				palevioletred: 14381203,
				papayawhip: 16773077,
				peachpuff: 16767673,
				peru: 13468991,
				pink: 16761035,
				plum: 14524637,
				powderblue: 11591910,
				purple: 8388736,
				rebeccapurple: 6697881,
				red: 16711680,
				rosybrown: 12357519,
				royalblue: 4286945,
				saddlebrown: 9127187,
				salmon: 16416882,
				sandybrown: 16032864,
				seagreen: 3050327,
				seashell: 16774638,
				sienna: 10506797,
				silver: 12632256,
				skyblue: 8900331,
				slateblue: 6970061,
				slategray: 7372944,
				slategrey: 7372944,
				snow: 16775930,
				springgreen: 65407,
				steelblue: 4620980,
				tan: 13808780,
				teal: 32896,
				thistle: 14204888,
				tomato: 16737095,
				turquoise: 4251856,
				violet: 15631086,
				wheat: 16113331,
				white: 16777215,
				whitesmoke: 16119285,
				yellow: 16776960,
				yellowgreen: 10145074
			};
			Object.assign(X.prototype, {
				isColor: !0,
				r: 1,
				g: 1,
				b: 1,
				set: function(e) {
					return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
				},
				setScalar: function(e) {
					return this.r = e, this.g = e, this.b = e, this
				},
				setHex: function(e) {
					return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
				},
				setRGB: function(e, t, n) {
					return this.r = e, this.g = t, this.b = n, this
				},
				setHSL: function() {
					function e(e, t, n) {
						return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
					}
					return function(t, n, i) {
						if (t = gs.euclideanModulo(t, 1), n = gs.clamp(n, 0, 1), i = gs.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
						else {
							var r = i <= .5 ? i * (1 + n) : i + n - i * n,
								o = 2 * i - r;
							this.r = e(o, r, t + 1 / 3), this.g = e(o, r, t), this.b = e(o, r, t - 1 / 3)
						}
						return this
					}
				}(),
				setStyle: function(e) {
					function t(t) {
						void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
					}
					var n;
					if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
						var i, r = n[1],
							o = n[2];
						switch (r) {
							case "rgb":
							case "rgba":
								if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
								if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
								break;
							case "hsl":
							case "hsla":
								if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
									var a = parseFloat(i[1]) / 360,
										s = parseInt(i[2], 10) / 100,
										c = parseInt(i[3], 10) / 100;
									return t(i[5]), this.setHSL(a, s, c)
								}
						}
					} else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
						var l = (u = n[1]).length;
						if (3 === l) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
						if (6 === l) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
					}
					if (e && e.length > 0) {
						var u = Ts[e];
						void 0 !== u ? this.setHex(u) : console.warn("THREE.Color: Unknown color " + e)
					}
					return this
				},
				clone: function() {
					return new this.constructor(this.r, this.g, this.b)
				},
				copy: function(e) {
					return this.r = e.r, this.g = e.g, this.b = e.b, this
				},
				copyGammaToLinear: function(e, t) {
					return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
				},
				copyLinearToGamma: function(e, t) {
					void 0 === t && (t = 2);
					var n = t > 0 ? 1 / t : 1;
					return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
				},
				convertGammaToLinear: function() {
					var e = this.r,
						t = this.g,
						n = this.b;
					return this.r = e * e, this.g = t * t, this.b = n * n, this
				},
				convertLinearToGamma: function() {
					return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
				},
				getHex: function() {
					return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
				},
				getHexString: function() {
					return ("000000" + this.getHex().toString(16)).slice(-6)
				},
				getHSL: function(e) {
					var t, n, i = e || {
							h: 0,
							s: 0,
							l: 0
						},
						r = this.r,
						o = this.g,
						a = this.b,
						s = Math.max(r, o, a),
						c = Math.min(r, o, a),
						l = (c + s) / 2;
					if (c === s) t = 0, n = 0;
					else {
						var u = s - c;
						switch (n = l <= .5 ? u / (s + c) : u / (2 - s - c), s) {
							case r:
								t = (o - a) / u + (o < a ? 6 : 0);
								break;
							case o:
								t = (a - r) / u + 2;
								break;
							case a:
								t = (r - o) / u + 4
						}
						t /= 6
					}
					return i.h = t, i.s = n, i.l = l, i
				},
				getStyle: function() {
					return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
				},
				offsetHSL: function(e, t, n) {
					var i = this.getHSL();
					return i.h += e, i.s += t, i.l += n, this.setHSL(i.h, i.s, i.l), this
				},
				add: function(e) {
					return this.r += e.r, this.g += e.g, this.b += e.b, this
				},
				addColors: function(e, t) {
					return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
				},
				addScalar: function(e) {
					return this.r += e, this.g += e, this.b += e, this
				},
				sub: function(e) {
					return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
				},
				multiply: function(e) {
					return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
				},
				multiplyScalar: function(e) {
					return this.r *= e, this.g *= e, this.b *= e, this
				},
				lerp: function(e, t) {
					return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
				},
				equals: function(e) {
					return e.r === this.r && e.g === this.g && e.b === this.b
				},
				fromArray: function(e, t) {
					return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
				},
				toArray: function(e, t) {
					return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
				},
				toJSON: function() {
					return this.getHex()
				}
			});
			var Ps = {
					common: {
						diffuse: {
							value: new X(15658734)
						},
						opacity: {
							value: 1
						},
						map: {
							value: null
						},
						uvTransform: {
							value: new a
						},
						alphaMap: {
							value: null
						}
					},
					specularmap: {
						specularMap: {
							value: null
						}
					},
					envmap: {
						envMap: {
							value: null
						},
						flipEnvMap: {
							value: -1
						},
						reflectivity: {
							value: 1
						},
						refractionRatio: {
							value: .98
						}
					},
					aomap: {
						aoMap: {
							value: null
						},
						aoMapIntensity: {
							value: 1
						}
					},
					lightmap: {
						lightMap: {
							value: null
						},
						lightMapIntensity: {
							value: 1
						}
					},
					emissivemap: {
						emissiveMap: {
							value: null
						}
					},
					bumpmap: {
						bumpMap: {
							value: null
						},
						bumpScale: {
							value: 1
						}
					},
					normalmap: {
						normalMap: {
							value: null
						},
						normalScale: {
							value: new n(1, 1)
						}
					},
					displacementmap: {
						displacementMap: {
							value: null
						},
						displacementScale: {
							value: 1
						},
						displacementBias: {
							value: 0
						}
					},
					roughnessmap: {
						roughnessMap: {
							value: null
						}
					},
					metalnessmap: {
						metalnessMap: {
							value: null
						}
					},
					gradientmap: {
						gradientMap: {
							value: null
						}
					},
					fog: {
						fogDensity: {
							value: 25e-5
						},
						fogNear: {
							value: 1
						},
						fogFar: {
							value: 2e3
						},
						fogColor: {
							value: new X(16777215)
						}
					},
					lights: {
						ambientLightColor: {
							value: []
						},
						directionalLights: {
							value: [],
							properties: {
								direction: {},
								color: {},
								shadow: {},
								shadowBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						directionalShadowMap: {
							value: []
						},
						directionalShadowMatrix: {
							value: []
						},
						spotLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								direction: {},
								distance: {},
								coneCos: {},
								penumbraCos: {},
								decay: {},
								shadow: {},
								shadowBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						spotShadowMap: {
							value: []
						},
						spotShadowMatrix: {
							value: []
						},
						pointLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								decay: {},
								distance: {},
								shadow: {},
								shadowBias: {},
								shadowRadius: {},
								shadowMapSize: {},
								shadowCameraNear: {},
								shadowCameraFar: {}
							}
						},
						pointShadowMap: {
							value: []
						},
						pointShadowMatrix: {
							value: []
						},
						hemisphereLights: {
							value: [],
							properties: {
								direction: {},
								skyColor: {},
								groundColor: {}
							}
						},
						rectAreaLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								width: {},
								height: {}
							}
						}
					},
					points: {
						diffuse: {
							value: new X(15658734)
						},
						opacity: {
							value: 1
						},
						size: {
							value: 1
						},
						scale: {
							value: 1
						},
						map: {
							value: null
						},
						uvTransform: {
							value: new a
						}
					}
				},
				As = {
					merge: function(e) {
						for (var t = {}, n = 0; n < e.length; n++) {
							var i = this.clone(e[n]);
							for (var r in i) t[r] = i[r]
						}
						return t
					},
					clone: function(e) {
						var t = {};
						for (var n in e) {
							t[n] = {};
							for (var i in e[n]) {
								var r = e[n][i];
								r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
							}
						}
						return t
					}
				},
				Ls = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "\nvec3 transformed = vec3( position );\n",
					beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
					bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
					color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
					color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
					common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
					defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
					encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
					encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
					envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
					fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
					gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
					lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
					lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
					map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
					map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
					normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
					project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
					dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
					dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
					tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
					uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
					uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
					cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
					cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
					equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
					meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
					normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
					shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
				},
				Cs = {
					basic: {
						uniforms: As.merge([Ps.common, Ps.specularmap, Ps.envmap, Ps.aomap, Ps.lightmap, Ps.fog]),
						vertexShader: Ls.meshbasic_vert,
						fragmentShader: Ls.meshbasic_frag
					},
					lambert: {
						uniforms: As.merge([Ps.common, Ps.specularmap, Ps.envmap, Ps.aomap, Ps.lightmap, Ps.emissivemap, Ps.fog, Ps.lights, {
							emissive: {
								value: new X(0)
							}
						}]),
						vertexShader: Ls.meshlambert_vert,
						fragmentShader: Ls.meshlambert_frag
					},
					phong: {
						uniforms: As.merge([Ps.common, Ps.specularmap, Ps.envmap, Ps.aomap, Ps.lightmap, Ps.emissivemap, Ps.bumpmap, Ps.normalmap, Ps.displacementmap, Ps.gradientmap, Ps.fog, Ps.lights, {
							emissive: {
								value: new X(0)
							},
							specular: {
								value: new X(1118481)
							},
							shininess: {
								value: 30
							}
						}]),
						vertexShader: Ls.meshphong_vert,
						fragmentShader: Ls.meshphong_frag
					},
					standard: {
						uniforms: As.merge([Ps.common, Ps.envmap, Ps.aomap, Ps.lightmap, Ps.emissivemap, Ps.bumpmap, Ps.normalmap, Ps.displacementmap, Ps.roughnessmap, Ps.metalnessmap, Ps.fog, Ps.lights, {
							emissive: {
								value: new X(0)
							},
							roughness: {
								value: .5
							},
							metalness: {
								value: .5
							},
							envMapIntensity: {
								value: 1
							}
						}]),
						vertexShader: Ls.meshphysical_vert,
						fragmentShader: Ls.meshphysical_frag
					},
					points: {
						uniforms: As.merge([Ps.points, Ps.fog]),
						vertexShader: Ls.points_vert,
						fragmentShader: Ls.points_frag
					},
					dashed: {
						uniforms: As.merge([Ps.common, Ps.fog, {
							scale: {
								value: 1
							},
							dashSize: {
								value: 1
							},
							totalSize: {
								value: 2
							}
						}]),
						vertexShader: Ls.linedashed_vert,
						fragmentShader: Ls.linedashed_frag
					},
					depth: {
						uniforms: As.merge([Ps.common, Ps.displacementmap]),
						vertexShader: Ls.depth_vert,
						fragmentShader: Ls.depth_frag
					},
					normal: {
						uniforms: As.merge([Ps.common, Ps.bumpmap, Ps.normalmap, Ps.displacementmap, {
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Ls.normal_vert,
						fragmentShader: Ls.normal_frag
					},
					cube: {
						uniforms: {
							tCube: {
								value: null
							},
							tFlip: {
								value: -1
							},
							opacity: {
								value: 1
							}
						},
						vertexShader: Ls.cube_vert,
						fragmentShader: Ls.cube_frag
					},
					equirect: {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: Ls.equirect_vert,
						fragmentShader: Ls.equirect_frag
					},
					distanceRGBA: {
						uniforms: As.merge([Ps.common, Ps.displacementmap, {
							referencePosition: {
								value: new o
							},
							nearDistance: {
								value: 1
							},
							farDistance: {
								value: 1e3
							}
						}]),
						vertexShader: Ls.distanceRGBA_vert,
						fragmentShader: Ls.distanceRGBA_frag
					},
					shadow: {
						uniforms: As.merge([Ps.lights, Ps.fog, {
							color: {
								value: new X(0)
							},
							opacity: {
								value: 1
							}
						}]),
						vertexShader: Ls.shadow_vert,
						fragmentShader: Ls.shadow_frag
					}
				};
			Cs.physical = {
				uniforms: As.merge([Cs.standard.uniforms, {
					clearCoat: {
						value: 0
					},
					clearCoatRoughness: {
						value: 0
					}
				}]),
				vertexShader: Ls.meshphysical_vert,
				fragmentShader: Ls.meshphysical_frag
			}, Object.assign(q.prototype, {
				set: function(e, t) {
					return this.min.copy(e), this.max.copy(t), this
				},
				setFromPoints: function(e) {
					this.makeEmpty();
					for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
					return this
				},
				setFromCenterAndSize: function() {
					var e = new n;
					return function(t, n) {
						var i = e.copy(n).multiplyScalar(.5);
						return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
					}
				}(),
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.min.copy(e.min), this.max.copy(e.max), this
				},
				makeEmpty: function() {
					return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
				},
				isEmpty: function() {
					return this.max.x < this.min.x || this.max.y < this.min.y
				},
				getCenter: function(e) {
					var t = e || new n;
					return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
				},
				getSize: function(e) {
					var t = e || new n;
					return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
				},
				expandByPoint: function(e) {
					return this.min.min(e), this.max.max(e), this
				},
				expandByVector: function(e) {
					return this.min.sub(e), this.max.add(e), this
				},
				expandByScalar: function(e) {
					return this.min.addScalar(-e), this.max.addScalar(e), this
				},
				containsPoint: function(e) {
					return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
				},
				containsBox: function(e) {
					return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
				},
				getParameter: function(e, t) {
					return (t || new n).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
				},
				intersectsBox: function(e) {
					return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
				},
				clampPoint: function(e, t) {
					return (t || new n).copy(e).clamp(this.min, this.max)
				},
				distanceToPoint: function() {
					var e = new n;
					return function(t) {
						return e.copy(t).clamp(this.min, this.max).sub(t).length()
					}
				}(),
				intersect: function(e) {
					return this.min.max(e.min), this.max.min(e.max), this
				},
				union: function(e) {
					return this.min.min(e.min), this.max.max(e.max), this
				},
				translate: function(e) {
					return this.min.add(e), this.max.add(e), this
				},
				equals: function(e) {
					return e.min.equals(this.min) && e.max.equals(this.max)
				}
			}), K.prototype = Object.create(s.prototype), K.prototype.constructor = K;
			var zs = 0;
			Q.prototype = Object.assign(Object.create(t.prototype), {
				constructor: Q,
				isMaterial: !0,
				onBeforeCompile: function() {},
				setValues: function(e) {
					if (void 0 !== e)
						for (var t in e) {
							var n = e[t];
							if (void 0 !== n)
								if ("shading" !== t) {
									var i = this[t];
									void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = "overdraw" === t ? Number(n) : n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
								} else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
							else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
						}
				},
				toJSON: function(e) {
					function t(e) {
						var t = [];
						for (var n in e) {
							var i = e[n];
							delete i.metadata, t.push(i)
						}
						return t
					}
					var n = void 0 === e || "string" == typeof e;
					n && (e = {
						textures: {},
						images: {}
					});
					var i = {
						metadata: {
							version: 4.5,
							type: "Material",
							generator: "Material.toJSON"
						}
					};
					if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Lo && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== Mo && (i.side = this.side), this.vertexColors !== Eo && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), n) {
						var r = t(e.textures),
							o = t(e.images);
						r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o)
					}
					return i
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
					var t = e.clippingPlanes,
						n = null;
					if (null !== t) {
						var i = t.length;
						n = new Array(i);
						for (var r = 0; r !== i; ++r) n[r] = t[r].clone()
					}
					return this.clippingPlanes = n, this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}), $.prototype = Object.create(Q.prototype), $.prototype.constructor = $, $.prototype.isMeshDepthMaterial = !0, $.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
			}, ee.prototype = Object.create(Q.prototype), ee.prototype.constructor = ee, ee.prototype.isMeshDistanceMaterial = !0, ee.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
			}, Object.assign(te.prototype, {
				isBox3: !0,
				set: function(e, t) {
					return this.min.copy(e), this.max.copy(t), this
				},
				setFromArray: function(e) {
					for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
						var l = e[s],
							u = e[s + 1],
							h = e[s + 2];
						l < t && (t = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > o && (o = u), h > a && (a = h)
					}
					return this.min.set(t, n, i), this.max.set(r, o, a), this
				},
				setFromBufferAttribute: function(e) {
					for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.count; s < c; s++) {
						var l = e.getX(s),
							u = e.getY(s),
							h = e.getZ(s);
						l < t && (t = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > o && (o = u), h > a && (a = h)
					}
					return this.min.set(t, n, i), this.max.set(r, o, a), this
				},
				setFromPoints: function(e) {
					this.makeEmpty();
					for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
					return this
				},
				setFromCenterAndSize: function() {
					var e = new o;
					return function(t, n) {
						var i = e.copy(n).multiplyScalar(.5);
						return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
					}
				}(),
				setFromObject: function(e) {
					return this.makeEmpty(), this.expandByObject(e)
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.min.copy(e.min), this.max.copy(e.max), this
				},
				makeEmpty: function() {
					return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
				},
				isEmpty: function() {
					return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
				},
				getCenter: function(e) {
					var t = e || new o;
					return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
				},
				getSize: function(e) {
					var t = e || new o;
					return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
				},
				expandByPoint: function(e) {
					return this.min.min(e), this.max.max(e), this
				},
				expandByVector: function(e) {
					return this.min.sub(e), this.max.add(e), this
				},
				expandByScalar: function(e) {
					return this.min.addScalar(-e), this.max.addScalar(e), this
				},
				expandByObject: function() {
					function e(e) {
						var o = e.geometry;
						if (void 0 !== o)
							if (o.isGeometry) {
								var a = o.vertices;
								for (n = 0, i = a.length; n < i; n++) r.copy(a[n]), r.applyMatrix4(e.matrixWorld), t.expandByPoint(r)
							} else if (o.isBufferGeometry) {
							var s = o.attributes.position;
							if (void 0 !== s)
								for (n = 0, i = s.count; n < i; n++) r.fromBufferAttribute(s, n).applyMatrix4(e.matrixWorld), t.expandByPoint(r)
						}
					}
					var t, n, i, r = new o;
					return function(n) {
						return t = this, n.updateMatrixWorld(!0), n.traverse(e), this
					}
				}(),
				containsPoint: function(e) {
					return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
				},
				containsBox: function(e) {
					return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
				},
				getParameter: function(e, t) {
					return (t || new o).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
				},
				intersectsBox: function(e) {
					return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
				},
				intersectsSphere: function() {
					var e = new o;
					return function(t) {
						return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
					}
				}(),
				intersectsPlane: function(e) {
					var t, n;
					return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= e.constant && n >= e.constant
				},
				clampPoint: function(e, t) {
					return (t || new o).copy(e).clamp(this.min, this.max)
				},
				distanceToPoint: function() {
					var e = new o;
					return function(t) {
						return e.copy(t).clamp(this.min, this.max).sub(t).length()
					}
				}(),
				getBoundingSphere: function() {
					var e = new o;
					return function(t) {
						var n = t || new ne;
						return this.getCenter(n.center), n.radius = .5 * this.getSize(e).length(), n
					}
				}(),
				intersect: function(e) {
					return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
				},
				union: function(e) {
					return this.min.min(e.min), this.max.max(e.max), this
				},
				applyMatrix4: function() {
					var e = [new o, new o, new o, new o, new o, new o, new o, new o];
					return function(t) {
						return this.isEmpty() ? this : (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e), this)
					}
				}(),
				translate: function(e) {
					return this.min.add(e), this.max.add(e), this
				},
				equals: function(e) {
					return e.min.equals(this.min) && e.max.equals(this.max)
				}
			}), Object.assign(ne.prototype, {
				set: function(e, t) {
					return this.center.copy(e), this.radius = t, this
				},
				setFromPoints: function() {
					var e = new te;
					return function(t, n) {
						var i = this.center;
						void 0 !== n ? i.copy(n) : e.setFromPoints(t).getCenter(i);
						for (var r = 0, o = 0, a = t.length; o < a; o++) r = Math.max(r, i.distanceToSquared(t[o]));
						return this.radius = Math.sqrt(r), this
					}
				}(),
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.center.copy(e.center), this.radius = e.radius, this
				},
				empty: function() {
					return this.radius <= 0
				},
				containsPoint: function(e) {
					return e.distanceToSquared(this.center) <= this.radius * this.radius
				},
				distanceToPoint: function(e) {
					return e.distanceTo(this.center) - this.radius
				},
				intersectsSphere: function(e) {
					var t = this.radius + e.radius;
					return e.center.distanceToSquared(this.center) <= t * t
				},
				intersectsBox: function(e) {
					return e.intersectsSphere(this)
				},
				intersectsPlane: function(e) {
					return Math.abs(e.distanceToPoint(this.center)) <= this.radius
				},
				clampPoint: function(e, t) {
					var n = this.center.distanceToSquared(e),
						i = t || new o;
					return i.copy(e), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i
				},
				getBoundingBox: function(e) {
					var t = e || new te;
					return t.set(this.center, this.center), t.expandByScalar(this.radius), t
				},
				applyMatrix4: function(e) {
					return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
				},
				translate: function(e) {
					return this.center.add(e), this
				},
				equals: function(e) {
					return e.center.equals(this.center) && e.radius === this.radius
				}
			}), Object.assign(ie.prototype, {
				set: function(e, t) {
					return this.normal.copy(e), this.constant = t, this
				},
				setComponents: function(e, t, n, i) {
					return this.normal.set(e, t, n), this.constant = i, this
				},
				setFromNormalAndCoplanarPoint: function(e, t) {
					return this.normal.copy(e), this.constant = -t.dot(this.normal), this
				},
				setFromCoplanarPoints: function() {
					var e = new o,
						t = new o;
					return function(n, i, r) {
						var o = e.subVectors(r, i).cross(t.subVectors(n, i)).normalize();
						return this.setFromNormalAndCoplanarPoint(o, n), this
					}
				}(),
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.normal.copy(e.normal), this.constant = e.constant, this
				},
				normalize: function() {
					var e = 1 / this.normal.length();
					return this.normal.multiplyScalar(e), this.constant *= e, this
				},
				negate: function() {
					return this.constant *= -1, this.normal.negate(), this
				},
				distanceToPoint: function(e) {
					return this.normal.dot(e) + this.constant
				},
				distanceToSphere: function(e) {
					return this.distanceToPoint(e.center) - e.radius
				},
				projectPoint: function(e, t) {
					return (t || new o).copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
				},
				intersectLine: function() {
					var e = new o;
					return function(t, n) {
						var i = n || new o,
							r = t.delta(e),
							a = this.normal.dot(r);
						if (0 !== a) {
							var s = -(t.start.dot(this.normal) + this.constant) / a;
							if (!(s < 0 || s > 1)) return i.copy(r).multiplyScalar(s).add(t.start)
						} else if (0 === this.distanceToPoint(t.start)) return i.copy(t.start)
					}
				}(),
				intersectsLine: function(e) {
					var t = this.distanceToPoint(e.start),
						n = this.distanceToPoint(e.end);
					return t < 0 && n > 0 || n < 0 && t > 0
				},
				intersectsBox: function(e) {
					return e.intersectsPlane(this)
				},
				intersectsSphere: function(e) {
					return e.intersectsPlane(this)
				},
				coplanarPoint: function(e) {
					return (e || new o).copy(this.normal).multiplyScalar(-this.constant)
				},
				applyMatrix4: function() {
					var e = new o,
						t = new a;
					return function(n, i) {
						var r = i || t.getNormalMatrix(n),
							o = this.coplanarPoint(e).applyMatrix4(n),
							a = this.normal.applyMatrix3(r).normalize();
						return this.constant = -o.dot(a), this
					}
				}(),
				translate: function(e) {
					return this.constant -= e.dot(this.normal), this
				},
				equals: function(e) {
					return e.normal.equals(this.normal) && e.constant === this.constant
				}
			}), Object.assign(re.prototype, {
				set: function(e, t, n, i, r, o) {
					var a = this.planes;
					return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
					return this
				},
				setFromMatrix: function(e) {
					var t = this.planes,
						n = e.elements,
						i = n[0],
						r = n[1],
						o = n[2],
						a = n[3],
						s = n[4],
						c = n[5],
						l = n[6],
						u = n[7],
						h = n[8],
						d = n[9],
						f = n[10],
						v = n[11],
						p = n[12],
						m = n[13],
						g = n[14],
						y = n[15];
					return t[0].setComponents(a - i, u - s, v - h, y - p).normalize(), t[1].setComponents(a + i, u + s, v + h, y + p).normalize(), t[2].setComponents(a + r, u + c, v + d, y + m).normalize(), t[3].setComponents(a - r, u - c, v - d, y - m).normalize(), t[4].setComponents(a - o, u - l, v - f, y - g).normalize(), t[5].setComponents(a + o, u + l, v + f, y + g).normalize(), this
				},
				intersectsObject: function() {
					var e = new ne;
					return function(t) {
						var n = t.geometry;
						return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
					}
				}(),
				intersectsSprite: function() {
					var e = new ne;
					return function(t) {
						return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
					}
				}(),
				intersectsSphere: function(e) {
					for (var t = this.planes, n = e.center, i = -e.radius, r = 0; r < 6; r++)
						if (t[r].distanceToPoint(n) < i) return !1;
					return !0
				},
				intersectsBox: function() {
					var e = new o,
						t = new o;
					return function(n) {
						for (var i = this.planes, r = 0; r < 6; r++) {
							var o = i[r];
							e.x = o.normal.x > 0 ? n.min.x : n.max.x, t.x = o.normal.x > 0 ? n.max.x : n.min.x, e.y = o.normal.y > 0 ? n.min.y : n.max.y, t.y = o.normal.y > 0 ? n.max.y : n.min.y, e.z = o.normal.z > 0 ? n.min.z : n.max.z, t.z = o.normal.z > 0 ? n.max.z : n.min.z;
							var a = o.distanceToPoint(e),
								s = o.distanceToPoint(t);
							if (a < 0 && s < 0) return !1
						}
						return !0
					}
				}(),
				containsPoint: function(e) {
					for (var t = this.planes, n = 0; n < 6; n++)
						if (t[n].distanceToPoint(e) < 0) return !1;
					return !0
				}
			}), se.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], se.DefaultOrder = "XYZ", Object.defineProperties(se.prototype, {
				x: {
					get: function() {
						return this._x
					},
					set: function(e) {
						this._x = e, this.onChangeCallback()
					}
				},
				y: {
					get: function() {
						return this._y
					},
					set: function(e) {
						this._y = e, this.onChangeCallback()
					}
				},
				z: {
					get: function() {
						return this._z
					},
					set: function(e) {
						this._z = e, this.onChangeCallback()
					}
				},
				order: {
					get: function() {
						return this._order
					},
					set: function(e) {
						this._order = e, this.onChangeCallback()
					}
				}
			}), Object.assign(se.prototype, {
				isEuler: !0,
				set: function(e, t, n, i) {
					return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
				},
				clone: function() {
					return new this.constructor(this._x, this._y, this._z, this._order)
				},
				copy: function(e) {
					return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
				},
				setFromRotationMatrix: function(e, t, n) {
					var i = gs.clamp,
						r = e.elements,
						o = r[0],
						a = r[4],
						s = r[8],
						c = r[1],
						l = r[5],
						u = r[9],
						h = r[2],
						d = r[6],
						f = r[10];
					return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === t ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === t ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, f))) : "XZY" === t ? (this._z = Math.asin(-i(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this.onChangeCallback(), this
				},
				setFromQuaternion: function() {
					var e = new i;
					return function(t, n, i) {
						return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, n, i)
					}
				}(),
				setFromVector3: function(e, t) {
					return this.set(e.x, e.y, e.z, t || this._order)
				},
				reorder: function() {
					var e = new r;
					return function(t) {
						return e.setFromEuler(this), this.setFromQuaternion(e, t)
					}
				}(),
				equals: function(e) {
					return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
				},
				fromArray: function(e) {
					return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
				},
				toArray: function(e, t) {
					return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
				},
				toVector3: function(e) {
					return e ? e.set(this._x, this._y, this._z) : new o(this._x, this._y, this._z)
				},
				onChange: function(e) {
					return this.onChangeCallback = e, this
				},
				onChangeCallback: function() {}
			}), Object.assign(ce.prototype, {
				set: function(e) {
					this.mask = 1 << e | 0
				},
				enable: function(e) {
					this.mask |= 1 << e | 0
				},
				toggle: function(e) {
					this.mask ^= 1 << e | 0
				},
				disable: function(e) {
					this.mask &= ~(1 << e | 0)
				},
				test: function(e) {
					return 0 != (this.mask & e.mask)
				}
			});
			var Rs = 0;
			le.DefaultUp = new o(0, 1, 0), le.DefaultMatrixAutoUpdate = !0, le.prototype = Object.assign(Object.create(t.prototype), {
				constructor: le,
				isObject3D: !0,
				onBeforeRender: function() {},
				onAfterRender: function() {},
				applyMatrix: function(e) {
					this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
				},
				applyQuaternion: function(e) {
					return this.quaternion.premultiply(e), this
				},
				setRotationFromAxisAngle: function(e, t) {
					this.quaternion.setFromAxisAngle(e, t)
				},
				setRotationFromEuler: function(e) {
					this.quaternion.setFromEuler(e, !0)
				},
				setRotationFromMatrix: function(e) {
					this.quaternion.setFromRotationMatrix(e)
				},
				setRotationFromQuaternion: function(e) {
					this.quaternion.copy(e)
				},
				rotateOnAxis: function() {
					var e = new r;
					return function(t, n) {
						return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
					}
				}(),
				rotateOnWorldAxis: function() {
					var e = new r;
					return function(t, n) {
						return e.setFromAxisAngle(t, n), this.quaternion.premultiply(e), this
					}
				}(),
				rotateX: function() {
					var e = new o(1, 0, 0);
					return function(t) {
						return this.rotateOnAxis(e, t)
					}
				}(),
				rotateY: function() {
					var e = new o(0, 1, 0);
					return function(t) {
						return this.rotateOnAxis(e, t)
					}
				}(),
				rotateZ: function() {
					var e = new o(0, 0, 1);
					return function(t) {
						return this.rotateOnAxis(e, t)
					}
				}(),
				translateOnAxis: function() {
					var e = new o;
					return function(t, n) {
						return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
					}
				}(),
				translateX: function() {
					var e = new o(1, 0, 0);
					return function(t) {
						return this.translateOnAxis(e, t)
					}
				}(),
				translateY: function() {
					var e = new o(0, 1, 0);
					return function(t) {
						return this.translateOnAxis(e, t)
					}
				}(),
				translateZ: function() {
					var e = new o(0, 0, 1);
					return function(t) {
						return this.translateOnAxis(e, t)
					}
				}(),
				localToWorld: function(e) {
					return e.applyMatrix4(this.matrixWorld)
				},
				worldToLocal: function() {
					var e = new i;
					return function(t) {
						return t.applyMatrix4(e.getInverse(this.matrixWorld))
					}
				}(),
				lookAt: function() {
					var e = new i,
						t = new o;
					return function(n, i, r) {
						n.isVector3 ? t.copy(n) : t.set(n, i, r), this.isCamera ? e.lookAt(this.position, t, this.up) : e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
					}
				}(),
				add: function(e) {
					if (arguments.length > 1) {
						for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
						return this
					}
					return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
						type: "added"
					}), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
				},
				remove: function(e) {
					if (arguments.length > 1) {
						for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
						return this
					}
					var n = this.children.indexOf(e);
					return -1 !== n && (e.parent = null, e.dispatchEvent({
						type: "removed"
					}), this.children.splice(n, 1)), this
				},
				getObjectById: function(e) {
					return this.getObjectByProperty("id", e)
				},
				getObjectByName: function(e) {
					return this.getObjectByProperty("name", e)
				},
				getObjectByProperty: function(e, t) {
					if (this[e] === t) return this;
					for (var n = 0, i = this.children.length; n < i; n++) {
						var r = this.children[n].getObjectByProperty(e, t);
						if (void 0 !== r) return r
					}
				},
				getWorldPosition: function(e) {
					var t = e || new o;
					return this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
				},
				getWorldQuaternion: function() {
					var e = new o,
						t = new o;
					return function(n) {
						var i = n || new r;
						return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
					}
				}(),
				getWorldRotation: function() {
					var e = new r;
					return function(t) {
						var n = t || new se;
						return this.getWorldQuaternion(e), n.setFromQuaternion(e, this.rotation.order, !1)
					}
				}(),
				getWorldScale: function() {
					var e = new o,
						t = new r;
					return function(n) {
						var i = n || new o;
						return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
					}
				}(),
				getWorldDirection: function() {
					var e = new r;
					return function(t) {
						var n = t || new o;
						return this.getWorldQuaternion(e), n.set(0, 0, 1).applyQuaternion(e)
					}
				}(),
				raycast: function() {},
				traverse: function(e) {
					e(this);
					for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverse(e)
				},
				traverseVisible: function(e) {
					if (!1 !== this.visible) {
						e(this);
						for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
					}
				},
				traverseAncestors: function(e) {
					var t = this.parent;
					null !== t && (e(t), t.traverseAncestors(e))
				},
				updateMatrix: function() {
					this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
				},
				updateMatrixWorld: function(e) {
					this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
					for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
				},
				toJSON: function(e) {
					function t(t, n) {
						return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
					}

					function n(e) {
						var t = [];
						for (var n in e) {
							var i = e[n];
							delete i.metadata, t.push(i)
						}
						return t
					}
					var i = void 0 === e || "string" == typeof e,
						r = {};
					i && (e = {
						geometries: {},
						materials: {},
						textures: {},
						images: {},
						shapes: {}
					}, r.metadata = {
						version: 4.5,
						type: "Object",
						generator: "Object3D.toJSON"
					});
					var o = {};
					if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.matrix = this.matrix.toArray(), void 0 !== this.geometry) {
						o.geometry = t(e.geometries, this.geometry);
						var a = this.geometry.parameters;
						if (void 0 !== a && void 0 !== a.shapes) {
							p = a.shapes;
							if (Array.isArray(p))
								for (var s = 0, c = p.length; s < c; s++) {
									var l = p[s];
									t(e.shapes, l)
								} else t(e.shapes, p)
						}
					}
					if (void 0 !== this.material)
						if (Array.isArray(this.material)) {
							for (var u = [], s = 0, c = this.material.length; s < c; s++) u.push(t(e.materials, this.material[s]));
							o.material = u
						} else o.material = t(e.materials, this.material);
					if (this.children.length > 0) {
						o.children = [];
						for (s = 0; s < this.children.length; s++) o.children.push(this.children[s].toJSON(e).object)
					}
					if (i) {
						var h = n(e.geometries),
							d = n(e.materials),
							f = n(e.textures),
							v = n(e.images),
							p = n(e.shapes);
						h.length > 0 && (r.geometries = h), d.length > 0 && (r.materials = d), f.length > 0 && (r.textures = f), v.length > 0 && (r.images = v), p.length > 0 && (r.shapes = p)
					}
					return r.object = o, r
				},
				clone: function(e) {
					return (new this.constructor).copy(this, e)
				},
				copy: function(e, t) {
					if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
						for (var n = 0; n < e.children.length; n++) {
							var i = e.children[n];
							this.add(i.clone())
						}
					return this
				}
			}), ue.prototype = Object.assign(Object.create(le.prototype), {
				constructor: ue,
				isCamera: !0,
				copy: function(e, t) {
					return le.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this
				},
				getWorldDirection: function() {
					var e = new r;
					return function(t) {
						var n = t || new o;
						return this.getWorldQuaternion(e), n.set(0, 0, -1).applyQuaternion(e)
					}
				}(),
				updateMatrixWorld: function(e) {
					le.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
				},
				clone: function() {
					return (new this.constructor).copy(this)
				}
			}), he.prototype = Object.assign(Object.create(ue.prototype), {
				constructor: he,
				isOrthographicCamera: !0,
				copy: function(e, t) {
					return ue.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
				},
				setViewOffset: function(e, t, n, i, r, o) {
					null === this.view && (this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
				},
				clearViewOffset: function() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				},
				updateProjectionMatrix: function() {
					var e = (this.right - this.left) / (2 * this.zoom),
						t = (this.top - this.bottom) / (2 * this.zoom),
						n = (this.right + this.left) / 2,
						i = (this.top + this.bottom) / 2,
						r = n - e,
						o = n + e,
						a = i + t,
						s = i - t;
					if (null !== this.view && this.view.enabled) {
						var c = this.zoom / (this.view.width / this.view.fullWidth),
							l = this.zoom / (this.view.height / this.view.fullHeight),
							u = (this.right - this.left) / this.view.width,
							h = (this.top - this.bottom) / this.view.height;
						o = (r += u * (this.view.offsetX / c)) + u * (this.view.width / c), s = (a -= h * (this.view.offsetY / l)) - h * (this.view.height / l)
					}
					this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far)
				},
				toJSON: function(e) {
					var t = le.prototype.toJSON.call(this, e);
					return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
				}
			}), Object.assign(de.prototype, {
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
					for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
					for (var t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
					return this
				}
			});
			var Is = 0;
			fe.prototype = Object.assign(Object.create(t.prototype), {
				constructor: fe,
				isGeometry: !0,
				applyMatrix: function(e) {
					for (var t = (new a).getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) this.vertices[n].applyMatrix4(e);
					for (var n = 0, i = this.faces.length; n < i; n++) {
						var r = this.faces[n];
						r.normal.applyMatrix3(t).normalize();
						for (var o = 0, s = r.vertexNormals.length; o < s; o++) r.vertexNormals[o].applyMatrix3(t).normalize()
					}
					return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
				},
				rotateX: function() {
					var e = new i;
					return function(t) {
						return e.makeRotationX(t), this.applyMatrix(e), this
					}
				}(),
				rotateY: function() {
					var e = new i;
					return function(t) {
						return e.makeRotationY(t), this.applyMatrix(e), this
					}
				}(),
				rotateZ: function() {
					var e = new i;
					return function(t) {
						return e.makeRotationZ(t), this.applyMatrix(e), this
					}
				}(),
				translate: function() {
					var e = new i;
					return function(t, n, i) {
						return e.makeTranslation(t, n, i), this.applyMatrix(e), this
					}
				}(),
				scale: function() {
					var e = new i;
					return function(t, n, i) {
						return e.makeScale(t, n, i), this.applyMatrix(e), this
					}
				}(),
				lookAt: function() {
					var e = new le;
					return function(t) {
						e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
					}
				}(),
				fromBufferGeometry: function(e) {
					function t(e, t, n, r) {
						var o = new de(e, t, n, void 0 !== c ? [d[e].clone(), d[t].clone(), d[n].clone()] : [], void 0 !== l ? [i.colors[e].clone(), i.colors[t].clone(), i.colors[n].clone()] : [], r);
						i.faces.push(o), void 0 !== u && i.faceVertexUvs[0].push([f[e].clone(), f[t].clone(), f[n].clone()]), void 0 !== h && i.faceVertexUvs[1].push([v[e].clone(), v[t].clone(), v[n].clone()])
					}
					var i = this,
						r = null !== e.index ? e.index.array : void 0,
						a = e.attributes,
						s = a.position.array,
						c = void 0 !== a.normal ? a.normal.array : void 0,
						l = void 0 !== a.color ? a.color.array : void 0,
						u = void 0 !== a.uv ? a.uv.array : void 0,
						h = void 0 !== a.uv2 ? a.uv2.array : void 0;
					void 0 !== h && (this.faceVertexUvs[1] = []);
					for (var d = [], f = [], v = [], p = 0, m = 0; p < s.length; p += 3, m += 2) i.vertices.push(new o(s[p], s[p + 1], s[p + 2])), void 0 !== c && d.push(new o(c[p], c[p + 1], c[p + 2])), void 0 !== l && i.colors.push(new X(l[p], l[p + 1], l[p + 2])), void 0 !== u && f.push(new n(u[m], u[m + 1])), void 0 !== h && v.push(new n(h[m], h[m + 1]));
					var g = e.groups;
					if (g.length > 0)
						for (p = 0; p < g.length; p++)
							for (var y = g[p], x = y.start, m = x, b = x + y.count; m < b; m += 3) void 0 !== r ? t(r[m], r[m + 1], r[m + 2], y.materialIndex) : t(m, m + 1, m + 2, y.materialIndex);
					else if (void 0 !== r)
						for (p = 0; p < r.length; p += 3) t(r[p], r[p + 1], r[p + 2]);
					else
						for (p = 0; p < s.length / 3; p += 3) t(p, p + 1, p + 2);
					return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
				},
				center: function() {
					this.computeBoundingBox();
					var e = this.boundingBox.getCenter().negate();
					return this.translate(e.x, e.y, e.z), e
				},
				normalize: function() {
					this.computeBoundingSphere();
					var e = this.boundingSphere.center,
						t = this.boundingSphere.radius,
						n = 0 === t ? 1 : 1 / t,
						r = new i;
					return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
				},
				computeFaceNormals: function() {
					for (var e = new o, t = new o, n = 0, i = this.faces.length; n < i; n++) {
						var r = this.faces[n],
							a = this.vertices[r.a],
							s = this.vertices[r.b],
							c = this.vertices[r.c];
						e.subVectors(c, s), t.subVectors(a, s), e.cross(t), e.normalize(), r.normal.copy(e)
					}
				},
				computeVertexNormals: function(e) {
					void 0 === e && (e = !0);
					var t, n, i, r, a, s;
					for (s = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) s[t] = new o;
					if (e) {
						var c, l, u, h = new o,
							d = new o;
						for (i = 0, r = this.faces.length; i < r; i++) a = this.faces[i], c = this.vertices[a.a], l = this.vertices[a.b], u = this.vertices[a.c], h.subVectors(u, l), d.subVectors(c, l), h.cross(d), s[a.a].add(h), s[a.b].add(h), s[a.c].add(h)
					} else
						for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) s[(a = this.faces[i]).a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
					for (t = 0, n = this.vertices.length; t < n; t++) s[t].normalize();
					for (i = 0, r = this.faces.length; i < r; i++) {
						var f = (a = this.faces[i]).vertexNormals;
						3 === f.length ? (f[0].copy(s[a.a]), f[1].copy(s[a.b]), f[2].copy(s[a.c])) : (f[0] = s[a.a].clone(), f[1] = s[a.b].clone(), f[2] = s[a.c].clone())
					}
					this.faces.length > 0 && (this.normalsNeedUpdate = !0)
				},
				computeFlatVertexNormals: function() {
					var e, t, n;
					for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
						var i = (n = this.faces[e]).vertexNormals;
						3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
					}
					this.faces.length > 0 && (this.normalsNeedUpdate = !0)
				},
				computeMorphNormals: function() {
					var e, t, n, i, r;
					for (n = 0, i = this.faces.length; n < i; n++)
						for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
					var a = new fe;
					for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
						if (!this.morphNormals[e]) {
							this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
							var s = this.morphNormals[e].faceNormals,
								c = this.morphNormals[e].vertexNormals;
							for (n = 0, i = this.faces.length; n < i; n++) u = new o, h = {
								a: new o,
								b: new o,
								c: new o
							}, s.push(u), c.push(h)
						}
						var l = this.morphNormals[e];
						a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals();
						var u, h;
						for (n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], u = l.faceNormals[n], h = l.vertexNormals[n], u.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2])
					}
					for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
				},
				computeLineDistances: function() {
					for (var e = 0, t = this.vertices, n = 0, i = t.length; n < i; n++) n > 0 && (e += t[n].distanceTo(t[n - 1])), this.lineDistances[n] = e
				},
				computeBoundingBox: function() {
					null === this.boundingBox && (this.boundingBox = new te), this.boundingBox.setFromPoints(this.vertices)
				},
				computeBoundingSphere: function() {
					null === this.boundingSphere && (this.boundingSphere = new ne), this.boundingSphere.setFromPoints(this.vertices)
				},
				merge: function(e, t, n) {
					if (e && e.isGeometry) {
						var i, r = this.vertices.length,
							o = this.vertices,
							s = e.vertices,
							c = this.faces,
							l = e.faces,
							u = this.faceVertexUvs[0],
							h = e.faceVertexUvs[0],
							d = this.colors,
							f = e.colors;
						void 0 === n && (n = 0), void 0 !== t && (i = (new a).getNormalMatrix(t));
						for (var v = 0, p = s.length; v < p; v++) {
							var m = s[v].clone();
							void 0 !== t && m.applyMatrix4(t), o.push(m)
						}
						for (var v = 0, p = f.length; v < p; v++) d.push(f[v].clone());
						for (v = 0, p = l.length; v < p; v++) {
							var g, y, x, b = l[v],
								w = b.vertexNormals,
								M = b.vertexColors;
							(g = new de(b.a + r, b.b + r, b.c + r)).normal.copy(b.normal), void 0 !== i && g.normal.applyMatrix3(i).normalize();
							for (var _ = 0, S = w.length; _ < S; _++) y = w[_].clone(), void 0 !== i && y.applyMatrix3(i).normalize(), g.vertexNormals.push(y);
							g.color.copy(b.color);
							for (var _ = 0, S = M.length; _ < S; _++) x = M[_], g.vertexColors.push(x.clone());
							g.materialIndex = b.materialIndex + n, c.push(g)
						}
						for (v = 0, p = h.length; v < p; v++) {
							var E = h[v],
								T = [];
							if (void 0 !== E) {
								for (var _ = 0, S = E.length; _ < S; _++) T.push(E[_].clone());
								u.push(T)
							}
						}
					} else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
				},
				mergeMesh: function(e) {
					e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
				},
				mergeVertices: function() {
					var e, t, n, i, r, o, a, s, c = {},
						l = [],
						u = [],
						h = Math.pow(10, 4);
					for (n = 0, i = this.vertices.length; n < i; n++) e = this.vertices[n], void 0 === c[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (c[t] = n, l.push(this.vertices[n]), u[n] = l.length - 1) : u[n] = u[c[t]];
					var d = [];
					for (n = 0, i = this.faces.length; n < i; n++) {
						(r = this.faces[n]).a = u[r.a], r.b = u[r.b], r.c = u[r.c], o = [r.a, r.b, r.c];
						for (var f = 0; f < 3; f++)
							if (o[f] === o[(f + 1) % 3]) {
								d.push(n);
								break
							}
					}
					for (n = d.length - 1; n >= 0; n--) {
						var v = d[n];
						for (this.faces.splice(v, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(v, 1)
					}
					var p = this.vertices.length - l.length;
					return this.vertices = l, p
				},
				setFromPoints: function(e) {
					this.vertices = [];
					for (var t = 0, n = e.length; t < n; t++) {
						var i = e[t];
						this.vertices.push(new o(i.x, i.y, i.z || 0))
					}
					return this
				},
				sortFacesByMaterialIndex: function() {
					for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
					e.sort(function(e, t) {
						return e.materialIndex - t.materialIndex
					});
					var i, r, o = this.faceVertexUvs[0],
						a = this.faceVertexUvs[1];
					o && o.length === t && (i = []), a && a.length === t && (r = []);
					for (n = 0; n < t; n++) {
						var s = e[n]._id;
						i && i.push(o[s]), r && r.push(a[s])
					}
					i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
				},
				toJSON: function() {
					function e(e, t, n) {
						return n ? e | 1 << t : e & ~(1 << t)
					}

					function t(e) {
						var t = e.x.toString() + e.y.toString() + e.z.toString();
						return void 0 !== d[t] ? d[t] : (d[t] = h.length / 3, h.push(e.x, e.y, e.z), d[t])
					}

					function n(e) {
						var t = e.r.toString() + e.g.toString() + e.b.toString();
						return void 0 !== v[t] ? v[t] : (v[t] = f.length, f.push(e.getHex()), v[t])
					}

					function i(e) {
						var t = e.x.toString() + e.y.toString();
						return void 0 !== m[t] ? m[t] : (m[t] = p.length / 2, p.push(e.x, e.y), m[t])
					}
					var r = {
						metadata: {
							version: 4.5,
							type: "Geometry",
							generator: "Geometry.toJSON"
						}
					};
					if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
						var o = this.parameters;
						for (var a in o) void 0 !== o[a] && (r[a] = o[a]);
						return r
					}
					for (var s = [], c = 0; c < this.vertices.length; c++) {
						var l = this.vertices[c];
						s.push(l.x, l.y, l.z)
					}
					for (var u = [], h = [], d = {}, f = [], v = {}, p = [], m = {}, c = 0; c < this.faces.length; c++) {
						var g = this.faces[c],
							y = void 0 !== this.faceVertexUvs[0][c],
							x = g.normal.length() > 0,
							b = g.vertexNormals.length > 0,
							w = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
							M = g.vertexColors.length > 0,
							_ = 0;
						if (_ = e(_, 0, 0), _ = e(_, 1, !0), _ = e(_, 2, !1), _ = e(_, 3, y), _ = e(_, 4, x), _ = e(_, 5, b), _ = e(_, 6, w), _ = e(_, 7, M), u.push(_), u.push(g.a, g.b, g.c), u.push(g.materialIndex), y) {
							var S = this.faceVertexUvs[0][c];
							u.push(i(S[0]), i(S[1]), i(S[2]))
						}
						if (x && u.push(t(g.normal)), b) {
							var E = g.vertexNormals;
							u.push(t(E[0]), t(E[1]), t(E[2]))
						}
						if (w && u.push(n(g.color)), M) {
							var T = g.vertexColors;
							u.push(n(T[0]), n(T[1]), n(T[2]))
						}
					}
					return r.data = {}, r.data.vertices = s, r.data.normals = h, f.length > 0 && (r.data.colors = f), p.length > 0 && (r.data.uvs = [p]), r.data.faces = u, r
				},
				clone: function() {
					return (new fe).copy(this)
				},
				copy: function(e) {
					var t, n, i, r, o, a;
					this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
					var s = e.vertices;
					for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
					var c = e.colors;
					for (t = 0, n = c.length; t < n; t++) this.colors.push(c[t].clone());
					var l = e.faces;
					for (t = 0, n = l.length; t < n; t++) this.faces.push(l[t].clone());
					for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
						var u = e.faceVertexUvs[t];
						for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), i = 0, r = u.length; i < r; i++) {
							var h = u[i],
								d = [];
							for (o = 0, a = h.length; o < a; o++) {
								var f = h[o];
								d.push(f.clone())
							}
							this.faceVertexUvs[t].push(d)
						}
					}
					var v = e.morphTargets;
					for (t = 0, n = v.length; t < n; t++) {
						var p = {};
						if (p.name = v[t].name, void 0 !== v[t].vertices)
							for (p.vertices = [], i = 0, r = v[t].vertices.length; i < r; i++) p.vertices.push(v[t].vertices[i].clone());
						if (void 0 !== v[t].normals)
							for (p.normals = [], i = 0, r = v[t].normals.length; i < r; i++) p.normals.push(v[t].normals[i].clone());
						this.morphTargets.push(p)
					}
					var m = e.morphNormals;
					for (t = 0, n = m.length; t < n; t++) {
						var g = {};
						if (void 0 !== m[t].vertexNormals)
							for (g.vertexNormals = [], i = 0, r = m[t].vertexNormals.length; i < r; i++) {
								var y = m[t].vertexNormals[i],
									x = {};
								x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
							}
						if (void 0 !== m[t].faceNormals)
							for (g.faceNormals = [], i = 0, r = m[t].faceNormals.length; i < r; i++) g.faceNormals.push(m[t].faceNormals[i].clone());
						this.morphNormals.push(g)
					}
					var b = e.skinWeights;
					for (t = 0, n = b.length; t < n; t++) this.skinWeights.push(b[t].clone());
					var w = e.skinIndices;
					for (t = 0, n = w.length; t < n; t++) this.skinIndices.push(w[t].clone());
					var M = e.lineDistances;
					for (t = 0, n = M.length; t < n; t++) this.lineDistances.push(M[t]);
					var _ = e.boundingBox;
					null !== _ && (this.boundingBox = _.clone());
					var S = e.boundingSphere;
					return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}), Object.defineProperty(ve.prototype, "needsUpdate", {
				set: function(e) {
					!0 === e && this.version++
				}
			}), Object.assign(ve.prototype, {
				isBufferAttribute: !0,
				setArray: function(e) {
					if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e
				},
				setDynamic: function(e) {
					return this.dynamic = e, this
				},
				copy: function(e) {
					return this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
				},
				copyAt: function(e, t, n) {
					e *= this.itemSize, n *= t.itemSize;
					for (var i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
					return this
				},
				copyArray: function(e) {
					return this.array.set(e), this
				},
				copyColorsArray: function(e) {
					for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
						var o = e[i];
						void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), o = new X), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
					}
					return this
				},
				copyIndicesArray: function(e) {
					for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
						var o = e[i];
						t[n++] = o.a, t[n++] = o.b, t[n++] = o.c
					}
					return this
				},
				copyVector2sArray: function(e) {
					for (var t = this.array, i = 0, r = 0, o = e.length; r < o; r++) {
						var a = e[r];
						void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new n), t[i++] = a.x, t[i++] = a.y
					}
					return this
				},
				copyVector3sArray: function(e) {
					for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
						var a = e[i];
						void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new o), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z
					}
					return this
				},
				copyVector4sArray: function(e) {
					for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
						var o = e[i];
						void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new c), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
					}
					return this
				},
				set: function(e, t) {
					return void 0 === t && (t = 0), this.array.set(e, t), this
				},
				getX: function(e) {
					return this.array[e * this.itemSize]
				},
				setX: function(e, t) {
					return this.array[e * this.itemSize] = t, this
				},
				getY: function(e) {
					return this.array[e * this.itemSize + 1]
				},
				setY: function(e, t) {
					return this.array[e * this.itemSize + 1] = t, this
				},
				getZ: function(e) {
					return this.array[e * this.itemSize + 2]
				},
				setZ: function(e, t) {
					return this.array[e * this.itemSize + 2] = t, this
				},
				getW: function(e) {
					return this.array[e * this.itemSize + 3]
				},
				setW: function(e, t) {
					return this.array[e * this.itemSize + 3] = t, this
				},
				setXY: function(e, t, n) {
					return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
				},
				setXYZ: function(e, t, n, i) {
					return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
				},
				setXYZW: function(e, t, n, i, r) {
					return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
				},
				onUpload: function(e) {
					return this.onUploadCallback = e, this
				},
				clone: function() {
					return new this.constructor(this.array, this.itemSize).copy(this)
				}
			}), pe.prototype = Object.create(ve.prototype), pe.prototype.constructor = pe, me.prototype = Object.create(ve.prototype), me.prototype.constructor = me, ge.prototype = Object.create(ve.prototype), ge.prototype.constructor = ge, ye.prototype = Object.create(ve.prototype), ye.prototype.constructor = ye, xe.prototype = Object.create(ve.prototype), xe.prototype.constructor = xe, be.prototype = Object.create(ve.prototype), be.prototype.constructor = be, we.prototype = Object.create(ve.prototype), we.prototype.constructor = we, Me.prototype = Object.create(ve.prototype), Me.prototype.constructor = Me, _e.prototype = Object.create(ve.prototype), _e.prototype.constructor = _e, Object.assign(Se.prototype, {
				computeGroups: function(e) {
					for (var t, n = [], i = void 0, r = e.faces, o = 0; o < r.length; o++) {
						var a = r[o];
						a.materialIndex !== i && (i = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = {
							start: 3 * o,
							materialIndex: i
						})
					}
					void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
				},
				fromGeometry: function(e) {
					var t, i = e.faces,
						r = e.vertices,
						o = e.faceVertexUvs,
						a = o[0] && o[0].length > 0,
						s = o[1] && o[1].length > 0,
						c = e.morphTargets,
						l = c.length;
					if (l > 0) {
						t = [];
						for (g = 0; g < l; g++) t[g] = [];
						this.morphTargets.position = t
					}
					var u, h = e.morphNormals,
						d = h.length;
					if (d > 0) {
						u = [];
						for (g = 0; g < d; g++) u[g] = [];
						this.morphTargets.normal = u
					}
					for (var f = e.skinIndices, v = e.skinWeights, p = f.length === r.length, m = v.length === r.length, g = 0; g < i.length; g++) {
						var y = i[g];
						this.vertices.push(r[y.a], r[y.b], r[y.c]);
						var x = y.vertexNormals;
						if (3 === x.length) this.normals.push(x[0], x[1], x[2]);
						else {
							var b = y.normal;
							this.normals.push(b, b, b)
						}
						var w = y.vertexColors;
						if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
						else {
							var M = y.color;
							this.colors.push(M, M, M)
						}
						if (!0 === a && (void 0 !== (_ = o[0][g]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new n, new n, new n))), !0 === s) {
							var _ = o[1][g];
							void 0 !== _ ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new n, new n, new n))
						}
						for (E = 0; E < l; E++) {
							var S = c[E].vertices;
							t[E].push(S[y.a], S[y.b], S[y.c])
						}
						for (var E = 0; E < d; E++) {
							var T = h[E].vertexNormals[g];
							u[E].push(T.a, T.b, T.c)
						}
						p && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), m && this.skinWeights.push(v[y.a], v[y.b], v[y.c])
					}
					return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
				}
			});
			var js = 1;
			Te.prototype = Object.assign(Object.create(t.prototype), {
				constructor: Te,
				isBufferGeometry: !0,
				getIndex: function() {
					return this.index
				},
				setIndex: function(e) {
					Array.isArray(e) ? this.index = new(Ee(e) > 65535 ? we : xe)(e, 1) : this.index = e
				},
				addAttribute: function(e, t) {
					return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(t)) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(e, new ve(arguments[1], arguments[2])))
				},
				getAttribute: function(e) {
					return this.attributes[e]
				},
				removeAttribute: function(e) {
					return delete this.attributes[e], this
				},
				addGroup: function(e, t, n) {
					this.groups.push({
						start: e,
						count: t,
						materialIndex: void 0 !== n ? n : 0
					})
				},
				clearGroups: function() {
					this.groups = []
				},
				setDrawRange: function(e, t) {
					this.drawRange.start = e, this.drawRange.count = t
				},
				applyMatrix: function(e) {
					var t = this.attributes.position;
					void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
					var n = this.attributes.normal;
					return void 0 !== n && ((new a).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
				},
				rotateX: function() {
					var e = new i;
					return function(t) {
						return e.makeRotationX(t), this.applyMatrix(e), this
					}
				}(),
				rotateY: function() {
					var e = new i;
					return function(t) {
						return e.makeRotationY(t), this.applyMatrix(e), this
					}
				}(),
				rotateZ: function() {
					var e = new i;
					return function(t) {
						return e.makeRotationZ(t), this.applyMatrix(e), this
					}
				}(),
				translate: function() {
					var e = new i;
					return function(t, n, i) {
						return e.makeTranslation(t, n, i), this.applyMatrix(e), this
					}
				}(),
				scale: function() {
					var e = new i;
					return function(t, n, i) {
						return e.makeScale(t, n, i), this.applyMatrix(e), this
					}
				}(),
				lookAt: function() {
					var e = new le;
					return function(t) {
						e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
					}
				}(),
				center: function() {
					this.computeBoundingBox();
					var e = this.boundingBox.getCenter().negate();
					return this.translate(e.x, e.y, e.z), e
				},
				setFromObject: function(e) {
					var t = e.geometry;
					if (e.isPoints || e.isLine) {
						var n = new Me(3 * t.vertices.length, 3),
							i = new Me(3 * t.colors.length, 3);
						if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
							var r = new Me(t.lineDistances.length, 1);
							this.addAttribute("lineDistance", r.copyArray(t.lineDistances))
						}
						null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
					} else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
					return this
				},
				setFromPoints: function(e) {
					for (var t = [], n = 0, i = e.length; n < i; n++) {
						var r = e[n];
						t.push(r.x, r.y, r.z || 0)
					}
					return this.addAttribute("position", new Me(t, 3)), this
				},
				updateFromObject: function(e) {
					var t = e.geometry;
					if (e.isMesh) {
						var n = t.__directGeometry;
						if (!0 === t.elementsNeedUpdate && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(t);
						n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = n
					}
					var i;
					return !0 === t.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
				},
				fromGeometry: function(e) {
					return e.__directGeometry = (new Se).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
				},
				fromDirectGeometry: function(e) {
					var t = new Float32Array(3 * e.vertices.length);
					if (this.addAttribute("position", new ve(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
						var n = new Float32Array(3 * e.normals.length);
						this.addAttribute("normal", new ve(n, 3).copyVector3sArray(e.normals))
					}
					if (e.colors.length > 0) {
						var i = new Float32Array(3 * e.colors.length);
						this.addAttribute("color", new ve(i, 3).copyColorsArray(e.colors))
					}
					if (e.uvs.length > 0) {
						var r = new Float32Array(2 * e.uvs.length);
						this.addAttribute("uv", new ve(r, 2).copyVector2sArray(e.uvs))
					}
					if (e.uvs2.length > 0) {
						var o = new Float32Array(2 * e.uvs2.length);
						this.addAttribute("uv2", new ve(o, 2).copyVector2sArray(e.uvs2))
					}
					if (e.indices.length > 0) {
						var a = new(Ee(e.indices) > 65535 ? Uint32Array : Uint16Array)(3 * e.indices.length);
						this.setIndex(new ve(a, 1).copyIndicesArray(e.indices))
					}
					this.groups = e.groups;
					for (var s in e.morphTargets) {
						for (var c = [], l = e.morphTargets[s], u = 0, h = l.length; u < h; u++) {
							var d = l[u],
								f = new Me(3 * d.length, 3);
							c.push(f.copyVector3sArray(d))
						}
						this.morphAttributes[s] = c
					}
					if (e.skinIndices.length > 0) {
						var v = new Me(4 * e.skinIndices.length, 4);
						this.addAttribute("skinIndex", v.copyVector4sArray(e.skinIndices))
					}
					if (e.skinWeights.length > 0) {
						var p = new Me(4 * e.skinWeights.length, 4);
						this.addAttribute("skinWeight", p.copyVector4sArray(e.skinWeights))
					}
					return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
				},
				computeBoundingBox: function() {
					null === this.boundingBox && (this.boundingBox = new te);
					var e = this.attributes.position;
					void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
				},
				computeBoundingSphere: function() {
					var e = new te,
						t = new o;
					return function() {
						null === this.boundingSphere && (this.boundingSphere = new ne);
						var n = this.attributes.position;
						if (n) {
							var i = this.boundingSphere.center;
							e.setFromBufferAttribute(n), e.getCenter(i);
							for (var r = 0, o = 0, a = n.count; o < a; o++) t.x = n.getX(o), t.y = n.getY(o), t.z = n.getZ(o), r = Math.max(r, i.distanceToSquared(t));
							this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
						}
					}
				}(),
				computeFaceNormals: function() {},
				computeVertexNormals: function() {
					var e = this.index,
						t = this.attributes,
						n = this.groups;
					if (t.position) {
						var i = t.position.array;
						if (void 0 === t.normal) this.addAttribute("normal", new ve(new Float32Array(i.length), 3));
						else
							for (var r = t.normal.array, a = 0, s = r.length; a < s; a++) r[a] = 0;
						var c, l, u, h = t.normal.array,
							d = new o,
							f = new o,
							v = new o,
							p = new o,
							m = new o;
						if (e) {
							var g = e.array;
							0 === n.length && this.addGroup(0, g.length);
							for (var y = 0, x = n.length; y < x; ++y)
								for (var b = n[y], w = b.start, a = w, s = w + b.count; a < s; a += 3) c = 3 * g[a + 0], l = 3 * g[a + 1], u = 3 * g[a + 2], d.fromArray(i, c), f.fromArray(i, l), v.fromArray(i, u), p.subVectors(v, f), m.subVectors(d, f), p.cross(m), h[c] += p.x, h[c + 1] += p.y, h[c + 2] += p.z, h[l] += p.x, h[l + 1] += p.y, h[l + 2] += p.z, h[u] += p.x, h[u + 1] += p.y, h[u + 2] += p.z
						} else
							for (var a = 0, s = i.length; a < s; a += 9) d.fromArray(i, a), f.fromArray(i, a + 3), v.fromArray(i, a + 6), p.subVectors(v, f), m.subVectors(d, f), p.cross(m), h[a] = p.x, h[a + 1] = p.y, h[a + 2] = p.z, h[a + 3] = p.x, h[a + 4] = p.y, h[a + 5] = p.z, h[a + 6] = p.x, h[a + 7] = p.y, h[a + 8] = p.z;
						this.normalizeNormals(), t.normal.needsUpdate = !0
					}
				},
				merge: function(e, t) {
					if (e && e.isBufferGeometry) {
						void 0 === t && (t = 0);
						var n = this.attributes;
						for (var i in n)
							if (void 0 !== e.attributes[i])
								for (var r = n[i].array, o = e.attributes[i], a = o.array, s = 0, c = o.itemSize * t; s < a.length; s++, c++) r[c] = a[s];
						return this
					}
					console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
				},
				normalizeNormals: function() {
					var e = new o;
					return function() {
						for (var t = this.attributes.normal, n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.normalize(), t.setXYZ(n, e.x, e.y, e.z)
					}
				}(),
				toNonIndexed: function() {
					if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
					var e = new Te,
						t = this.index.array,
						n = this.attributes;
					for (var i in n) {
						for (var r = n[i], o = r.array, a = r.itemSize, s = new o.constructor(t.length * a), c = 0, l = 0, u = 0, h = t.length; u < h; u++) {
							c = t[u] * a;
							for (var d = 0; d < a; d++) s[l++] = o[c++]
						}
						e.addAttribute(i, new ve(s, a))
					}
					return e
				},
				toJSON: function() {
					var e = {
						metadata: {
							version: 4.5,
							type: "BufferGeometry",
							generator: "BufferGeometry.toJSON"
						}
					};
					if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
						var t = this.parameters;
						for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
						return e
					}
					e.data = {
						attributes: {}
					};
					var i = this.index;
					if (null !== i) {
						a = Array.prototype.slice.call(i.array);
						e.data.index = {
							type: i.array.constructor.name,
							array: a
						}
					}
					var r = this.attributes;
					for (var n in r) {
						var o = r[n],
							a = Array.prototype.slice.call(o.array);
						e.data.attributes[n] = {
							itemSize: o.itemSize,
							type: o.array.constructor.name,
							array: a,
							normalized: o.normalized
						}
					}
					var s = this.groups;
					s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
					var c = this.boundingSphere;
					return null !== c && (e.data.boundingSphere = {
						center: c.center.toArray(),
						radius: c.radius
					}), e
				},
				clone: function() {
					return (new Te).copy(this)
				},
				copy: function(e) {
					var t, n, i;
					this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
					var r = e.index;
					null !== r && this.setIndex(r.clone());
					var o = e.attributes;
					for (t in o) {
						var a = o[t];
						this.addAttribute(t, a.clone())
					}
					var s = e.morphAttributes;
					for (t in s) {
						var c = [],
							l = s[t];
						for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
						this.morphAttributes[t] = c
					}
					var u = e.groups;
					for (n = 0, i = u.length; n < i; n++) {
						var h = u[n];
						this.addGroup(h.start, h.count, h.materialIndex)
					}
					var d = e.boundingBox;
					null !== d && (this.boundingBox = d.clone());
					var f = e.boundingSphere;
					return null !== f && (this.boundingSphere = f.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}), (Pe.prototype = Object.create(fe.prototype)).constructor = Pe, Ae.prototype = Object.create(Te.prototype), Ae.prototype.constructor = Ae, (Le.prototype = Object.create(fe.prototype)).constructor = Le, Ce.prototype = Object.create(Te.prototype), Ce.prototype.constructor = Ce, ze.prototype = Object.create(Q.prototype), ze.prototype.constructor = ze, ze.prototype.isMeshBasicMaterial = !0, ze.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
			}, Re.prototype = Object.create(Q.prototype), Re.prototype.constructor = Re, Re.prototype.isShaderMaterial = !0, Re.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = As.clone(e.uniforms), this.defines = e.defines, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
			}, Re.prototype.toJSON = function(e) {
				var t = Q.prototype.toJSON.call(this, e);
				return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
			}, Object.assign(Ie.prototype, {
				set: function(e, t) {
					return this.origin.copy(e), this.direction.copy(t), this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.origin.copy(e.origin), this.direction.copy(e.direction), this
				},
				at: function(e, t) {
					return (t || new o).copy(this.direction).multiplyScalar(e).add(this.origin)
				},
				lookAt: function(e) {
					return this.direction.copy(e).sub(this.origin).normalize(), this
				},
				recast: function() {
					var e = new o;
					return function(t) {
						return this.origin.copy(this.at(t, e)), this
					}
				}(),
				closestPointToPoint: function(e, t) {
					var n = t || new o;
					n.subVectors(e, this.origin);
					var i = n.dot(this.direction);
					return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin)
				},
				distanceToPoint: function(e) {
					return Math.sqrt(this.distanceSqToPoint(e))
				},
				distanceSqToPoint: function() {
					var e = new o;
					return function(t) {
						var n = e.subVectors(t, this.origin).dot(this.direction);
						return n < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(t))
					}
				}(),
				distanceSqToSegment: function() {
					var e = new o,
						t = new o,
						n = new o;
					return function(i, r, o, a) {
						e.copy(i).add(r).multiplyScalar(.5), t.copy(r).sub(i).normalize(), n.copy(this.origin).sub(e);
						var s, c, l, u, h = .5 * i.distanceTo(r),
							d = -this.direction.dot(t),
							f = n.dot(this.direction),
							v = -n.dot(t),
							p = n.lengthSq(),
							m = Math.abs(1 - d * d);
						if (m > 0)
							if (s = d * v - f, c = d * f - v, u = h * m, s >= 0)
								if (c >= -u)
									if (c <= u) {
										var g = 1 / m;
										l = (s *= g) * (s + d * (c *= g) + 2 * f) + c * (d * s + c + 2 * v) + p
									} else c = h, l = -(s = Math.max(0, -(d * c + f))) * s + c * (c + 2 * v) + p;
						else c = -h, l = -(s = Math.max(0, -(d * c + f))) * s + c * (c + 2 * v) + p;
						else c <= -u ? l = -(s = Math.max(0, -(-d * h + f))) * s + (c = s > 0 ? -h : Math.min(Math.max(-h, -v), h)) * (c + 2 * v) + p : c <= u ? (s = 0, l = (c = Math.min(Math.max(-h, -v), h)) * (c + 2 * v) + p) : l = -(s = Math.max(0, -(d * h + f))) * s + (c = s > 0 ? h : Math.min(Math.max(-h, -v), h)) * (c + 2 * v) + p;
						else c = d > 0 ? -h : h, l = -(s = Math.max(0, -(d * c + f))) * s + c * (c + 2 * v) + p;
						return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(t).multiplyScalar(c).add(e), l
					}
				}(),
				intersectSphere: function() {
					var e = new o;
					return function(t, n) {
						e.subVectors(t.center, this.origin);
						var i = e.dot(this.direction),
							r = e.dot(e) - i * i,
							o = t.radius * t.radius;
						if (r > o) return null;
						var a = Math.sqrt(o - r),
							s = i - a,
							c = i + a;
						return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
					}
				}(),
				intersectsSphere: function(e) {
					return this.distanceToPoint(e.center) <= e.radius
				},
				distanceToPlane: function(e) {
					var t = e.normal.dot(this.direction);
					if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
					var n = -(this.origin.dot(e.normal) + e.constant) / t;
					return n >= 0 ? n : null
				},
				intersectPlane: function(e, t) {
					var n = this.distanceToPlane(e);
					return null === n ? null : this.at(n, t)
				},
				intersectsPlane: function(e) {
					var t = e.distanceToPoint(this.origin);
					return 0 === t || e.normal.dot(this.direction) * t < 0
				},
				intersectBox: function(e, t) {
					var n, i, r, o, a, s, c = 1 / this.direction.x,
						l = 1 / this.direction.y,
						u = 1 / this.direction.z,
						h = this.origin;
					return c >= 0 ? (n = (e.min.x - h.x) * c, i = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c, i = (e.min.x - h.x) * c), l >= 0 ? (r = (e.min.y - h.y) * l, o = (e.max.y - h.y) * l) : (r = (e.max.y - h.y) * l, o = (e.min.y - h.y) * l), n > o || r > i ? null : ((r > n || n !== n) && (n = r), (o < i || i !== i) && (i = o), u >= 0 ? (a = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), n > s || a > i ? null : ((a > n || n !== n) && (n = a), (s < i || i !== i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
				},
				intersectsBox: function() {
					var e = new o;
					return function(t) {
						return null !== this.intersectBox(t, e)
					}
				}(),
				intersectTriangle: function() {
					var e = new o,
						t = new o,
						n = new o,
						i = new o;
					return function(r, o, a, s, c) {
						t.subVectors(o, r), n.subVectors(a, r), i.crossVectors(t, n);
						var l, u = this.direction.dot(i);
						if (u > 0) {
							if (s) return null;
							l = 1
						} else {
							if (!(u < 0)) return null;
							l = -1, u = -u
						}
						e.subVectors(this.origin, r);
						var h = l * this.direction.dot(n.crossVectors(e, n));
						if (h < 0) return null;
						var d = l * this.direction.dot(t.cross(e));
						if (d < 0) return null;
						if (h + d > u) return null;
						var f = -l * e.dot(i);
						return f < 0 ? null : this.at(f / u, c)
					}
				}(),
				applyMatrix4: function(e) {
					return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
				},
				equals: function(e) {
					return e.origin.equals(this.origin) && e.direction.equals(this.direction)
				}
			}), Object.assign(je.prototype, {
				set: function(e, t) {
					return this.start.copy(e), this.end.copy(t), this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.start.copy(e.start), this.end.copy(e.end), this
				},
				getCenter: function(e) {
					return (e || new o).addVectors(this.start, this.end).multiplyScalar(.5)
				},
				delta: function(e) {
					return (e || new o).subVectors(this.end, this.start)
				},
				distanceSq: function() {
					return this.start.distanceToSquared(this.end)
				},
				distance: function() {
					return this.start.distanceTo(this.end)
				},
				at: function(e, t) {
					var n = t || new o;
					return this.delta(n).multiplyScalar(e).add(this.start)
				},
				closestPointToPointParameter: function() {
					var e = new o,
						t = new o;
					return function(n, i) {
						e.subVectors(n, this.start), t.subVectors(this.end, this.start);
						var r = t.dot(t),
							o = t.dot(e) / r;
						return i && (o = gs.clamp(o, 0, 1)), o
					}
				}(),
				closestPointToPoint: function(e, t, n) {
					var i = this.closestPointToPointParameter(e, t),
						r = n || new o;
					return this.delta(r).multiplyScalar(i).add(this.start)
				},
				applyMatrix4: function(e) {
					return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
				},
				equals: function(e) {
					return e.start.equals(this.start) && e.end.equals(this.end)
				}
			}), Object.assign(Oe, {
				normal: function() {
					var e = new o;
					return function(t, n, i, r) {
						var a = r || new o;
						a.subVectors(i, n), e.subVectors(t, n), a.cross(e);
						var s = a.lengthSq();
						return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0)
					}
				}(),
				barycoordFromPoint: function() {
					var e = new o,
						t = new o,
						n = new o;
					return function(i, r, a, s, c) {
						e.subVectors(s, r), t.subVectors(a, r), n.subVectors(i, r);
						var l = e.dot(e),
							u = e.dot(t),
							h = e.dot(n),
							d = t.dot(t),
							f = t.dot(n),
							v = l * d - u * u,
							p = c || new o;
						if (0 === v) return p.set(-2, -1, -1);
						var m = 1 / v,
							g = (d * h - u * f) * m,
							y = (l * f - u * h) * m;
						return p.set(1 - g - y, y, g)
					}
				}(),
				containsPoint: function() {
					var e = new o;
					return function(t, n, i, r) {
						var o = Oe.barycoordFromPoint(t, n, i, r, e);
						return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
					}
				}()
			}), Object.assign(Oe.prototype, {
				set: function(e, t, n) {
					return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
				},
				setFromPointsAndIndices: function(e, t, n, i) {
					return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
				},
				area: function() {
					var e = new o,
						t = new o;
					return function() {
						return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
					}
				}(),
				midpoint: function(e) {
					return (e || new o).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
				},
				normal: function(e) {
					return Oe.normal(this.a, this.b, this.c, e)
				},
				plane: function(e) {
					return (e || new ie).setFromCoplanarPoints(this.a, this.b, this.c)
				},
				barycoordFromPoint: function(e, t) {
					return Oe.barycoordFromPoint(e, this.a, this.b, this.c, t)
				},
				containsPoint: function(e) {
					return Oe.containsPoint(e, this.a, this.b, this.c)
				},
				closestPointToPoint: function() {
					var e = new ie,
						t = [new je, new je, new je],
						n = new o,
						i = new o;
					return function(r, a) {
						var s = a || new o,
							c = 1 / 0;
						if (e.setFromCoplanarPoints(this.a, this.b, this.c), e.projectPoint(r, n), !0 === this.containsPoint(n)) s.copy(n);
						else {
							t[0].set(this.a, this.b), t[1].set(this.b, this.c), t[2].set(this.c, this.a);
							for (var l = 0; l < t.length; l++) {
								t[l].closestPointToPoint(n, !0, i);
								var u = n.distanceToSquared(i);
								u < c && (c = u, s.copy(i))
							}
						}
						return s
					}
				}(),
				equals: function(e) {
					return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
				}
			}), De.prototype = Object.assign(Object.create(le.prototype), {
				constructor: De,
				isMesh: !0,
				setDrawMode: function(e) {
					this.drawMode = e
				},
				copy: function(e) {
					return le.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
				},
				updateMorphTargets: function() {
					var e, t, n, i = this.geometry;
					if (i.isBufferGeometry) {
						var r = i.morphAttributes,
							o = Object.keys(r);
						if (o.length > 0) {
							var a = r[o[0]];
							if (void 0 !== a)
								for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
						}
					} else {
						var s = i.morphTargets;
						if (void 0 !== s && s.length > 0)
							for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = s.length; e < t; e++) n = s[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
					}
				},
				raycast: function() {
					function e(e, t, n, i, r, o, a) {
						return Oe.barycoordFromPoint(e, t, n, i, y), r.multiplyScalar(y.x), o.multiplyScalar(y.y), a.multiplyScalar(y.z), r.add(o).add(a), r.clone()
					}

					function t(e, t, n, i, r, o, a, s) {
						if (null === (t.side === _o ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, t.side !== So, s))) return null;
						b.copy(s), b.applyMatrix4(e.matrixWorld);
						var c = n.ray.origin.distanceTo(b);
						return c < n.near || c > n.far ? null : {
							distance: c,
							point: b.clone(),
							object: e
						}
					}

					function r(n, i, r, o, a, s, c, d) {
						l.fromBufferAttribute(o, s), u.fromBufferAttribute(o, c), h.fromBufferAttribute(o, d);
						var f = t(n, n.material, i, r, l, u, h, x);
						return f && (a && (p.fromBufferAttribute(a, s), m.fromBufferAttribute(a, c), g.fromBufferAttribute(a, d), f.uv = e(x, l, u, h, p, m, g)), f.face = new de(s, c, d, Oe.normal(l, u, h)), f.faceIndex = s), f
					}
					var a = new i,
						s = new Ie,
						c = new ne,
						l = new o,
						u = new o,
						h = new o,
						d = new o,
						f = new o,
						v = new o,
						p = new n,
						m = new n,
						g = new n,
						y = new o,
						x = new o,
						b = new o;
					return function(n, i) {
						var o = this.geometry,
							y = this.material,
							b = this.matrixWorld;
						if (void 0 !== y && (null === o.boundingSphere && o.computeBoundingSphere(), c.copy(o.boundingSphere), c.applyMatrix4(b), !1 !== n.ray.intersectsSphere(c) && (a.getInverse(b), s.copy(n.ray).applyMatrix4(a), null === o.boundingBox || !1 !== s.intersectsBox(o.boundingBox)))) {
							var w;
							if (o.isBufferGeometry) {
								var M, _, S, E, T, P = o.index,
									A = o.attributes.position,
									L = o.attributes.uv;
								if (null !== P)
									for (E = 0, T = P.count; E < T; E += 3) M = P.getX(E), _ = P.getX(E + 1), S = P.getX(E + 2), (w = r(this, n, s, A, L, M, _, S)) && (w.faceIndex = Math.floor(E / 3), i.push(w));
								else if (void 0 !== A)
									for (E = 0, T = A.count; E < T; E += 3)(w = r(this, n, s, A, L, M = E, _ = E + 1, S = E + 2)) && (w.index = M, i.push(w))
							} else if (o.isGeometry) {
								var C, z, R, I, j = Array.isArray(y),
									O = o.vertices,
									D = o.faces,
									F = o.faceVertexUvs[0];
								F.length > 0 && (I = F);
								for (var U = 0, k = D.length; U < k; U++) {
									var N = D[U],
										B = j ? y[N.materialIndex] : y;
									if (void 0 !== B) {
										if (C = O[N.a], z = O[N.b], R = O[N.c], !0 === B.morphTargets) {
											var G = o.morphTargets,
												H = this.morphTargetInfluences;
											l.set(0, 0, 0), u.set(0, 0, 0), h.set(0, 0, 0);
											for (var V = 0, W = G.length; V < W; V++) {
												var Y = H[V];
												if (0 !== Y) {
													var X = G[V].vertices;
													l.addScaledVector(d.subVectors(X[N.a], C), Y), u.addScaledVector(f.subVectors(X[N.b], z), Y), h.addScaledVector(v.subVectors(X[N.c], R), Y)
												}
											}
											l.add(C), u.add(z), h.add(R), C = l, z = u, R = h
										}
										if (w = t(this, B, n, s, C, z, R, x)) {
											if (I && I[U]) {
												var q = I[U];
												p.copy(q[0]), m.copy(q[1]), g.copy(q[2]), w.uv = e(x, C, z, R, p, m, g)
											}
											w.face = N, w.faceIndex = U, i.push(w)
										}
									}
								}
							}
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			});
			var Os = 0;
			pt.prototype = Object.assign(Object.create(ue.prototype), {
				constructor: pt,
				isPerspectiveCamera: !0,
				copy: function(e, t) {
					return ue.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
				},
				setFocalLength: function(e) {
					var t = .5 * this.getFilmHeight() / e;
					this.fov = 2 * gs.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
				},
				getFocalLength: function() {
					var e = Math.tan(.5 * gs.DEG2RAD * this.fov);
					return .5 * this.getFilmHeight() / e
				},
				getEffectiveFOV: function() {
					return 2 * gs.RAD2DEG * Math.atan(Math.tan(.5 * gs.DEG2RAD * this.fov) / this.zoom)
				},
				getFilmWidth: function() {
					return this.filmGauge * Math.min(this.aspect, 1)
				},
				getFilmHeight: function() {
					return this.filmGauge / Math.max(this.aspect, 1)
				},
				setViewOffset: function(e, t, n, i, r, o) {
					this.aspect = e / t, null === this.view && (this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
				},
				clearViewOffset: function() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				},
				updateProjectionMatrix: function() {
					var e = this.near,
						t = e * Math.tan(.5 * gs.DEG2RAD * this.fov) / this.zoom,
						n = 2 * t,
						i = this.aspect * n,
						r = -.5 * i,
						o = this.view;
					if (null !== this.view && this.view.enabled) {
						var a = o.fullWidth,
							s = o.fullHeight;
						r += o.offsetX * i / a, t -= o.offsetY * n / s, i *= o.width / a, n *= o.height / s
					}
					var c = this.filmOffset;
					0 !== c && (r += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far)
				},
				toJSON: function(e) {
					var t = le.prototype.toJSON.call(this, e);
					return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
				}
			}), mt.prototype = Object.assign(Object.create(pt.prototype), {
				constructor: mt,
				isArrayCamera: !0
			}), Mt.prototype.isFogExp2 = !0, Mt.prototype.clone = function() {
				return new Mt(this.color.getHex(), this.density)
			}, Mt.prototype.toJSON = function() {
				return {
					type: "FogExp2",
					color: this.color.getHex(),
					density: this.density
				}
			}, _t.prototype.isFog = !0, _t.prototype.clone = function() {
				return new _t(this.color.getHex(), this.near, this.far)
			}, _t.prototype.toJSON = function() {
				return {
					type: "Fog",
					color: this.color.getHex(),
					near: this.near,
					far: this.far
				}
			}, St.prototype = Object.assign(Object.create(le.prototype), {
				constructor: St,
				copy: function(e, t) {
					return le.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
				},
				toJSON: function(e) {
					var t = le.prototype.toJSON.call(this, e);
					return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
				}
			}), Et.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Et,
				isLensFlare: !0,
				copy: function(e) {
					le.prototype.copy.call(this, e), this.positionScreen.copy(e.positionScreen), this.customUpdateCallback = e.customUpdateCallback;
					for (var t = 0, n = e.lensFlares.length; t < n; t++) this.lensFlares.push(e.lensFlares[t]);
					return this
				},
				add: function(e, t, n, i, r, o) {
					void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === o && (o = 1), void 0 === r && (r = new X(16777215)), void 0 === i && (i = Lo), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
						texture: e,
						size: t,
						distance: n,
						x: 0,
						y: 0,
						z: 0,
						scale: 1,
						rotation: 0,
						opacity: o,
						color: r,
						blending: i
					})
				},
				updateLensFlares: function() {
					var e, t, n = this.lensFlares.length,
						i = 2 * -this.positionScreen.x,
						r = 2 * -this.positionScreen.y;
					for (e = 0; e < n; e++)(t = this.lensFlares[e]).x = this.positionScreen.x + i * t.distance, t.y = this.positionScreen.y + r * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
				}
			}), Tt.prototype = Object.create(Q.prototype), Tt.prototype.constructor = Tt, Tt.prototype.isSpriteMaterial = !0, Tt.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this
			}, Pt.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Pt,
				isSprite: !0,
				raycast: function() {
					var e = new o,
						t = new o,
						n = new o;
					return function(i, r) {
						t.setFromMatrixPosition(this.matrixWorld), i.ray.closestPointToPoint(t, e), n.setFromMatrixScale(this.matrixWorld);
						var o = n.x * n.y / 4;
						if (!(t.distanceToSquared(e) > o)) {
							var a = i.ray.origin.distanceTo(e);
							a < i.near || a > i.far || r.push({
								distance: a,
								point: e.clone(),
								face: null,
								object: this
							})
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.material).copy(this)
				}
			}), At.prototype = Object.assign(Object.create(le.prototype), {
				constructor: At,
				copy: function(e) {
					le.prototype.copy.call(this, e, !1);
					for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
						var r = t[n];
						this.addLevel(r.object.clone(), r.distance)
					}
					return this
				},
				addLevel: function(e, t) {
					void 0 === t && (t = 0), t = Math.abs(t);
					for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++);
					n.splice(i, 0, {
						distance: t,
						object: e
					}), this.add(e)
				},
				getObjectForDistance: function(e) {
					for (var t = this.levels, n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
					return t[n - 1].object
				},
				raycast: function() {
					var e = new o;
					return function(t, n) {
						e.setFromMatrixPosition(this.matrixWorld);
						var i = t.ray.origin.distanceTo(e);
						this.getObjectForDistance(i).raycast(t, n)
					}
				}(),
				update: function() {
					var e = new o,
						t = new o;
					return function(n) {
						var i = this.levels;
						if (i.length > 1) {
							e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
							var r = e.distanceTo(t);
							i[0].object.visible = !0;
							for (var o = 1, a = i.length; o < a && r >= i[o].distance; o++) i[o - 1].object.visible = !1, i[o].object.visible = !0;
							for (; o < a; o++) i[o].object.visible = !1
						}
					}
				}(),
				toJSON: function(e) {
					var t = le.prototype.toJSON.call(this, e);
					t.object.levels = [];
					for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
						var o = n[i];
						t.object.levels.push({
							object: o.object.uuid,
							distance: o.distance
						})
					}
					return t
				}
			}), Object.assign(Lt.prototype, {
				calculateInverses: function() {
					this.boneInverses = [];
					for (var e = 0, t = this.bones.length; e < t; e++) {
						var n = new i;
						this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
					}
				},
				pose: function() {
					var e, t, n;
					for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
					for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
				},
				update: function() {
					var e = new i,
						t = new i;
					return function() {
						for (var n = this.bones, i = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
							var c = n[a] ? n[a].matrixWorld : t;
							e.multiplyMatrices(c, i[a]), e.toArray(r, 16 * a)
						}
						void 0 !== o && (o.needsUpdate = !0)
					}
				}(),
				clone: function() {
					return new Lt(this.bones, this.boneInverses)
				}
			}), Ct.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Ct,
				isBone: !0
			}), zt.prototype = Object.assign(Object.create(De.prototype), {
				constructor: zt,
				isSkinnedMesh: !0,
				initBones: function() {
					var e, t, n, i, r = [];
					if (this.geometry && void 0 !== this.geometry.bones) {
						for (n = 0, i = this.geometry.bones.length; n < i; n++) t = this.geometry.bones[n], e = new Ct, r.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl);
						for (n = 0, i = this.geometry.bones.length; n < i; n++) - 1 !== (t = this.geometry.bones[n]).parent && null !== t.parent && void 0 !== r[t.parent] ? r[t.parent].add(r[n]) : this.add(r[n])
					}
					return this.updateMatrixWorld(!0), r
				},
				bind: function(e, t) {
					this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
				},
				pose: function() {
					this.skeleton.pose()
				},
				normalizeSkinWeights: function() {
					var e, t;
					if (this.geometry && this.geometry.isGeometry)
						for (t = 0; t < this.geometry.skinWeights.length; t++) {
							var n = this.geometry.skinWeights[t];
							(e = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0)
						} else if (this.geometry && this.geometry.isBufferGeometry) {
							var i = new c,
								r = this.geometry.attributes.skinWeight;
							for (t = 0; t < r.count; t++) i.x = r.getX(t), i.y = r.getY(t), i.z = r.getZ(t), i.w = r.getW(t), (e = 1 / i.manhattanLength()) !== 1 / 0 ? i.multiplyScalar(e) : i.set(1, 0, 0, 0), r.setXYZW(t, i.x, i.y, i.z, i.w)
						}
				},
				updateMatrixWorld: function(e) {
					De.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
				},
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}), Rt.prototype = Object.create(Q.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isLineBasicMaterial = !0, Rt.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
			}, It.prototype = Object.assign(Object.create(le.prototype), {
				constructor: It,
				isLine: !0,
				raycast: function() {
					var e = new i,
						t = new Ie,
						n = new ne;
					return function(i, r) {
						var a = i.linePrecision,
							s = a * a,
							c = this.geometry,
							l = this.matrixWorld;
						if (null === c.boundingSphere && c.computeBoundingSphere(), n.copy(c.boundingSphere), n.applyMatrix4(l), !1 !== i.ray.intersectsSphere(n)) {
							e.getInverse(l), t.copy(i.ray).applyMatrix4(e);
							var u = new o,
								h = new o,
								d = new o,
								f = new o,
								v = this && this.isLineSegments ? 2 : 1;
							if (c.isBufferGeometry) {
								var p = c.index,
									m = c.attributes.position.array;
								if (null !== p)
									for (var g = p.array, y = 0, x = g.length - 1; y < x; y += v) {
										var b = g[y],
											w = g[y + 1];
										u.fromArray(m, 3 * b), h.fromArray(m, 3 * w), (S = t.distanceSqToSegment(u, h, f, d)) > s || (f.applyMatrix4(this.matrixWorld), (E = i.ray.origin.distanceTo(f)) < i.near || E > i.far || r.push({
											distance: E,
											point: d.clone().applyMatrix4(this.matrixWorld),
											index: y,
											face: null,
											faceIndex: null,
											object: this
										}))
									} else
										for (var y = 0, x = m.length / 3 - 1; y < x; y += v) u.fromArray(m, 3 * y), h.fromArray(m, 3 * y + 3), (S = t.distanceSqToSegment(u, h, f, d)) > s || (f.applyMatrix4(this.matrixWorld), (E = i.ray.origin.distanceTo(f)) < i.near || E > i.far || r.push({
											distance: E,
											point: d.clone().applyMatrix4(this.matrixWorld),
											index: y,
											face: null,
											faceIndex: null,
											object: this
										}))
							} else if (c.isGeometry)
								for (var M = c.vertices, _ = M.length, y = 0; y < _ - 1; y += v) {
									var S = t.distanceSqToSegment(M[y], M[y + 1], f, d);
									if (!(S > s)) {
										f.applyMatrix4(this.matrixWorld);
										var E = i.ray.origin.distanceTo(f);
										E < i.near || E > i.far || r.push({
											distance: E,
											point: d.clone().applyMatrix4(this.matrixWorld),
											index: y,
											face: null,
											faceIndex: null,
											object: this
										})
									}
								}
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}), jt.prototype = Object.assign(Object.create(It.prototype), {
				constructor: jt,
				isLineSegments: !0
			}), Ot.prototype = Object.assign(Object.create(It.prototype), {
				constructor: Ot,
				isLineLoop: !0
			}), Dt.prototype = Object.create(Q.prototype), Dt.prototype.constructor = Dt, Dt.prototype.isPointsMaterial = !0, Dt.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
			}, Ft.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Ft,
				isPoints: !0,
				raycast: function() {
					var e = new i,
						t = new Ie,
						n = new ne;
					return function(i, r) {
						function a(e, n) {
							var o = t.distanceSqToPoint(e);
							if (o < d) {
								var a = t.closestPointToPoint(e);
								a.applyMatrix4(l);
								var c = i.ray.origin.distanceTo(a);
								if (c < i.near || c > i.far) return;
								r.push({
									distance: c,
									distanceToRay: Math.sqrt(o),
									point: a.clone(),
									index: n,
									face: null,
									object: s
								})
							}
						}
						var s = this,
							c = this.geometry,
							l = this.matrixWorld,
							u = i.params.Points.threshold;
						if (null === c.boundingSphere && c.computeBoundingSphere(), n.copy(c.boundingSphere), n.applyMatrix4(l), n.radius += u, !1 !== i.ray.intersectsSphere(n)) {
							e.getInverse(l), t.copy(i.ray).applyMatrix4(e);
							var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
								d = h * h,
								f = new o;
							if (c.isBufferGeometry) {
								var v = c.index,
									p = c.attributes.position.array;
								if (null !== v)
									for (var m = v.array, g = 0, y = m.length; g < y; g++) {
										var x = m[g];
										f.fromArray(p, 3 * x), a(f, x)
									} else
										for (var g = 0, b = p.length / 3; g < b; g++) f.fromArray(p, 3 * g), a(f, g)
							} else
								for (var w = c.vertices, g = 0, b = w.length; g < b; g++) a(w[g], g)
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}), Ut.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Ut,
				isGroup: !0
			}), kt.prototype = Object.assign(Object.create(s.prototype), {
				constructor: kt,
				isVideoTexture: !0,
				update: function() {
					var e = this.image;
					e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
				}
			}), (Nt.prototype = Object.create(s.prototype)).constructor = Nt, Nt.prototype.isCompressedTexture = !0, (Bt.prototype = Object.create(s.prototype)).constructor = Bt, Bt.prototype.isDepthTexture = !0, Gt.prototype = Object.create(Te.prototype), Gt.prototype.constructor = Gt, (Ht.prototype = Object.create(fe.prototype)).constructor = Ht, (Vt.prototype = Object.create(Te.prototype)).constructor = Vt, (Wt.prototype = Object.create(fe.prototype)).constructor = Wt, Yt.prototype = Object.create(Te.prototype), Yt.prototype.constructor = Yt, (Xt.prototype = Object.create(fe.prototype)).constructor = Xt, (qt.prototype = Object.create(Yt.prototype)).constructor = qt, (Zt.prototype = Object.create(fe.prototype)).constructor = Zt, Kt.prototype = Object.create(Yt.prototype), Kt.prototype.constructor = Kt, (Jt.prototype = Object.create(fe.prototype)).constructor = Jt, (Qt.prototype = Object.create(Yt.prototype)).constructor = Qt, ($t.prototype = Object.create(fe.prototype)).constructor = $t, (en.prototype = Object.create(Yt.prototype)).constructor = en, (tn.prototype = Object.create(fe.prototype)).constructor = tn, (nn.prototype = Object.create(Te.prototype)).constructor = nn, (rn.prototype = Object.create(fe.prototype)).constructor = rn, (on.prototype = Object.create(Te.prototype)).constructor = on, (an.prototype = Object.create(fe.prototype)).constructor = an, (sn.prototype = Object.create(Te.prototype)).constructor = sn;
			var Ds = {
					triangulate: function(e, t, n) {
						n = n || 2;
						var i = t && t.length,
							r = i ? t[0] * n : e.length,
							o = cn(e, 0, r, n, !0),
							a = [];
						if (!o) return a;
						var s, c, l, u, h, d, f;
						if (i && (o = pn(e, t, o, n)), e.length > 80 * n) {
							s = l = e[0], c = u = e[1];
							for (var v = n; v < r; v += n) h = e[v], d = e[v + 1], h < s && (s = h), d < c && (c = d), h > l && (l = h), d > u && (u = d);
							f = 0 !== (f = Math.max(l - s, u - c)) ? 1 / f : 0
						}
						return un(o, a, n, s, c, f), a
					}
				},
				Fs = {
					area: function(e) {
						for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
						return .5 * n
					},
					isClockWise: function(e) {
						return Fs.area(e) < 0
					},
					triangulateShape: function(e, t) {
						function n(e) {
							var t = e.length;
							t > 2 && e[t - 1].equals(e[0]) && e.pop()
						}

						function i(e, t) {
							for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
						}
						var r = [],
							o = [],
							a = [];
						n(e), i(r, e);
						var s = e.length;
						for (t.forEach(n), l = 0; l < t.length; l++) o.push(s), s += t[l].length, i(r, t[l]);
						for (var c = Ds.triangulate(r, o), l = 0; l < c.length; l += 3) a.push(c.slice(l, l + 3));
						return a
					}
				};
			(Dn.prototype = Object.create(fe.prototype)).constructor = Dn, Fn.prototype = Object.create(Te.prototype), Fn.prototype.constructor = Fn, Fn.prototype.getArrays = function() {
				var e = this.getAttribute("position"),
					t = e ? Array.prototype.slice.call(e.array) : [],
					n = this.getAttribute("uv"),
					i = n ? Array.prototype.slice.call(n.array) : [],
					r = this.index;
				return {
					position: t,
					uv: i,
					index: r ? Array.prototype.slice.call(r.array) : []
				}
			}, Fn.prototype.addShapeList = function(e, t) {
				var n = e.length;
				t.arrays = this.getArrays();
				for (var i = 0; i < n; i++) {
					var r = e[i];
					this.addShape(r, t)
				}
				this.setIndex(t.arrays.index), this.addAttribute("position", new Me(t.arrays.position, 3)), this.addAttribute("uv", new Me(t.arrays.uv, 2))
			}, Fn.prototype.addShape = function(e, t) {
				function i(e, t, n) {
					return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
				}

				function r(e, t, i) {
					var r, o, a, s = e.x - t.x,
						c = e.y - t.y,
						l = i.x - e.x,
						u = i.y - e.y,
						h = s * s + c * c,
						d = s * u - c * l;
					if (Math.abs(d) > Number.EPSILON) {
						var f = Math.sqrt(h),
							v = Math.sqrt(l * l + u * u),
							p = t.x - c / f,
							m = t.y + s / f,
							g = ((i.x - u / v - p) * u - (i.y + l / v - m) * l) / (s * u - c * l),
							y = (r = p + s * g - e.x) * r + (o = m + c * g - e.y) * o;
						if (y <= 2) return new n(r, o);
						a = Math.sqrt(y / 2)
					} else {
						var x = !1;
						s > Number.EPSILON ? l > Number.EPSILON && (x = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (x = !0) : Math.sign(c) === Math.sign(u) && (x = !0), x ? (r = -c, o = s, a = Math.sqrt(h)) : (r = s, o = c, a = Math.sqrt(h / 2))
					}
					return new n(r / a, o / a)
				}

				function a(e, t) {
					var n, i;
					for (K = e.length; --K >= 0;) {
						n = K, (i = K - 1) < 0 && (i = e.length - 1);
						var r = 0,
							o = A + 2 * E;
						for (r = 0; r < o; r++) {
							var a = X * r,
								s = X * (r + 1);
							l(t + n + a, t + i + a, t + i + s, t + n + s)
						}
					}
				}

				function s(e, t, n) {
					w.push(e), w.push(t), w.push(n)
				}

				function c(e, t, n) {
					u(e), u(t), u(n);
					var i = y.length / 3,
						r = z.generateTopUV(O, y, i - 3, i - 2, i - 1);
					h(r[0]), h(r[1]), h(r[2])
				}

				function l(e, t, n, i) {
					u(e), u(t), u(i), u(t), u(n), u(i);
					var r = y.length / 3,
						o = z.generateSideWallUV(O, y, r - 6, r - 3, r - 2, r - 1);
					h(o[0]), h(o[1]), h(o[3]), h(o[1]), h(o[2]), h(o[3])
				}

				function u(e) {
					x.push(y.length / 3), y.push(w[3 * e + 0]), y.push(w[3 * e + 1]), y.push(w[3 * e + 2])
				}

				function h(e) {
					b.push(e.x), b.push(e.y)
				}
				var d, f, v, p, m, g = t.arrays ? t.arrays : this.getArrays(),
					y = g.position,
					x = g.index,
					b = g.uv,
					w = [],
					M = void 0 !== t.amount ? t.amount : 100,
					_ = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
					S = void 0 !== t.bevelSize ? t.bevelSize : _ - 2,
					E = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
					T = void 0 === t.bevelEnabled || t.bevelEnabled,
					P = void 0 !== t.curveSegments ? t.curveSegments : 12,
					A = void 0 !== t.steps ? t.steps : 1,
					L = t.extrudePath,
					C = !1,
					z = void 0 !== t.UVGenerator ? t.UVGenerator : Dn.WorldUVGenerator;
				L && (d = L.getSpacedPoints(A), C = !0, T = !1, f = void 0 !== t.frames ? t.frames : L.computeFrenetFrames(A, !1), v = new o, p = new o, m = new o), T || (E = 0, _ = 0, S = 0);
				var R, I, j, O = this,
					D = e.extractPoints(P),
					F = D.shape,
					U = D.holes;
				if (!Fs.isClockWise(F))
					for (F = F.reverse(), I = 0, j = U.length; I < j; I++) R = U[I], Fs.isClockWise(R) && (U[I] = R.reverse());
				var k = Fs.triangulateShape(F, U),
					N = F;
				for (I = 0, j = U.length; I < j; I++) R = U[I], F = F.concat(R);
				for (var B, G, H, V, W, Y, X = F.length, q = k.length, Z = [], K = 0, J = N.length, Q = J - 1, $ = K + 1; K < J; K++, Q++, $++) Q === J && (Q = 0), $ === J && ($ = 0), Z[K] = r(N[K], N[Q], N[$]);
				var ee, te = [],
					ne = Z.concat();
				for (I = 0, j = U.length; I < j; I++) {
					for (R = U[I], ee = [], K = 0, Q = (J = R.length) - 1, $ = K + 1; K < J; K++, Q++, $++) Q === J && (Q = 0), $ === J && ($ = 0), ee[K] = r(R[K], R[Q], R[$]);
					te.push(ee), ne = ne.concat(ee)
				}
				for (B = 0; B < E; B++) {
					for (H = B / E, V = _ * Math.cos(H * Math.PI / 2), G = S * Math.sin(H * Math.PI / 2), K = 0, J = N.length; K < J; K++) s((W = i(N[K], Z[K], G)).x, W.y, -V);
					for (I = 0, j = U.length; I < j; I++)
						for (R = U[I], ee = te[I], K = 0, J = R.length; K < J; K++) s((W = i(R[K], ee[K], G)).x, W.y, -V)
				}
				for (G = S, K = 0; K < X; K++) W = T ? i(F[K], ne[K], G) : F[K], C ? (p.copy(f.normals[0]).multiplyScalar(W.x), v.copy(f.binormals[0]).multiplyScalar(W.y), m.copy(d[0]).add(p).add(v), s(m.x, m.y, m.z)) : s(W.x, W.y, 0);
				var ie;
				for (ie = 1; ie <= A; ie++)
					for (K = 0; K < X; K++) W = T ? i(F[K], ne[K], G) : F[K], C ? (p.copy(f.normals[ie]).multiplyScalar(W.x), v.copy(f.binormals[ie]).multiplyScalar(W.y), m.copy(d[ie]).add(p).add(v), s(m.x, m.y, m.z)) : s(W.x, W.y, M / A * ie);
				for (B = E - 1; B >= 0; B--) {
					for (H = B / E, V = _ * Math.cos(H * Math.PI / 2), G = S * Math.sin(H * Math.PI / 2), K = 0, J = N.length; K < J; K++) s((W = i(N[K], Z[K], G)).x, W.y, M + V);
					for (I = 0, j = U.length; I < j; I++)
						for (R = U[I], ee = te[I], K = 0, J = R.length; K < J; K++) W = i(R[K], ee[K], G), C ? s(W.x, W.y + d[A - 1].y, d[A - 1].x + V) : s(W.x, W.y, M + V)
				}! function() {
					var e = y.length / 3;
					if (T) {
						var n = 0,
							i = X * n;
						for (K = 0; K < q; K++) c((Y = k[K])[2] + i, Y[1] + i, Y[0] + i);
						for (i = X * (n = A + 2 * E), K = 0; K < q; K++) c((Y = k[K])[0] + i, Y[1] + i, Y[2] + i)
					} else {
						for (K = 0; K < q; K++) c((Y = k[K])[2], Y[1], Y[0]);
						for (K = 0; K < q; K++) c((Y = k[K])[0] + X * A, Y[1] + X * A, Y[2] + X * A)
					}
					O.addGroup(e, y.length / 3 - e, void 0 !== t.material ? t.material : 0)
				}(),
				function() {
					var e = y.length / 3,
						n = 0;
					for (a(N, n), n += N.length, I = 0, j = U.length; I < j; I++) a(R = U[I], n), n += R.length;
					O.addGroup(e, y.length / 3 - e, void 0 !== t.extrudeMaterial ? t.extrudeMaterial : 1)
				}(), t.arrays || (this.setIndex(x), this.addAttribute("position", new Me(y, 3)), this.addAttribute("uv", new Me(b, 2)))
			}, Dn.WorldUVGenerator = {
				generateTopUV: function(e, t, i, r, o) {
					var a = t[3 * i],
						s = t[3 * i + 1],
						c = t[3 * r],
						l = t[3 * r + 1],
						u = t[3 * o],
						h = t[3 * o + 1];
					return [new n(a, s), new n(c, l), new n(u, h)]
				},
				generateSideWallUV: function(e, t, i, r, o, a) {
					var s = t[3 * i],
						c = t[3 * i + 1],
						l = t[3 * i + 2],
						u = t[3 * r],
						h = t[3 * r + 1],
						d = t[3 * r + 2],
						f = t[3 * o],
						v = t[3 * o + 1],
						p = t[3 * o + 2],
						m = t[3 * a],
						g = t[3 * a + 1],
						y = t[3 * a + 2];
					return Math.abs(c - h) < .01 ? [new n(s, 1 - l), new n(u, 1 - d), new n(f, 1 - p), new n(m, 1 - y)] : [new n(c, 1 - l), new n(h, 1 - d), new n(v, 1 - p), new n(g, 1 - y)]
				}
			}, (Un.prototype = Object.create(fe.prototype)).constructor = Un, (kn.prototype = Object.create(Fn.prototype)).constructor = kn, (Nn.prototype = Object.create(fe.prototype)).constructor = Nn, Bn.prototype = Object.create(Te.prototype), Bn.prototype.constructor = Bn, (Gn.prototype = Object.create(fe.prototype)).constructor = Gn, (Hn.prototype = Object.create(Te.prototype)).constructor = Hn, (Vn.prototype = Object.create(fe.prototype)).constructor = Vn, (Wn.prototype = Object.create(Te.prototype)).constructor = Wn, (Yn.prototype = Object.create(fe.prototype)).constructor = Yn, Yn.prototype.toJSON = function() {
				var e = fe.prototype.toJSON.call(this);
				return qn(this.parameters.shapes, e)
			}, (Xn.prototype = Object.create(Te.prototype)).constructor = Xn, Xn.prototype.toJSON = function() {
				var e = Te.prototype.toJSON.call(this);
				return qn(this.parameters.shapes, e)
			}, Zn.prototype = Object.create(Te.prototype), Zn.prototype.constructor = Zn, Kn.prototype = Object.create(fe.prototype), Kn.prototype.constructor = Kn, Jn.prototype = Object.create(Te.prototype), Jn.prototype.constructor = Jn, (Qn.prototype = Object.create(Kn.prototype)).constructor = Qn, ($n.prototype = Object.create(Jn.prototype)).constructor = $n, (ei.prototype = Object.create(fe.prototype)).constructor = ei, (ti.prototype = Object.create(Te.prototype)).constructor = ti;
			var Us = Object.freeze({
				WireframeGeometry: Gt,
				ParametricGeometry: Ht,
				ParametricBufferGeometry: Vt,
				TetrahedronGeometry: Xt,
				TetrahedronBufferGeometry: qt,
				OctahedronGeometry: Zt,
				OctahedronBufferGeometry: Kt,
				IcosahedronGeometry: Jt,
				IcosahedronBufferGeometry: Qt,
				DodecahedronGeometry: $t,
				DodecahedronBufferGeometry: en,
				PolyhedronGeometry: Wt,
				PolyhedronBufferGeometry: Yt,
				TubeGeometry: tn,
				TubeBufferGeometry: nn,
				TorusKnotGeometry: rn,
				TorusKnotBufferGeometry: on,
				TorusGeometry: an,
				TorusBufferGeometry: sn,
				TextGeometry: Un,
				TextBufferGeometry: kn,
				SphereGeometry: Nn,
				SphereBufferGeometry: Bn,
				RingGeometry: Gn,
				RingBufferGeometry: Hn,
				PlaneGeometry: Le,
				PlaneBufferGeometry: Ce,
				LatheGeometry: Vn,
				LatheBufferGeometry: Wn,
				ShapeGeometry: Yn,
				ShapeBufferGeometry: Xn,
				ExtrudeGeometry: Dn,
				ExtrudeBufferGeometry: Fn,
				EdgesGeometry: Zn,
				ConeGeometry: Qn,
				ConeBufferGeometry: $n,
				CylinderGeometry: Kn,
				CylinderBufferGeometry: Jn,
				CircleGeometry: ei,
				CircleBufferGeometry: ti,
				BoxGeometry: Pe,
				BoxBufferGeometry: Ae
			});
			(ni.prototype = Object.create(Q.prototype)).constructor = ni, ni.prototype.isShadowMaterial = !0, (ii.prototype = Object.create(Re.prototype)).constructor = ii, ii.prototype.isRawShaderMaterial = !0, ri.prototype = Object.create(Q.prototype), ri.prototype.constructor = ri, ri.prototype.isMeshStandardMaterial = !0, ri.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.defines = {
					STANDARD: ""
				}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
			}, (oi.prototype = Object.create(ri.prototype)).constructor = oi, oi.prototype.isMeshPhysicalMaterial = !0, oi.prototype.copy = function(e) {
				return ri.prototype.copy.call(this, e), this.defines = {
					PHYSICAL: ""
				}, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
			}, ai.prototype = Object.create(Q.prototype), ai.prototype.constructor = ai, ai.prototype.isMeshPhongMaterial = !0, ai.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
			}, (si.prototype = Object.create(ai.prototype)).constructor = si, si.prototype.isMeshToonMaterial = !0, si.prototype.copy = function(e) {
				return ai.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
			}, (ci.prototype = Object.create(Q.prototype)).constructor = ci, ci.prototype.isMeshNormalMaterial = !0, ci.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
			}, (li.prototype = Object.create(Q.prototype)).constructor = li, li.prototype.isMeshLambertMaterial = !0, li.prototype.copy = function(e) {
				return Q.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
			}, (ui.prototype = Object.create(Rt.prototype)).constructor = ui, ui.prototype.isLineDashedMaterial = !0, ui.prototype.copy = function(e) {
				return Rt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
			};
			var ks = Object.freeze({
					ShadowMaterial: ni,
					SpriteMaterial: Tt,
					RawShaderMaterial: ii,
					ShaderMaterial: Re,
					PointsMaterial: Dt,
					MeshPhysicalMaterial: oi,
					MeshStandardMaterial: ri,
					MeshPhongMaterial: ai,
					MeshToonMaterial: si,
					MeshNormalMaterial: ci,
					MeshLambertMaterial: li,
					MeshDepthMaterial: $,
					MeshDistanceMaterial: ee,
					MeshBasicMaterial: ze,
					LineDashedMaterial: ui,
					LineBasicMaterial: Rt,
					Material: Q
				}),
				Ns = {
					enabled: !1,
					files: {},
					add: function(e, t) {
						!1 !== this.enabled && (this.files[e] = t)
					},
					get: function(e) {
						if (!1 !== this.enabled) return this.files[e]
					},
					remove: function(e) {
						delete this.files[e]
					},
					clear: function() {
						this.files = {}
					}
				},
				Bs = new hi,
				Gs = {};
			Object.assign(di.prototype, {
				load: function(e, t, n, i) {
					void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
					var r = this,
						o = Ns.get(e);
					if (void 0 !== o) return r.manager.itemStart(e), setTimeout(function() {
						t && t(o), r.manager.itemEnd(e)
					}, 0), o;
					if (void 0 === Gs[e]) {
						var a = /^data:(.*?)(;base64)?,(.*)$/,
							s = e.match(a);
						if (s) {
							var c = s[1],
								l = !!s[2],
								u = s[3];
							u = window.decodeURIComponent(u), l && (u = window.atob(u));
							try {
								var h, d = (this.responseType || "").toLowerCase();
								switch (d) {
									case "arraybuffer":
									case "blob":
										for (var f = new Uint8Array(u.length), v = 0; v < u.length; v++) f[v] = u.charCodeAt(v);
										h = "blob" === d ? new Blob([f.buffer], {
											type: c
										}) : f.buffer;
										break;
									case "document":
										var p = new DOMParser;
										h = p.parseFromString(u, c);
										break;
									case "json":
										h = JSON.parse(u);
										break;
									default:
										h = u
								}
								window.setTimeout(function() {
									t && t(h), r.manager.itemEnd(e)
								}, 0)
							} catch (t) {
								window.setTimeout(function() {
									i && i(t), r.manager.itemEnd(e), r.manager.itemError(e)
								}, 0)
							}
						} else {
							Gs[e] = [], Gs[e].push({
								onLoad: t,
								onProgress: n,
								onError: i
							});
							var m = new XMLHttpRequest;
							m.open("GET", e, !0), m.addEventListener("load", function(t) {
								var n = this.response;
								Ns.add(e, n);
								var i = Gs[e];
								if (delete Gs[e], 200 === this.status) {
									for (var o = 0, a = i.length; o < a; o++)(s = i[o]).onLoad && s.onLoad(n);
									r.manager.itemEnd(e)
								} else if (0 === this.status) {
									console.warn("THREE.FileLoader: HTTP Status 0 received.");
									for (var o = 0, a = i.length; o < a; o++)(s = i[o]).onLoad && s.onLoad(n);
									r.manager.itemEnd(e)
								} else {
									for (var o = 0, a = i.length; o < a; o++) {
										var s = i[o];
										s.onError && s.onError(t)
									}
									r.manager.itemEnd(e), r.manager.itemError(e)
								}
							}, !1), m.addEventListener("progress", function(t) {
								for (var n = Gs[e], i = 0, r = n.length; i < r; i++) {
									var o = n[i];
									o.onProgress && o.onProgress(t)
								}
							}, !1), m.addEventListener("error", function(t) {
								var n = Gs[e];
								delete Gs[e];
								for (var i = 0, o = n.length; i < o; i++) {
									var a = n[i];
									a.onError && a.onError(t)
								}
								r.manager.itemEnd(e), r.manager.itemError(e)
							}, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
							for (var g in this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
							m.send(null)
						}
						return r.manager.itemStart(e), m
					}
					Gs[e].push({
						onLoad: t,
						onProgress: n,
						onError: i
					})
				},
				setPath: function(e) {
					return this.path = e, this
				},
				setResponseType: function(e) {
					return this.responseType = e, this
				},
				setWithCredentials: function(e) {
					return this.withCredentials = e, this
				},
				setMimeType: function(e) {
					return this.mimeType = e, this
				},
				setRequestHeader: function(e) {
					return this.requestHeader = e, this
				}
			}), Object.assign(fi.prototype, {
				load: function(e, t, n, i) {
					var r = this,
						o = [],
						a = new Nt;
					a.image = o;
					var s = new di(this.manager);
					if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(e))
						for (var c = 0, l = 0, u = e.length; l < u; ++l) ! function(l) {
							s.load(e[l], function(e) {
								var n = r._parser(e, !0);
								o[l] = {
									width: n.width,
									height: n.height,
									format: n.format,
									mipmaps: n.mipmaps
								}, 6 === (c += 1) && (1 === n.mipmapCount && (a.minFilter = Ea), a.format = n.format, a.needsUpdate = !0, t && t(a))
							}, n, i)
						}(l);
					else s.load(e, function(e) {
						var n = r._parser(e, !0);
						if (n.isCubemap)
							for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
								o[s] = {
									mipmaps: []
								};
								for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
							} else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
						1 === n.mipmapCount && (a.minFilter = Ea), a.format = n.format, a.needsUpdate = !0, t && t(a)
					}, n, i);
					return a
				},
				setPath: function(e) {
					return this.path = e, this
				}
			}), Object.assign(vi.prototype, {
				load: function(e, t, n, i) {
					var r = this,
						o = new h,
						a = new di(this.manager);
					return a.setResponseType("arraybuffer"), a.load(e, function(e) {
						var n = r._parser(e);
						n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : ba, o.wrapT = void 0 !== n.wrapT ? n.wrapT : ba, o.magFilter = void 0 !== n.magFilter ? n.magFilter : Ea, o.minFilter = void 0 !== n.minFilter ? n.minFilter : Pa, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = Ea), o.needsUpdate = !0, t && t(o, n))
					}, n, i), o
				}
			}), Object.assign(pi.prototype, {
				crossOrigin: "Anonymous",
				load: function(e, t, n, i) {
					void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
					var r = this,
						o = Ns.get(e);
					if (void 0 !== o) return r.manager.itemStart(e), setTimeout(function() {
						t && t(o), r.manager.itemEnd(e)
					}, 0), o;
					var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
					return a.addEventListener("load", function() {
						Ns.add(e, this), t && t(this), r.manager.itemEnd(e)
					}, !1), a.addEventListener("error", function(t) {
						i && i(t), r.manager.itemEnd(e), r.manager.itemError(e)
					}, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
				},
				setCrossOrigin: function(e) {
					return this.crossOrigin = e, this
				},
				setPath: function(e) {
					return this.path = e, this
				}
			}), Object.assign(mi.prototype, {
				crossOrigin: "Anonymous",
				load: function(e, t, n, i) {
					var r = new d,
						o = new pi(this.manager);
					o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
					for (var a = 0, s = 0; s < e.length; ++s) ! function(n) {
						o.load(e[n], function(e) {
							r.images[n] = e, 6 == ++a && (r.needsUpdate = !0, t && t(r))
						}, void 0, i)
					}(s);
					return r
				},
				setCrossOrigin: function(e) {
					return this.crossOrigin = e, this
				},
				setPath: function(e) {
					return this.path = e, this
				}
			}), Object.assign(gi.prototype, {
				crossOrigin: "Anonymous",
				load: function(e, t, n, i) {
					var r = new s,
						o = new pi(this.manager);
					return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(n) {
						r.image = n;
						var i = e.search(/\.(jpg|jpeg)$/) > 0 || 0 === e.search(/^data\:image\/jpeg/);
						r.format = i ? Ba : Ga, r.needsUpdate = !0, void 0 !== t && t(r)
					}, n, i), r
				},
				setCrossOrigin: function(e) {
					return this.crossOrigin = e, this
				},
				setPath: function(e) {
					return this.path = e, this
				}
			}), Object.assign(yi.prototype, {
				getPoint: function() {
					return console.warn("THREE.Curve: .getPoint() not implemented."), null
				},
				getPointAt: function(e, t) {
					var n = this.getUtoTmapping(e);
					return this.getPoint(n, t)
				},
				getPoints: function(e) {
					void 0 === e && (e = 5);
					for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
					return t
				},
				getSpacedPoints: function(e) {
					void 0 === e && (e = 5);
					for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
					return t
				},
				getLength: function() {
					var e = this.getLengths();
					return e[e.length - 1]
				},
				getLengths: function(e) {
					if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
					this.needsUpdate = !1;
					var t, n, i = [],
						r = this.getPoint(0),
						o = 0;
					for (i.push(0), n = 1; n <= e; n++) o += (t = this.getPoint(n / e)).distanceTo(r), i.push(o), r = t;
					return this.cacheArcLengths = i, i
				},
				updateArcLengths: function() {
					this.needsUpdate = !0, this.getLengths()
				},
				getUtoTmapping: function(e, t) {
					var n, i = this.getLengths(),
						r = 0,
						o = i.length;
					n = t || e * i[o - 1];
					for (var a, s = 0, c = o - 1; s <= c;)
						if (r = Math.floor(s + (c - s) / 2), (a = i[r] - n) < 0) s = r + 1;
						else {
							if (!(a > 0)) {
								c = r;
								break
							}
							c = r - 1
						}
					if (r = c, i[r] === n) return r / (o - 1);
					var l = i[r];
					return (r + (n - l) / (i[r + 1] - l)) / (o - 1)
				},
				getTangent: function(e) {
					var t = e - 1e-4,
						n = e + 1e-4;
					t < 0 && (t = 0), n > 1 && (n = 1);
					var i = this.getPoint(t);
					return this.getPoint(n).clone().sub(i).normalize()
				},
				getTangentAt: function(e) {
					var t = this.getUtoTmapping(e);
					return this.getTangent(t)
				},
				computeFrenetFrames: function(e, t) {
					var n, r, a, s = new o,
						c = [],
						l = [],
						u = [],
						h = new o,
						d = new i;
					for (n = 0; n <= e; n++) r = n / e, c[n] = this.getTangentAt(r), c[n].normalize();
					l[0] = new o, u[0] = new o;
					var f = Number.MAX_VALUE,
						v = Math.abs(c[0].x),
						p = Math.abs(c[0].y),
						m = Math.abs(c[0].z);
					for (v <= f && (f = v, s.set(1, 0, 0)), p <= f && (f = p, s.set(0, 1, 0)), m <= f && s.set(0, 0, 1), h.crossVectors(c[0], s).normalize(), l[0].crossVectors(c[0], h), u[0].crossVectors(c[0], l[0]), n = 1; n <= e; n++) l[n] = l[n - 1].clone(), u[n] = u[n - 1].clone(), h.crossVectors(c[n - 1], c[n]), h.length() > Number.EPSILON && (h.normalize(), a = Math.acos(gs.clamp(c[n - 1].dot(c[n]), -1, 1)), l[n].applyMatrix4(d.makeRotationAxis(h, a))), u[n].crossVectors(c[n], l[n]);
					if (!0 === t)
						for (a = Math.acos(gs.clamp(l[0].dot(l[e]), -1, 1)), a /= e, c[0].dot(h.crossVectors(l[0], l[e])) > 0 && (a = -a), n = 1; n <= e; n++) l[n].applyMatrix4(d.makeRotationAxis(c[n], a * n)), u[n].crossVectors(c[n], l[n]);
					return {
						tangents: c,
						normals: l,
						binormals: u
					}
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.arcLengthDivisions = e.arcLengthDivisions, this
				},
				toJSON: function() {
					var e = {
						metadata: {
							version: 4.5,
							type: "Curve",
							generator: "Curve.toJSON"
						}
					};
					return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
				},
				fromJSON: function(e) {
					return this.arcLengthDivisions = e.arcLengthDivisions, this
				}
			}), xi.prototype = Object.create(yi.prototype), xi.prototype.constructor = xi, xi.prototype.isEllipseCurve = !0, xi.prototype.getPoint = function(e, t) {
				for (var i = t || new n, r = 2 * Math.PI, o = this.aEndAngle - this.aStartAngle, a = Math.abs(o) < Number.EPSILON; o < 0;) o += r;
				for (; o > r;) o -= r;
				o < Number.EPSILON && (o = a ? 0 : r), !0 !== this.aClockwise || a || (o === r ? o = -r : o -= r);
				var s = this.aStartAngle + e * o,
					c = this.aX + this.xRadius * Math.cos(s),
					l = this.aY + this.yRadius * Math.sin(s);
				if (0 !== this.aRotation) {
					var u = Math.cos(this.aRotation),
						h = Math.sin(this.aRotation),
						d = c - this.aX,
						f = l - this.aY;
					c = d * u - f * h + this.aX, l = d * h + f * u + this.aY
				}
				return i.set(c, l)
			}, xi.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
			}, xi.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
			}, xi.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
			}, (bi.prototype = Object.create(xi.prototype)).constructor = bi, bi.prototype.isArcCurve = !0;
			var Hs = new o,
				Vs = new wi,
				Ws = new wi,
				Ys = new wi;
			Mi.prototype = Object.create(yi.prototype), Mi.prototype.constructor = Mi, Mi.prototype.isCatmullRomCurve3 = !0, Mi.prototype.getPoint = function(e, t) {
				var n = t || new o,
					i = this.points,
					r = i.length,
					a = (r - (this.closed ? 0 : 1)) * e,
					s = Math.floor(a),
					c = a - s;
				this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / i.length) + 1) * i.length : 0 === c && s === r - 1 && (s = r - 2, c = 1);
				var l, u, h, d;
				if (this.closed || s > 0 ? l = i[(s - 1) % r] : (Hs.subVectors(i[0], i[1]).add(i[0]), l = Hs), u = i[s % r], h = i[(s + 1) % r], this.closed || s + 2 < r ? d = i[(s + 2) % r] : (Hs.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), d = Hs), "centripetal" === this.curveType || "chordal" === this.curveType) {
					var f = "chordal" === this.curveType ? .5 : .25,
						v = Math.pow(l.distanceToSquared(u), f),
						p = Math.pow(u.distanceToSquared(h), f),
						m = Math.pow(h.distanceToSquared(d), f);
					p < 1e-4 && (p = 1), v < 1e-4 && (v = p), m < 1e-4 && (m = p), Vs.initNonuniformCatmullRom(l.x, u.x, h.x, d.x, v, p, m), Ws.initNonuniformCatmullRom(l.y, u.y, h.y, d.y, v, p, m), Ys.initNonuniformCatmullRom(l.z, u.z, h.z, d.z, v, p, m)
				} else "catmullrom" === this.curveType && (Vs.initCatmullRom(l.x, u.x, h.x, d.x, this.tension), Ws.initCatmullRom(l.y, u.y, h.y, d.y, this.tension), Ys.initCatmullRom(l.z, u.z, h.z, d.z, this.tension));
				return n.set(Vs.calc(c), Ws.calc(c), Ys.calc(c)), n
			}, Mi.prototype.copy = function(e) {
				yi.prototype.copy.call(this, e), this.points = [];
				for (var t = 0, n = e.points.length; t < n; t++) {
					var i = e.points[t];
					this.points.push(i.clone())
				}
				return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
			}, Mi.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				e.points = [];
				for (var t = 0, n = this.points.length; t < n; t++) {
					var i = this.points[t];
					e.points.push(i.toArray())
				}
				return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
			}, Mi.prototype.fromJSON = function(e) {
				yi.prototype.fromJSON.call(this, e), this.points = [];
				for (var t = 0, n = e.points.length; t < n; t++) {
					var i = e.points[t];
					this.points.push((new o).fromArray(i))
				}
				return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
			}, (Ii.prototype = Object.create(yi.prototype)).constructor = Ii, Ii.prototype.isCubicBezierCurve = !0, Ii.prototype.getPoint = function(e, t) {
				var i = t || new n,
					r = this.v0,
					o = this.v1,
					a = this.v2,
					s = this.v3;
				return i.set(Ri(e, r.x, o.x, a.x, s.x), Ri(e, r.y, o.y, a.y, s.y)), i
			}, Ii.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
			}, Ii.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
			}, Ii.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
			}, (ji.prototype = Object.create(yi.prototype)).constructor = ji, ji.prototype.isCubicBezierCurve3 = !0, ji.prototype.getPoint = function(e, t) {
				var n = t || new o,
					i = this.v0,
					r = this.v1,
					a = this.v2,
					s = this.v3;
				return n.set(Ri(e, i.x, r.x, a.x, s.x), Ri(e, i.y, r.y, a.y, s.y), Ri(e, i.z, r.z, a.z, s.z)), n
			}, ji.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
			}, ji.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
			}, ji.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
			}, (Oi.prototype = Object.create(yi.prototype)).constructor = Oi, Oi.prototype.isLineCurve = !0, Oi.prototype.getPoint = function(e, t) {
				var i = t || new n;
				return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
			}, Oi.prototype.getPointAt = function(e, t) {
				return this.getPoint(e, t)
			}, Oi.prototype.getTangent = function() {
				return this.v2.clone().sub(this.v1).normalize()
			}, Oi.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}, Oi.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}, Oi.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}, (Di.prototype = Object.create(yi.prototype)).constructor = Di, Di.prototype.isLineCurve3 = !0, Di.prototype.getPoint = function(e, t) {
				var n = t || new o;
				return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
			}, Di.prototype.getPointAt = function(e, t) {
				return this.getPoint(e, t)
			}, Di.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}, Di.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}, Di.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}, (Fi.prototype = Object.create(yi.prototype)).constructor = Fi, Fi.prototype.isQuadraticBezierCurve = !0, Fi.prototype.getPoint = function(e, t) {
				var i = t || new n,
					r = this.v0,
					o = this.v1,
					a = this.v2;
				return i.set(Pi(e, r.x, o.x, a.x), Pi(e, r.y, o.y, a.y)), i
			}, Fi.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}, Fi.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}, Fi.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}, (Ui.prototype = Object.create(yi.prototype)).constructor = Ui, Ui.prototype.isQuadraticBezierCurve3 = !0, Ui.prototype.getPoint = function(e, t) {
				var n = t || new o,
					i = this.v0,
					r = this.v1,
					a = this.v2;
				return n.set(Pi(e, i.x, r.x, a.x), Pi(e, i.y, r.y, a.y), Pi(e, i.z, r.z, a.z)), n
			}, Ui.prototype.copy = function(e) {
				return yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}, Ui.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}, Ui.prototype.fromJSON = function(e) {
				return yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}, (ki.prototype = Object.create(yi.prototype)).constructor = ki, ki.prototype.isSplineCurve = !0, ki.prototype.getPoint = function(e, t) {
				var i = t || new n,
					r = this.points,
					o = (r.length - 1) * e,
					a = Math.floor(o),
					s = o - a,
					c = r[0 === a ? a : a - 1],
					l = r[a],
					u = r[a > r.length - 2 ? r.length - 1 : a + 1],
					h = r[a > r.length - 3 ? r.length - 1 : a + 2];
				return i.set(_i(s, c.x, l.x, u.x, h.x), _i(s, c.y, l.y, u.y, h.y)), i
			}, ki.prototype.copy = function(e) {
				yi.prototype.copy.call(this, e), this.points = [];
				for (var t = 0, n = e.points.length; t < n; t++) {
					var i = e.points[t];
					this.points.push(i.clone())
				}
				return this
			}, ki.prototype.toJSON = function() {
				var e = yi.prototype.toJSON.call(this);
				e.points = [];
				for (var t = 0, n = this.points.length; t < n; t++) {
					var i = this.points[t];
					e.points.push(i.toArray())
				}
				return e
			}, ki.prototype.fromJSON = function(e) {
				yi.prototype.fromJSON.call(this, e), this.points = [];
				for (var t = 0, i = e.points.length; t < i; t++) {
					var r = e.points[t];
					this.points.push((new n).fromArray(r))
				}
				return this
			};
			var Xs = Object.freeze({
				ArcCurve: bi,
				CatmullRomCurve3: Mi,
				CubicBezierCurve: Ii,
				CubicBezierCurve3: ji,
				EllipseCurve: xi,
				LineCurve: Oi,
				LineCurve3: Di,
				QuadraticBezierCurve: Fi,
				QuadraticBezierCurve3: Ui,
				SplineCurve: ki
			});
			Ni.prototype = Object.assign(Object.create(yi.prototype), {
				constructor: Ni,
				add: function(e) {
					this.curves.push(e)
				},
				closePath: function() {
					var e = this.curves[0].getPoint(0),
						t = this.curves[this.curves.length - 1].getPoint(1);
					e.equals(t) || this.curves.push(new Oi(t, e))
				},
				getPoint: function(e) {
					for (var t = e * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
						if (n[i] >= t) {
							var r = n[i] - t,
								o = this.curves[i],
								a = o.getLength(),
								s = 0 === a ? 0 : 1 - r / a;
							return o.getPointAt(s)
						}
						i++
					}
					return null
				},
				getLength: function() {
					var e = this.getCurveLengths();
					return e[e.length - 1]
				},
				updateArcLengths: function() {
					this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
				},
				getCurveLengths: function() {
					if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
					for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
					return this.cacheLengths = e, e
				},
				getSpacedPoints: function(e) {
					void 0 === e && (e = 40);
					for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
					return this.autoClose && t.push(t[0]), t
				},
				getPoints: function(e) {
					e = e || 12;
					for (var t, n = [], i = 0, r = this.curves; i < r.length; i++)
						for (var o = r[i], a = o && o.isEllipseCurve ? 2 * e : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), c = 0; c < s.length; c++) {
							var l = s[c];
							t && t.equals(l) || (n.push(l), t = l)
						}
					return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
				},
				copy: function(e) {
					yi.prototype.copy.call(this, e), this.curves = [];
					for (var t = 0, n = e.curves.length; t < n; t++) {
						var i = e.curves[t];
						this.curves.push(i.clone())
					}
					return this.autoClose = e.autoClose, this
				},
				toJSON: function() {
					var e = yi.prototype.toJSON.call(this);
					e.autoClose = this.autoClose, e.curves = [];
					for (var t = 0, n = this.curves.length; t < n; t++) {
						var i = this.curves[t];
						e.curves.push(i.toJSON())
					}
					return e
				},
				fromJSON: function(e) {
					yi.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
					for (var t = 0, n = e.curves.length; t < n; t++) {
						var i = e.curves[t];
						this.curves.push((new Xs[i.type]).fromJSON(i))
					}
					return this
				}
			}), Bi.prototype = Object.assign(Object.create(Ni.prototype), {
				constructor: Bi,
				setFromPoints: function(e) {
					this.moveTo(e[0].x, e[0].y);
					for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
				},
				moveTo: function(e, t) {
					this.currentPoint.set(e, t)
				},
				lineTo: function(e, t) {
					var i = new Oi(this.currentPoint.clone(), new n(e, t));
					this.curves.push(i), this.currentPoint.set(e, t)
				},
				quadraticCurveTo: function(e, t, i, r) {
					var o = new Fi(this.currentPoint.clone(), new n(e, t), new n(i, r));
					this.curves.push(o), this.currentPoint.set(i, r)
				},
				bezierCurveTo: function(e, t, i, r, o, a) {
					var s = new Ii(this.currentPoint.clone(), new n(e, t), new n(i, r), new n(o, a));
					this.curves.push(s), this.currentPoint.set(o, a)
				},
				splineThru: function(e) {
					var t = new ki([this.currentPoint.clone()].concat(e));
					this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
				},
				arc: function(e, t, n, i, r, o) {
					var a = this.currentPoint.x,
						s = this.currentPoint.y;
					this.absarc(e + a, t + s, n, i, r, o)
				},
				absarc: function(e, t, n, i, r, o) {
					this.absellipse(e, t, n, n, i, r, o)
				},
				ellipse: function(e, t, n, i, r, o, a, s) {
					var c = this.currentPoint.x,
						l = this.currentPoint.y;
					this.absellipse(e + c, t + l, n, i, r, o, a, s)
				},
				absellipse: function(e, t, n, i, r, o, a, s) {
					var c = new xi(e, t, n, i, r, o, a, s);
					if (this.curves.length > 0) {
						var l = c.getPoint(0);
						l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
					}
					this.curves.push(c);
					var u = c.getPoint(1);
					this.currentPoint.copy(u)
				},
				copy: function(e) {
					return Ni.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
				},
				toJSON: function() {
					var e = Ni.prototype.toJSON.call(this);
					return e.currentPoint = this.currentPoint.toArray(), e
				},
				fromJSON: function(e) {
					return Ni.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
				}
			}), Gi.prototype = Object.assign(Object.create(Bi.prototype), {
				constructor: Gi,
				getPointsHoles: function(e) {
					for (var t = [], n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
					return t
				},
				extractPoints: function(e) {
					return {
						shape: this.getPoints(e),
						holes: this.getPointsHoles(e)
					}
				},
				copy: function(e) {
					Bi.prototype.copy.call(this, e), this.holes = [];
					for (var t = 0, n = e.holes.length; t < n; t++) {
						var i = e.holes[t];
						this.holes.push(i.clone())
					}
					return this
				},
				toJSON: function() {
					var e = Bi.prototype.toJSON.call(this);
					e.uuid = this.uuid, e.holes = [];
					for (var t = 0, n = this.holes.length; t < n; t++) {
						var i = this.holes[t];
						e.holes.push(i.toJSON())
					}
					return e
				},
				fromJSON: function(e) {
					Bi.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
					for (var t = 0, n = e.holes.length; t < n; t++) {
						var i = e.holes[t];
						this.holes.push((new Bi).fromJSON(i))
					}
					return this
				}
			}), Hi.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Hi,
				isLight: !0,
				copy: function(e) {
					return le.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
				},
				toJSON: function(e) {
					var t = le.prototype.toJSON.call(this, e);
					return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
				}
			}), Vi.prototype = Object.assign(Object.create(Hi.prototype), {
				constructor: Vi,
				isHemisphereLight: !0,
				copy: function(e) {
					return Hi.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
				}
			}), Object.assign(Wi.prototype, {
				copy: function(e) {
					return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				toJSON: function() {
					var e = {};
					return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
				}
			}), Yi.prototype = Object.assign(Object.create(Wi.prototype), {
				constructor: Yi,
				isSpotLightShadow: !0,
				update: function(e) {
					var t = this.camera,
						n = 2 * gs.RAD2DEG * e.angle,
						i = this.mapSize.width / this.mapSize.height,
						r = e.distance || t.far;
					n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix())
				}
			}), Xi.prototype = Object.assign(Object.create(Hi.prototype), {
				constructor: Xi,
				isSpotLight: !0,
				copy: function(e) {
					return Hi.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
				}
			}), qi.prototype = Object.assign(Object.create(Hi.prototype), {
				constructor: qi,
				isPointLight: !0,
				copy: function(e) {
					return Hi.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
				}
			}), Zi.prototype = Object.assign(Object.create(Wi.prototype), {
				constructor: Zi
			}), Ki.prototype = Object.assign(Object.create(Hi.prototype), {
				constructor: Ki,
				isDirectionalLight: !0,
				copy: function(e) {
					return Hi.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
				}
			}), Ji.prototype = Object.assign(Object.create(Hi.prototype), {
				constructor: Ji,
				isAmbientLight: !0
			}), Qi.prototype = Object.assign(Object.create(Hi.prototype), {
				constructor: Qi,
				isRectAreaLight: !0,
				copy: function(e) {
					return Hi.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
				},
				toJSON: function(e) {
					var t = Hi.prototype.toJSON.call(this, e);
					return t.object.width = this.width, t.object.height = this.height, t
				}
			}), $i.prototype = Object.assign(Object.create(lr.prototype), {
				constructor: $i,
				ValueTypeName: "string",
				ValueBufferType: Array,
				DefaultInterpolation: 2300,
				InterpolantFactoryMethodLinear: void 0,
				InterpolantFactoryMethodSmooth: void 0
			}), er.prototype = Object.assign(Object.create(lr.prototype), {
				constructor: er,
				ValueTypeName: "bool",
				ValueBufferType: Array,
				DefaultInterpolation: 2300,
				InterpolantFactoryMethodLinear: void 0,
				InterpolantFactoryMethodSmooth: void 0
			}), Object.assign(tr.prototype, {
				evaluate: function(e) {
					var t = this.parameterPositions,
						n = this._cachedIndex,
						i = t[n],
						r = t[n - 1];
					e: {
						t: {
							var o;n: {
								i: if (!(e < i)) {
									for (s = n + 2;;) {
										if (void 0 === i) {
											if (e < r) break i;
											return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
										}
										if (n === s) break;
										if (r = i, i = t[++n], e < i) break t
									}
									o = t.length;
									break n
								} {
									if (e >= r) break e;
									var a = t[1];
									e < a && (n = 2, r = a);
									for (var s = n - 2;;) {
										if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
										if (n === s) break;
										if (i = r, r = t[--n - 1], e >= r) break t
									}
									o = n, n = 0
								}
							}
							for (; n < o;) {
								var c = n + o >>> 1;
								e < t[c] ? o = c : n = c + 1
							}
							if (i = t[n], void 0 === (r = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
							if (void 0 === i) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e)
						}
						this._cachedIndex = n,
						this.intervalChanged_(n, r, i)
					}
					return this.interpolate_(n, r, e, i)
				},
				settings: null,
				DefaultSettings_: {},
				getSettings_: function() {
					return this.settings || this.DefaultSettings_
				},
				copySampleValue_: function(e) {
					for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i, o = 0; o !== i; ++o) t[o] = n[r + o];
					return t
				},
				interpolate_: function() {
					throw new Error("call to abstract method")
				},
				intervalChanged_: function() {}
			}), Object.assign(tr.prototype, {
				beforeStart_: tr.prototype.copySampleValue_,
				afterEnd_: tr.prototype.copySampleValue_
			}), nr.prototype = Object.assign(Object.create(tr.prototype), {
				constructor: nr,
				interpolate_: function(e, t, n, i) {
					for (var o = this.resultBuffer, a = this.sampleValues, s = this.valueSize, c = e * s, l = (n - t) / (i - t), u = c + s; c !== u; c += 4) r.slerpFlat(o, 0, a, c - s, a, c, l);
					return o
				}
			}), ir.prototype = Object.assign(Object.create(lr.prototype), {
				constructor: ir,
				ValueTypeName: "quaternion",
				DefaultInterpolation: 2301,
				InterpolantFactoryMethodLinear: function(e) {
					return new nr(this.times, this.values, this.getValueSize(), e)
				},
				InterpolantFactoryMethodSmooth: void 0
			}), rr.prototype = Object.assign(Object.create(lr.prototype), {
				constructor: rr,
				ValueTypeName: "color"
			}), or.prototype = Object.assign(Object.create(lr.prototype), {
				constructor: or,
				ValueTypeName: "number"
			}), ar.prototype = Object.assign(Object.create(tr.prototype), {
				constructor: ar,
				DefaultSettings_: {
					endingStart: rs,
					endingEnd: rs
				},
				intervalChanged_: function(e, t, n) {
					var i = this.parameterPositions,
						r = e - 2,
						o = e + 1,
						a = i[r],
						s = i[o];
					if (void 0 === a) switch (this.getSettings_().endingStart) {
						case 2401:
							r = e, a = 2 * t - n;
							break;
						case 2402:
							a = t + i[r = i.length - 2] - i[r + 1];
							break;
						default:
							r = e, a = n
					}
					if (void 0 === s) switch (this.getSettings_().endingEnd) {
						case 2401:
							o = e, s = 2 * n - t;
							break;
						case 2402:
							o = 1, s = n + i[1] - i[0];
							break;
						default:
							o = e - 1, s = t
					}
					var c = .5 * (n - t),
						l = this.valueSize;
					this._weightPrev = c / (t - a), this._weightNext = c / (s - n), this._offsetPrev = r * l, this._offsetNext = o * l
				},
				interpolate_: function(e, t, n, i) {
					for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - t) / (i - t), v = f * f, p = v * f, m = -h * p + 2 * h * v - h * f, g = (1 + h) * p + (-1.5 - 2 * h) * v + (-.5 + h) * f + 1, y = (-1 - d) * p + (1.5 + d) * v + .5 * f, x = d * p - d * v, b = 0; b !== a; ++b) r[b] = m * o[l + b] + g * o[c + b] + y * o[s + b] + x * o[u + b];
					return r
				}
			}), sr.prototype = Object.assign(Object.create(tr.prototype), {
				constructor: sr,
				interpolate_: function(e, t, n, i) {
					for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = (n - t) / (i - t), u = 1 - l, h = 0; h !== a; ++h) r[h] = o[c + h] * u + o[s + h] * l;
					return r
				}
			}), cr.prototype = Object.assign(Object.create(tr.prototype), {
				constructor: cr,
				interpolate_: function(e) {
					return this.copySampleValue_(e - 1)
				}
			});
			var qs = {
				arraySlice: function(e, t, n) {
					return qs.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
				},
				convertArray: function(e, t, n) {
					return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
				},
				isTypedArray: function(e) {
					return ArrayBuffer.isView(e) && !(e instanceof DataView)
				},
				getKeyframeOrder: function(e) {
					for (var t = e.length, n = new Array(t), i = 0; i !== t; ++i) n[i] = i;
					return n.sort(function(t, n) {
						return e[t] - e[n]
					}), n
				},
				sortedArray: function(e, t, n) {
					for (var i = e.length, r = new e.constructor(i), o = 0, a = 0; a !== i; ++o)
						for (var s = n[o] * t, c = 0; c !== t; ++c) r[a++] = e[s + c];
					return r
				},
				flattenJSON: function(e, t, n, i) {
					for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[i];) o = e[r++];
					if (void 0 !== o) {
						var a = o[i];
						if (void 0 !== a)
							if (Array.isArray(a))
								do {
									void 0 !== (a = o[i]) && (t.push(o.time), n.push.apply(n, a)), o = e[r++]
								} while (void 0 !== o);
							else if (void 0 !== a.toArray)
							do {
								void 0 !== (a = o[i]) && (t.push(o.time), a.toArray(n, n.length)), o = e[r++]
							} while (void 0 !== o);
						else
							do {
								void 0 !== (a = o[i]) && (t.push(o.time), n.push(a)), o = e[r++]
							} while (void 0 !== o)
					}
				}
			};
			Object.assign(lr, {
				parse: function(e) {
					if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
					var t = lr._getTrackTypeForValueTypeName(e.type);
					if (void 0 === e.times) {
						var n = [],
							i = [];
						qs.flattenJSON(e.keys, n, i, "value"), e.times = n, e.values = i
					}
					return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
				},
				toJSON: function(e) {
					var t, n = e.constructor;
					if (void 0 !== n.toJSON) t = n.toJSON(e);
					else {
						t = {
							name: e.name,
							times: qs.convertArray(e.times, Array),
							values: qs.convertArray(e.values, Array)
						};
						var i = e.getInterpolation();
						i !== e.DefaultInterpolation && (t.interpolation = i)
					}
					return t.type = e.ValueTypeName, t
				},
				_getTrackTypeForValueTypeName: function(e) {
					switch (e.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return or;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return ur;
						case "color":
							return rr;
						case "quaternion":
							return ir;
						case "bool":
						case "boolean":
							return er;
						case "string":
							return $i
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
				}
			}), Object.assign(lr.prototype, {
				constructor: lr,
				TimeBufferType: Float32Array,
				ValueBufferType: Float32Array,
				DefaultInterpolation: 2301,
				InterpolantFactoryMethodDiscrete: function(e) {
					return new cr(this.times, this.values, this.getValueSize(), e)
				},
				InterpolantFactoryMethodLinear: function(e) {
					return new sr(this.times, this.values, this.getValueSize(), e)
				},
				InterpolantFactoryMethodSmooth: function(e) {
					return new ar(this.times, this.values, this.getValueSize(), e)
				},
				setInterpolation: function(e) {
					var t;
					switch (e) {
						case 2300:
							t = this.InterpolantFactoryMethodDiscrete;
							break;
						case 2301:
							t = this.InterpolantFactoryMethodLinear;
							break;
						case 2302:
							t = this.InterpolantFactoryMethodSmooth
					}
					if (void 0 !== t) this.createInterpolant = t;
					else {
						var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
						if (void 0 === this.createInterpolant) {
							if (e === this.DefaultInterpolation) throw new Error(n);
							this.setInterpolation(this.DefaultInterpolation)
						}
						console.warn("THREE.KeyframeTrack:", n)
					}
				},
				getInterpolation: function() {
					switch (this.createInterpolant) {
						case this.InterpolantFactoryMethodDiscrete:
							return 2300;
						case this.InterpolantFactoryMethodLinear:
							return 2301;
						case this.InterpolantFactoryMethodSmooth:
							return 2302
					}
				},
				getValueSize: function() {
					return this.values.length / this.times.length
				},
				shift: function(e) {
					if (0 !== e)
						for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] += e;
					return this
				},
				scale: function(e) {
					if (1 !== e)
						for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] *= e;
					return this
				},
				trim: function(e, t) {
					for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < e;) ++r;
					for (; - 1 !== o && n[o] > t;) --o;
					if (++o, 0 !== r || o !== i) {
						r >= o && (o = Math.max(o, 1), r = o - 1);
						var a = this.getValueSize();
						this.times = qs.arraySlice(n, r, o), this.values = qs.arraySlice(this.values, r * a, o * a)
					}
					return this
				},
				validate: function() {
					var e = !0,
						t = this.getValueSize();
					t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
					var n = this.times,
						i = this.values,
						r = n.length;
					0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
					for (var o = null, a = 0; a !== r; a++) {
						var s = n[a];
						if ("number" == typeof s && isNaN(s)) {
							console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), e = !1;
							break
						}
						if (null !== o && o > s) {
							console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), e = !1;
							break
						}
						o = s
					}
					if (void 0 !== i && qs.isTypedArray(i))
						for (var a = 0, c = i.length; a !== c; ++a) {
							var l = i[a];
							if (isNaN(l)) {
								console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), e = !1;
								break
							}
						}
					return e
				},
				optimize: function() {
					for (var e = this.times, t = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, o = e.length - 1, a = 1; a < o; ++a) {
						var s = !1,
							c = e[a];
						if (c !== e[a + 1] && (1 !== a || c !== c[0]))
							if (i) s = !0;
							else
								for (var l = a * n, u = l - n, h = l + n, d = 0; d !== n; ++d) {
									var f = t[l + d];
									if (f !== t[u + d] || f !== t[h + d]) {
										s = !0;
										break
									}
								}
						if (s) {
							if (a !== r) {
								e[r] = e[a];
								for (var v = a * n, p = r * n, d = 0; d !== n; ++d) t[p + d] = t[v + d]
							}++r
						}
					}
					if (o > 0) {
						e[r] = e[o];
						for (var v = o * n, p = r * n, d = 0; d !== n; ++d) t[p + d] = t[v + d];
						++r
					}
					return r !== e.length && (this.times = qs.arraySlice(e, 0, r), this.values = qs.arraySlice(t, 0, r * n)), this
				}
			}), ur.prototype = Object.assign(Object.create(lr.prototype), {
				constructor: ur,
				ValueTypeName: "vector"
			}), Object.assign(hr, {
				parse: function(e) {
					for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, o = n.length; r !== o; ++r) t.push(lr.parse(n[r]).scale(i));
					return new hr(e.name, e.duration, t)
				},
				toJSON: function(e) {
					for (var t = [], n = e.tracks, i = {
							name: e.name,
							duration: e.duration,
							tracks: t
						}, r = 0, o = n.length; r !== o; ++r) t.push(lr.toJSON(n[r]));
					return i
				},
				CreateFromMorphTargetSequence: function(e, t, n, i) {
					for (var r = t.length, o = [], a = 0; a < r; a++) {
						var s = [],
							c = [];
						s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
						var l = qs.getKeyframeOrder(s);
						s = qs.sortedArray(s, 1, l), c = qs.sortedArray(c, 1, l), i || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new or(".morphTargetInfluences[" + t[a].name + "]", s, c).scale(1 / n))
					}
					return new hr(e, -1, o)
				},
				findByName: function(e, t) {
					var n = e;
					if (!Array.isArray(e)) {
						var i = e;
						n = i.geometry && i.geometry.animations || i.animations
					}
					for (var r = 0; r < n.length; r++)
						if (n[r].name === t) return n[r];
					return null
				},
				CreateClipsFromMorphTargetSequences: function(e, t, n) {
					for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
						var s = e[o],
							c = s.name.match(r);
						if (c && c.length > 1) {
							var l = i[h = c[1]];
							l || (i[h] = l = []), l.push(s)
						}
					}
					var u = [];
					for (var h in i) u.push(hr.CreateFromMorphTargetSequence(h, i[h], t, n));
					return u
				},
				parseAnimation: function(e, t) {
					if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
					for (var n = function(e, t, n, i, r) {
							if (0 !== n.length) {
								var o = [],
									a = [];
								qs.flattenJSON(n, o, a, i), 0 !== o.length && r.push(new e(t, o, a))
							}
						}, i = [], r = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], c = 0; c < s.length; c++) {
						var l = s[c].keys;
						if (l && 0 !== l.length)
							if (l[0].morphTargets) {
								for (var u = {}, h = 0; h < l.length; h++)
									if (l[h].morphTargets)
										for (p = 0; p < l[h].morphTargets.length; p++) u[l[h].morphTargets[p]] = -1;
								for (var d in u) {
									for (var f = [], v = [], p = 0; p !== l[h].morphTargets.length; ++p) {
										var m = l[h];
										f.push(m.time), v.push(m.morphTarget === d ? 1 : 0)
									}
									i.push(new or(".morphTargetInfluence[" + d + "]", f, v))
								}
								o = u.length * (a || 1)
							} else {
								var g = ".bones[" + t[c].name + "]";
								n(ur, g + ".position", l, "pos", i), n(ir, g + ".quaternion", l, "rot", i), n(ur, g + ".scale", l, "scl", i)
							}
					}
					return 0 === i.length ? null : new hr(r, o, i)
				}
			}), Object.assign(hr.prototype, {
				resetDuration: function() {
					for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
						var i = this.tracks[t];
						e = Math.max(e, i.times[i.times.length - 1])
					}
					this.duration = e
				},
				trim: function() {
					for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
					return this
				},
				optimize: function() {
					for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
					return this
				}
			}), Object.assign(dr.prototype, {
				load: function(e, t, n, i) {
					var r = this;
					new di(r.manager).load(e, function(e) {
						t(r.parse(JSON.parse(e)))
					}, n, i)
				},
				setTextures: function(e) {
					this.textures = e
				},
				parse: function(e) {
					function t(e) {
						return void 0 === i[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), i[e]
					}
					var i = this.textures,
						r = new ks[e.type];
					if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearCoat && (r.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (r.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.uniforms && (r.uniforms = e.uniforms), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = t(e.map)), void 0 !== e.alphaMap && (r.alphaMap = t(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = t(e.normalMap)), void 0 !== e.normalScale) {
						var o = e.normalScale;
						!1 === Array.isArray(o) && (o = [o, o]), r.normalScale = (new n).fromArray(o)
					}
					return void 0 !== e.displacementMap && (r.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = t(e.specularMap)), void 0 !== e.envMap && (r.envMap = t(e.envMap)), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.lightMap && (r.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = t(e.gradientMap)), r
				}
			}), Object.assign(fr.prototype, {
				load: function(e, t, n, i) {
					var r = this;
					new di(r.manager).load(e, function(e) {
						t(r.parse(JSON.parse(e)))
					}, n, i)
				},
				parse: function(e) {
					var t = new Te,
						n = e.data.index;
					if (void 0 !== n) {
						s = new Zs[n.type](n.array);
						t.setIndex(new ve(s, 1))
					}
					var i = e.data.attributes;
					for (var r in i) {
						var a = i[r],
							s = new Zs[a.type](a.array);
						t.addAttribute(r, new ve(s, a.itemSize, a.normalized))
					}
					var c = e.data.groups || e.data.drawcalls || e.data.offsets;
					if (void 0 !== c)
						for (var l = 0, u = c.length; l !== u; ++l) {
							var h = c[l];
							t.addGroup(h.start, h.count, h.materialIndex)
						}
					var d = e.data.boundingSphere;
					if (void 0 !== d) {
						var f = new o;
						void 0 !== d.center && f.fromArray(d.center), t.boundingSphere = new ne(f, d.radius)
					}
					return t
				}
			});
			var Zs = {
				Int8Array: Int8Array,
				Uint8Array: Uint8Array,
				Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
				Int16Array: Int16Array,
				Uint16Array: Uint16Array,
				Int32Array: Int32Array,
				Uint32Array: Uint32Array,
				Float32Array: Float32Array,
				Float64Array: Float64Array
			};
			vr.Handlers = {
				handlers: [],
				add: function(e, t) {
					this.handlers.push(e, t)
				},
				get: function(e) {
					for (var t = this.handlers, n = 0, i = t.length; n < i; n += 2) {
						var r = t[n],
							o = t[n + 1];
						if (r.test(e)) return o
					}
					return null
				}
			}, Object.assign(vr.prototype, {
				crossOrigin: void 0,
				initMaterials: function(e, t, n) {
					for (var i = [], r = 0; r < e.length; ++r) i[r] = this.createMaterial(e[r], t, n);
					return i
				},
				createMaterial: function() {
					var e = {
							NoBlending: Ao,
							NormalBlending: Lo,
							AdditiveBlending: Co,
							SubtractiveBlending: zo,
							MultiplyBlending: Ro,
							CustomBlending: Io
						},
						t = new X,
						n = new gi,
						i = new dr;
					return function(r, o, a) {
						function s(e, t, i, r, s) {
							var l, u = o + e,
								h = vr.Handlers.get(u);
							null !== h ? l = h.load(u) : (n.setCrossOrigin(a), l = n.load(u)), void 0 !== t && (l.repeat.fromArray(t), 1 !== t[0] && (l.wrapS = xa), 1 !== t[1] && (l.wrapT = xa)), void 0 !== i && l.offset.fromArray(i), void 0 !== r && ("repeat" === r[0] && (l.wrapS = xa), "mirror" === r[0] && (l.wrapS = wa), "repeat" === r[1] && (l.wrapT = xa), "mirror" === r[1] && (l.wrapT = wa)), void 0 !== s && (l.anisotropy = s);
							var d = gs.generateUUID();
							return c[d] = l, d
						}
						var c = {},
							l = {
								uuid: gs.generateUUID(),
								type: "MeshLambertMaterial"
							};
						for (var u in r) {
							var h = r[u];
							switch (u) {
								case "DbgColor":
								case "DbgIndex":
								case "opticalDensity":
								case "illumination":
									break;
								case "DbgName":
									l.name = h;
									break;
								case "blending":
									l.blending = e[h];
									break;
								case "colorAmbient":
								case "mapAmbient":
									console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
									break;
								case "colorDiffuse":
									l.color = t.fromArray(h).getHex();
									break;
								case "colorSpecular":
									l.specular = t.fromArray(h).getHex();
									break;
								case "colorEmissive":
									l.emissive = t.fromArray(h).getHex();
									break;
								case "specularCoef":
									l.shininess = h;
									break;
								case "shading":
									"basic" === h.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (l.type = "MeshStandardMaterial");
									break;
								case "mapDiffuse":
									l.map = s(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
									break;
								case "mapDiffuseRepeat":
								case "mapDiffuseOffset":
								case "mapDiffuseWrap":
								case "mapDiffuseAnisotropy":
									break;
								case "mapEmissive":
									l.emissiveMap = s(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
									break;
								case "mapEmissiveRepeat":
								case "mapEmissiveOffset":
								case "mapEmissiveWrap":
								case "mapEmissiveAnisotropy":
									break;
								case "mapLight":
									l.lightMap = s(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
									break;
								case "mapLightRepeat":
								case "mapLightOffset":
								case "mapLightWrap":
								case "mapLightAnisotropy":
									break;
								case "mapAO":
									l.aoMap = s(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
									break;
								case "mapAORepeat":
								case "mapAOOffset":
								case "mapAOWrap":
								case "mapAOAnisotropy":
									break;
								case "mapBump":
									l.bumpMap = s(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
									break;
								case "mapBumpScale":
									l.bumpScale = h;
									break;
								case "mapBumpRepeat":
								case "mapBumpOffset":
								case "mapBumpWrap":
								case "mapBumpAnisotropy":
									break;
								case "mapNormal":
									l.normalMap = s(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
									break;
								case "mapNormalFactor":
									l.normalScale = [h, h];
									break;
								case "mapNormalRepeat":
								case "mapNormalOffset":
								case "mapNormalWrap":
								case "mapNormalAnisotropy":
									break;
								case "mapSpecular":
									l.specularMap = s(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
									break;
								case "mapSpecularRepeat":
								case "mapSpecularOffset":
								case "mapSpecularWrap":
								case "mapSpecularAnisotropy":
									break;
								case "mapMetalness":
									l.metalnessMap = s(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
									break;
								case "mapMetalnessRepeat":
								case "mapMetalnessOffset":
								case "mapMetalnessWrap":
								case "mapMetalnessAnisotropy":
									break;
								case "mapRoughness":
									l.roughnessMap = s(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
									break;
								case "mapRoughnessRepeat":
								case "mapRoughnessOffset":
								case "mapRoughnessWrap":
								case "mapRoughnessAnisotropy":
									break;
								case "mapAlpha":
									l.alphaMap = s(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
									break;
								case "mapAlphaRepeat":
								case "mapAlphaOffset":
								case "mapAlphaWrap":
								case "mapAlphaAnisotropy":
									break;
								case "flipSided":
									l.side = _o;
									break;
								case "doubleSided":
									l.side = So;
									break;
								case "transparency":
									console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = h;
									break;
								case "depthTest":
								case "depthWrite":
								case "colorWrite":
								case "opacity":
								case "reflectivity":
								case "transparent":
								case "visible":
								case "wireframe":
									l[u] = h;
									break;
								case "vertexColors":
									!0 === h && (l.vertexColors = Po), "face" === h && (l.vertexColors = To);
									break;
								default:
									console.error("THREE.Loader.createMaterial: Unsupported", u, h)
							}
						}
						return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, l.opacity < 1 && (l.transparent = !0), i.setTextures(c), i.parse(l)
					}
				}()
			});
			var Ks = {
				decodeText: function(e) {
					if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
					for (var t = "", n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
					return t
				},
				extractUrlBase: function(e) {
					var t = e.split("/");
					return 1 === t.length ? "./" : (t.pop(), t.join("/") + "/")
				}
			};
			Object.assign(pr.prototype, {
				load: function(e, t, n, i) {
					var r = this,
						o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Ks.extractUrlBase(e),
						a = new di(this.manager);
					a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
						var i = JSON.parse(n),
							a = i.metadata;
						if (void 0 !== a) {
							var s = a.type;
							if (void 0 !== s) {
								if ("object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.");
								if ("scene" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.SceneLoader instead.")
							}
						}
						var c = r.parse(i, o);
						t(c.geometry, c.materials)
					}, n, i)
				},
				setTexturePath: function(e) {
					this.texturePath = e
				},
				parse: function() {
					function e(e, t) {
						function i(e, t) {
							return e & 1 << t
						}
						var r, a, s, c, l, u, h, d, f, v, p, m, g, y, x, b, w, M, _, S, E, T, P, A, L, C = e.faces,
							z = e.vertices,
							R = e.normals,
							I = e.colors,
							j = e.scale,
							O = 0;
						if (void 0 !== e.uvs) {
							for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && O++;
							for (r = 0; r < O; r++) t.faceVertexUvs[r] = []
						}
						for (c = 0, l = z.length; c < l;)(M = new o).x = z[c++] * j, M.y = z[c++] * j, M.z = z[c++] * j, t.vertices.push(M);
						for (c = 0, l = C.length; c < l;)
							if (v = C[c++], p = i(v, 0), m = i(v, 1), g = i(v, 3), y = i(v, 4), x = i(v, 5), b = i(v, 6), w = i(v, 7), p) {
								if (S = new de, S.a = C[c], S.b = C[c + 1], S.c = C[c + 3], E = new de, E.a = C[c + 1], E.b = C[c + 2], E.c = C[c + 3], c += 4, m && (f = C[c++], S.materialIndex = f, E.materialIndex = f), s = t.faces.length, g)
									for (r = 0; r < O; r++)
										for (A = e.uvs[r], t.faceVertexUvs[r][s] = [], t.faceVertexUvs[r][s + 1] = [], a = 0; a < 4; a++) L = new n(A[2 * (d = C[c++])], A[2 * d + 1]), 2 !== a && t.faceVertexUvs[r][s].push(L), 0 !== a && t.faceVertexUvs[r][s + 1].push(L);
								if (y && (h = 3 * C[c++], S.normal.set(R[h++], R[h++], R[h]), E.normal.copy(S.normal)), x)
									for (r = 0; r < 4; r++) h = 3 * C[c++], P = new o(R[h++], R[h++], R[h]), 2 !== r && S.vertexNormals.push(P), 0 !== r && E.vertexNormals.push(P);
								if (b && (T = I[u = C[c++]], S.color.setHex(T), E.color.setHex(T)), w)
									for (r = 0; r < 4; r++) T = I[u = C[c++]], 2 !== r && S.vertexColors.push(new X(T)), 0 !== r && E.vertexColors.push(new X(T));
								t.faces.push(S), t.faces.push(E)
							} else {
								if (_ = new de, _.a = C[c++], _.b = C[c++], _.c = C[c++], m && (f = C[c++], _.materialIndex = f), s = t.faces.length, g)
									for (r = 0; r < O; r++)
										for (A = e.uvs[r], t.faceVertexUvs[r][s] = [], a = 0; a < 3; a++) L = new n(A[2 * (d = C[c++])], A[2 * d + 1]), t.faceVertexUvs[r][s].push(L);
								if (y && (h = 3 * C[c++], _.normal.set(R[h++], R[h++], R[h])), x)
									for (r = 0; r < 3; r++) h = 3 * C[c++], P = new o(R[h++], R[h++], R[h]), _.vertexNormals.push(P);
								if (b && (u = C[c++], _.color.setHex(I[u])), w)
									for (r = 0; r < 3; r++) u = C[c++], _.vertexColors.push(new X(I[u]));
								t.faces.push(_)
							}
					}

					function t(e, t) {
						var n = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
						if (e.skinWeights)
							for (var i = 0, r = e.skinWeights.length; i < r; i += n) {
								var o = e.skinWeights[i],
									a = n > 1 ? e.skinWeights[i + 1] : 0,
									s = n > 2 ? e.skinWeights[i + 2] : 0,
									l = n > 3 ? e.skinWeights[i + 3] : 0;
								t.skinWeights.push(new c(o, a, s, l))
							}
						if (e.skinIndices)
							for (var i = 0, r = e.skinIndices.length; i < r; i += n) {
								var u = e.skinIndices[i],
									h = n > 1 ? e.skinIndices[i + 1] : 0,
									d = n > 2 ? e.skinIndices[i + 2] : 0,
									f = n > 3 ? e.skinIndices[i + 3] : 0;
								t.skinIndices.push(new c(u, h, d, f))
							}
						t.bones = e.bones, t.bones && t.bones.length > 0 && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
					}

					function i(e, t) {
						var n = e.scale;
						if (void 0 !== e.morphTargets)
							for (var i = 0, r = e.morphTargets.length; i < r; i++) {
								t.morphTargets[i] = {}, t.morphTargets[i].name = e.morphTargets[i].name, t.morphTargets[i].vertices = [];
								for (var a = t.morphTargets[i].vertices, s = e.morphTargets[i].vertices, c = 0, l = s.length; c < l; c += 3) {
									var u = new o;
									u.x = s[c] * n, u.y = s[c + 1] * n, u.z = s[c + 2] * n, a.push(u)
								}
							}
						if (void 0 !== e.morphColors && e.morphColors.length > 0) {
							console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
							for (var h = t.faces, d = e.morphColors[0].colors, i = 0, r = h.length; i < r; i++) h[i].color.fromArray(d, 3 * i)
						}
					}

					function r(e, t) {
						var n = [],
							i = [];
						void 0 !== e.animation && i.push(e.animation), void 0 !== e.animations && (e.animations.length ? i = i.concat(e.animations) : i.push(e.animations));
						for (var r = 0; r < i.length; r++) {
							var o = hr.parseAnimation(i[r], t.bones);
							o && n.push(o)
						}
						if (t.morphTargets) {
							var a = hr.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
							n = n.concat(a)
						}
						n.length > 0 && (t.animations = n)
					}
					return function(n, o) {
						void 0 !== n.data && (n = n.data), void 0 !== n.scale ? n.scale = 1 / n.scale : n.scale = 1;
						var a = new fe;
						return e(n, a), t(n, a), i(n, a), r(n, a), a.computeFaceNormals(), a.computeBoundingSphere(), void 0 === n.materials || 0 === n.materials.length ? {
							geometry: a
						} : {
							geometry: a,
							materials: vr.prototype.initMaterials(n.materials, o, this.crossOrigin)
						}
					}
				}()
			}), Object.assign(mr.prototype, {
				load: function(e, t, n, i) {
					"" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
					var r = this;
					new di(r.manager).load(e, function(n) {
						var o = null;
						try {
							o = JSON.parse(n)
						} catch (t) {
							return void 0 !== i && i(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
						}
						var a = o.metadata;
						void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, t) : console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.")
					}, n, i)
				},
				setTexturePath: function(e) {
					this.texturePath = e
				},
				setCrossOrigin: function(e) {
					this.crossOrigin = e
				},
				parse: function(e, t) {
					var n = this.parseShape(e.shapes),
						i = this.parseGeometries(e.geometries, n),
						r = this.parseImages(e.images, function() {
							void 0 !== t && t(s)
						}),
						o = this.parseTextures(e.textures, r),
						a = this.parseMaterials(e.materials, o),
						s = this.parseObject(e.object, i, a);
					return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
				},
				parseShape: function(e) {
					var t = {};
					if (void 0 !== e)
						for (var n = 0, i = e.length; n < i; n++) {
							var r = (new Gi).fromJSON(e[n]);
							t[r.uuid] = r
						}
					return t
				},
				parseGeometries: function(e, t) {
					var n = {};
					if (void 0 !== e)
						for (var i = new pr, r = new fr, o = 0, a = e.length; o < a; o++) {
							var s, c = e[o];
							switch (c.type) {
								case "PlaneGeometry":
								case "PlaneBufferGeometry":
									s = new Us[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
									break;
								case "BoxGeometry":
								case "BoxBufferGeometry":
								case "CubeGeometry":
									s = new Us[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
									break;
								case "CircleGeometry":
								case "CircleBufferGeometry":
									s = new Us[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
									break;
								case "CylinderGeometry":
								case "CylinderBufferGeometry":
									s = new Us[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
									break;
								case "ConeGeometry":
								case "ConeBufferGeometry":
									s = new Us[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
									break;
								case "SphereGeometry":
								case "SphereBufferGeometry":
									s = new Us[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
									break;
								case "DodecahedronGeometry":
								case "DodecahedronBufferGeometry":
								case "IcosahedronGeometry":
								case "IcosahedronBufferGeometry":
								case "OctahedronGeometry":
								case "OctahedronBufferGeometry":
								case "TetrahedronGeometry":
								case "TetrahedronBufferGeometry":
									s = new Us[c.type](c.radius, c.detail);
									break;
								case "RingGeometry":
								case "RingBufferGeometry":
									s = new Us[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
									break;
								case "TorusGeometry":
								case "TorusBufferGeometry":
									s = new Us[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
									break;
								case "TorusKnotGeometry":
								case "TorusKnotBufferGeometry":
									s = new Us[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
									break;
								case "LatheGeometry":
								case "LatheBufferGeometry":
									s = new Us[c.type](c.points, c.segments, c.phiStart, c.phiLength);
									break;
								case "PolyhedronGeometry":
								case "PolyhedronBufferGeometry":
									s = new Us[c.type](c.vertices, c.indices, c.radius, c.details);
									break;
								case "ShapeGeometry":
								case "ShapeBufferGeometry":
									for (var l = [], o = 0, a = c.shapes.length; o < a; o++) {
										var u = t[c.shapes[o]];
										l.push(u)
									}
									s = new Us[c.type](l, c.curveSegments);
									break;
								case "BufferGeometry":
									s = r.parse(c);
									break;
								case "Geometry":
									s = i.parse(c, this.texturePath).geometry;
									break;
								default:
									console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
									continue
							}
							s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), n[c.uuid] = s
						}
					return n
				},
				parseMaterials: function(e, t) {
					var n = {};
					if (void 0 !== e) {
						var i = new dr;
						i.setTextures(t);
						for (var r = 0, o = e.length; r < o; r++) {
							var a = e[r];
							if ("MultiMaterial" === a.type) {
								for (var s = [], c = 0; c < a.materials.length; c++) s.push(i.parse(a.materials[c]));
								n[a.uuid] = s
							} else n[a.uuid] = i.parse(a)
						}
					}
					return n
				},
				parseAnimations: function(e) {
					for (var t = [], n = 0; n < e.length; n++) {
						var i = hr.parse(e[n]);
						t.push(i)
					}
					return t
				},
				parseImages: function(e, t) {
					var n = this,
						i = {};
					if (void 0 !== e && e.length > 0) {
						var r = new pi(new hi(t));
						r.setCrossOrigin(this.crossOrigin);
						for (var o = 0, a = e.length; o < a; o++) {
							var s = e[o],
								c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.texturePath + s.url;
							i[s.uuid] = function(e) {
								return n.manager.itemStart(e), r.load(e, function() {
									n.manager.itemEnd(e)
								}, void 0, function() {
									n.manager.itemEnd(e), n.manager.itemError(e)
								})
							}(c)
						}
					}
					return i
				},
				parseTextures: function(e, t) {
					function n(e, t) {
						return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
					}
					var i = {};
					if (void 0 !== e)
						for (var r = 0, o = e.length; r < o; r++) {
							var a = e[r];
							void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
							var c = new s(t[a.image]);
							c.needsUpdate = !0, c.uuid = a.uuid, void 0 !== a.name && (c.name = a.name), void 0 !== a.mapping && (c.mapping = n(a.mapping, Js)), void 0 !== a.offset && c.offset.fromArray(a.offset), void 0 !== a.repeat && c.repeat.fromArray(a.repeat), void 0 !== a.center && c.center.fromArray(a.center), void 0 !== a.rotation && (c.rotation = a.rotation), void 0 !== a.wrap && (c.wrapS = n(a.wrap[0], Qs), c.wrapT = n(a.wrap[1], Qs)), void 0 !== a.minFilter && (c.minFilter = n(a.minFilter, $s)), void 0 !== a.magFilter && (c.magFilter = n(a.magFilter, $s)), void 0 !== a.anisotropy && (c.anisotropy = a.anisotropy), void 0 !== a.flipY && (c.flipY = a.flipY), i[a.uuid] = c
						}
					return i
				},
				parseObject: function() {
					var e = new i;
					return function(t, n, i) {
						function r(e) {
							return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), n[e]
						}

						function o(e) {
							if (void 0 !== e) {
								if (Array.isArray(e)) {
									for (var t = [], n = 0, r = e.length; n < r; n++) {
										var o = e[n];
										void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(i[o])
									}
									return t
								}
								return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e]
							}
						}
						var a;
						switch (t.type) {
							case "Scene":
								a = new St, void 0 !== t.background && Number.isInteger(t.background) && (a.background = new X(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? a.fog = new _t(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (a.fog = new Mt(t.fog.color, t.fog.density)));
								break;
							case "PerspectiveCamera":
								a = new pt(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (a.focus = t.focus), void 0 !== t.zoom && (a.zoom = t.zoom), void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset), void 0 !== t.view && (a.view = Object.assign({}, t.view));
								break;
							case "OrthographicCamera":
								a = new he(t.left, t.right, t.top, t.bottom, t.near, t.far);
								break;
							case "AmbientLight":
								a = new Ji(t.color, t.intensity);
								break;
							case "DirectionalLight":
								a = new Ki(t.color, t.intensity);
								break;
							case "PointLight":
								a = new qi(t.color, t.intensity, t.distance, t.decay);
								break;
							case "RectAreaLight":
								a = new Qi(t.color, t.intensity, t.width, t.height);
								break;
							case "SpotLight":
								a = new Xi(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
								break;
							case "HemisphereLight":
								a = new Vi(t.color, t.groundColor, t.intensity);
								break;
							case "SkinnedMesh":
								console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
							case "Mesh":
								var s = r(t.geometry),
									c = o(t.material);
								a = s.bones && s.bones.length > 0 ? new zt(s, c) : new De(s, c);
								break;
							case "LOD":
								a = new At;
								break;
							case "Line":
								a = new It(r(t.geometry), o(t.material), t.mode);
								break;
							case "LineLoop":
								a = new Ot(r(t.geometry), o(t.material));
								break;
							case "LineSegments":
								a = new jt(r(t.geometry), o(t.material));
								break;
							case "PointCloud":
							case "Points":
								a = new Ft(r(t.geometry), o(t.material));
								break;
							case "Sprite":
								a = new Pt(o(t.material));
								break;
							case "Group":
								a = new Ut;
								break;
							default:
								a = new le
						}
						if (a.uuid = t.uuid, void 0 !== t.name && (a.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== t.position && a.position.fromArray(t.position), void 0 !== t.rotation && a.rotation.fromArray(t.rotation), void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion), void 0 !== t.scale && a.scale.fromArray(t.scale)), void 0 !== t.castShadow && (a.castShadow = t.castShadow), void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && a.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (a.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (a.visible = t.visible), void 0 !== t.userData && (a.userData = t.userData), void 0 !== t.children)
							for (var l = t.children, u = 0; u < l.length; u++) a.add(this.parseObject(l[u], n, i));
						if ("LOD" === t.type)
							for (var h = t.levels, d = 0; d < h.length; d++) {
								var f = h[d],
									v = a.getObjectByProperty("uuid", f.object);
								void 0 !== v && a.addLevel(v, f.distance)
							}
						return a
					}
				}()
			});
			var Js = {
					UVMapping: 300,
					CubeReflectionMapping: da,
					CubeRefractionMapping: fa,
					EquirectangularReflectionMapping: va,
					EquirectangularRefractionMapping: pa,
					SphericalReflectionMapping: ma,
					CubeUVReflectionMapping: ga,
					CubeUVRefractionMapping: ya
				},
				Qs = {
					RepeatWrapping: xa,
					ClampToEdgeWrapping: ba,
					MirroredRepeatWrapping: wa
				},
				$s = {
					NearestFilter: Ma,
					NearestMipMapNearestFilter: _a,
					NearestMipMapLinearFilter: Sa,
					LinearFilter: Ea,
					LinearMipMapNearestFilter: Ta,
					LinearMipMapLinearFilter: Pa
				};
			gr.prototype = {
				constructor: gr,
				setOptions: function(e) {
					return this.options = e, this
				},
				load: function(e, t, n, i) {
					void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
					var r = this,
						o = Ns.get(e);
					if (void 0 !== o) return r.manager.itemStart(e), setTimeout(function() {
						t && t(o), r.manager.itemEnd(e)
					}, 0), o;
					fetch(e).then(function(e) {
						return e.blob()
					}).then(function(e) {
						return createImageBitmap(e, r.options)
					}).then(function(n) {
						Ns.add(e, n), t && t(n), r.manager.itemEnd(e)
					}).catch(function(t) {
						i && i(t), r.manager.itemEnd(e), r.manager.itemError(e)
					})
				},
				setCrossOrigin: function() {
					return this
				},
				setPath: function(e) {
					return this.path = e, this
				}
			}, Object.assign(yr.prototype, {
				moveTo: function(e, t) {
					this.currentPath = new Bi, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
				},
				lineTo: function(e, t) {
					this.currentPath.lineTo(e, t)
				},
				quadraticCurveTo: function(e, t, n, i) {
					this.currentPath.quadraticCurveTo(e, t, n, i)
				},
				bezierCurveTo: function(e, t, n, i, r, o) {
					this.currentPath.bezierCurveTo(e, t, n, i, r, o)
				},
				splineThru: function(e) {
					this.currentPath.splineThru(e)
				},
				toShapes: function(e, t) {
					function n(e) {
						for (var t = [], n = 0, i = e.length; n < i; n++) {
							var r = e[n],
								o = new Gi;
							o.curves = r.curves, t.push(o)
						}
						return t
					}
					var i = Fs.isClockWise,
						r = this.subPaths;
					if (0 === r.length) return [];
					if (!0 === t) return n(r);
					var o, a, s, c = [];
					if (1 === r.length) return a = r[0], s = new Gi, s.curves = a.curves, c.push(s), c;
					var l = !i(r[0].getPoints());
					l = e ? !l : l;
					var u, h = [],
						d = [],
						f = [],
						v = 0;
					d[v] = void 0, f[v] = [];
					for (var p = 0, m = r.length; p < m; p++) o = i(u = (a = r[p]).getPoints()), (o = e ? !o : o) ? (!l && d[v] && v++, d[v] = {
						s: new Gi,
						p: u
					}, d[v].s.curves = a.curves, l && v++, f[v] = []) : f[v].push({
						h: a,
						p: u[0]
					});
					if (!d[0]) return n(r);
					if (d.length > 1) {
						for (var g = !1, y = [], x = 0, b = d.length; x < b; x++) h[x] = [];
						for (var x = 0, b = d.length; x < b; x++)
							for (var w = f[x], M = 0; M < w.length; M++) {
								for (var _ = w[M], S = !0, E = 0; E < d.length; E++)(function(e, t) {
									for (var n = t.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
										var a = t[r],
											s = t[o],
											c = s.x - a.x,
											l = s.y - a.y;
										if (Math.abs(l) > Number.EPSILON) {
											if (l < 0 && (a = t[o], c = -c, s = t[r], l = -l), e.y < a.y || e.y > s.y) continue;
											if (e.y === a.y) {
												if (e.x === a.x) return !0
											} else {
												var u = l * (e.x - a.x) - c * (e.y - a.y);
												if (0 === u) return !0;
												if (u < 0) continue;
												i = !i
											}
										} else {
											if (e.y !== a.y) continue;
											if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
										}
									}
									return i
								})(_.p, d[E].p) && (x !== E && y.push({
									froms: x,
									tos: E,
									hole: M
								}), S ? (S = !1, h[E].push(_)) : g = !0);
								S && h[x].push(_)
							}
						y.length > 0 && (g || (f = h))
					}
					for (var T, p = 0, P = d.length; p < P; p++) {
						s = d[p].s, c.push(s);
						for (var A = 0, L = (T = f[p]).length; A < L; A++) s.holes.push(T[A].h)
					}
					return c
				}
			}), Object.assign(xr.prototype, {
				isFont: !0,
				generateShapes: function(e, t, n) {
					function i(e, t, n, i) {
						var o = r.glyphs[e] || r.glyphs["?"];
						if (o) {
							var a, s, c, l, u, h, d, f, v, p = new yr,
								m = [];
							if (o.o)
								for (var g = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), y = 0, x = g.length; y < x;) switch (g[y++]) {
									case "m":
										a = g[y++] * t + n, s = g[y++] * t + i, p.moveTo(a, s);
										break;
									case "l":
										a = g[y++] * t + n, s = g[y++] * t + i, p.lineTo(a, s);
										break;
									case "q":
										c = g[y++] * t + n, l = g[y++] * t + i, u = g[y++] * t + n, h = g[y++] * t + i, p.quadraticCurveTo(u, h, c, l), (v = m[m.length - 1]) && (v.x, v.y);
										break;
									case "b":
										c = g[y++] * t + n, l = g[y++] * t + i, u = g[y++] * t + n, h = g[y++] * t + i, d = g[y++] * t + n, f = g[y++] * t + i, p.bezierCurveTo(u, h, d, f, c, l), (v = m[m.length - 1]) && (v.x, v.y)
								}
							return {
								offsetX: o.ha * t,
								path: p
							}
						}
					}
					void 0 === t && (t = 100), void 0 === n && (n = 4);
					for (var r = this.data, o = function(e) {
							for (var n = String(e).split(""), o = t / r.resolution, a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * o, s = 0, c = 0, l = [], u = 0; u < n.length; u++) {
								var h = n[u];
								if ("\n" === h) s = 0, c -= a;
								else {
									var d = i(h, o, s, c);
									s += d.offsetX, l.push(d.path)
								}
							}
							return l
						}(e), a = [], s = 0, c = o.length; s < c; s++) Array.prototype.push.apply(a, o[s].toShapes());
					return a
				}
			}), Object.assign(br.prototype, {
				load: function(e, t, n, i) {
					var r = this,
						o = new di(this.manager);
					o.setPath(this.path), o.load(e, function(e) {
						var n;
						try {
							n = JSON.parse(e)
						} catch (t) {
							console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2))
						}
						var i = r.parse(n);
						t && t(i)
					}, n, i)
				},
				parse: function(e) {
					return new xr(e)
				},
				setPath: function(e) {
					return this.path = e, this
				}
			});
			var ec, tc = {
				getContext: function() {
					return void 0 === ec && (ec = new(window.AudioContext || window.webkitAudioContext)), ec
				},
				setContext: function(e) {
					ec = e
				}
			};
			Object.assign(wr.prototype, {
				load: function(e, t, n, i) {
					var r = new di(this.manager);
					r.setResponseType("arraybuffer"), r.load(e, function(e) {
						tc.getContext().decodeAudioData(e, function(e) {
							t(e)
						})
					}, n, i)
				}
			}), Object.assign(Mr.prototype, {
				update: function() {
					var e, t, n, r, o, a, s, c, l = new i,
						u = new i;
					return function(i) {
						if (e !== this || t !== i.focus || n !== i.fov || r !== i.aspect * this.aspect || o !== i.near || a !== i.far || s !== i.zoom || c !== this.eyeSep) {
							e = this, t = i.focus, n = i.fov, r = i.aspect * this.aspect, o = i.near, a = i.far, s = i.zoom;
							var h, d, f = i.projectionMatrix.clone(),
								v = (c = this.eyeSep / 2) * o / t,
								p = o * Math.tan(gs.DEG2RAD * n * .5) / s;
							u.elements[12] = -c, l.elements[12] = c, h = -p * r + v, d = p * r + v, f.elements[0] = 2 * o / (d - h), f.elements[8] = (d + h) / (d - h), this.cameraL.projectionMatrix.copy(f), h = -p * r - v, d = p * r - v, f.elements[0] = 2 * o / (d - h), f.elements[8] = (d + h) / (d - h), this.cameraR.projectionMatrix.copy(f)
						}
						this.cameraL.matrixWorld.copy(i.matrixWorld).multiply(u), this.cameraR.matrixWorld.copy(i.matrixWorld).multiply(l)
					}
				}()
			}), (_r.prototype = Object.create(le.prototype)).constructor = _r, Sr.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Sr,
				getInput: function() {
					return this.gain
				},
				removeFilter: function() {
					null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
				},
				getFilter: function() {
					return this.filter
				},
				setFilter: function(e) {
					null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
				},
				getMasterVolume: function() {
					return this.gain.gain.value
				},
				setMasterVolume: function(e) {
					this.gain.gain.value = e
				},
				updateMatrixWorld: function() {
					var e = new o,
						t = new r,
						n = new o,
						i = new o;
					return function(r) {
						le.prototype.updateMatrixWorld.call(this, r);
						var o = this.context.listener,
							a = this.up;
						this.matrixWorld.decompose(e, t, n), i.set(0, 0, -1).applyQuaternion(t), o.positionX ? (o.positionX.setValueAtTime(e.x, this.context.currentTime), o.positionY.setValueAtTime(e.y, this.context.currentTime), o.positionZ.setValueAtTime(e.z, this.context.currentTime), o.forwardX.setValueAtTime(i.x, this.context.currentTime), o.forwardY.setValueAtTime(i.y, this.context.currentTime), o.forwardZ.setValueAtTime(i.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(e.x, e.y, e.z), o.setOrientation(i.x, i.y, i.z, a.x, a.y, a.z))
					}
				}()
			}), Er.prototype = Object.assign(Object.create(le.prototype), {
				constructor: Er,
				getOutput: function() {
					return this.gain
				},
				setNodeSource: function(e) {
					return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
				},
				setBuffer: function(e) {
					return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
				},
				play: function() {
					if (!0 !== this.isPlaying) {
						if (!1 !== this.hasPlaybackControl) {
							var e = this.context.createBufferSource();
							return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect()
						}
						console.warn("THREE.Audio: this Audio has no playback control.")
					} else console.warn("THREE.Audio: Audio is already playing.")
				},
				pause: function() {
					if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				},
				stop: function() {
					if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				},
				connect: function() {
					if (this.filters.length > 0) {
						this.source.connect(this.filters[0]);
						for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
						this.filters[this.filters.length - 1].connect(this.getOutput())
					} else this.source.connect(this.getOutput());
					return this
				},
				disconnect: function() {
					if (this.filters.length > 0) {
						this.source.disconnect(this.filters[0]);
						for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
						this.filters[this.filters.length - 1].disconnect(this.getOutput())
					} else this.source.disconnect(this.getOutput());
					return this
				},
				getFilters: function() {
					return this.filters
				},
				setFilters: function(e) {
					return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
				},
				getFilter: function() {
					return this.getFilters()[0]
				},
				setFilter: function(e) {
					return this.setFilters(e ? [e] : [])
				},
				setPlaybackRate: function(e) {
					if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				},
				getPlaybackRate: function() {
					return this.playbackRate
				},
				onEnded: function() {
					this.isPlaying = !1
				},
				getLoop: function() {
					return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
				},
				setLoop: function(e) {
					if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				},
				getVolume: function() {
					return this.gain.gain.value
				},
				setVolume: function(e) {
					return this.gain.gain.value = e, this
				}
			}), Tr.prototype = Object.assign(Object.create(Er.prototype), {
				constructor: Tr,
				getOutput: function() {
					return this.panner
				},
				getRefDistance: function() {
					return this.panner.refDistance
				},
				setRefDistance: function(e) {
					this.panner.refDistance = e
				},
				getRolloffFactor: function() {
					return this.panner.rolloffFactor
				},
				setRolloffFactor: function(e) {
					this.panner.rolloffFactor = e
				},
				getDistanceModel: function() {
					return this.panner.distanceModel
				},
				setDistanceModel: function(e) {
					this.panner.distanceModel = e
				},
				getMaxDistance: function() {
					return this.panner.maxDistance
				},
				setMaxDistance: function(e) {
					this.panner.maxDistance = e
				},
				updateMatrixWorld: function() {
					var e = new o;
					return function(t) {
						le.prototype.updateMatrixWorld.call(this, t), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z)
					}
				}()
			}), Object.assign(Pr.prototype, {
				getFrequencyData: function() {
					return this.analyser.getByteFrequencyData(this.data), this.data
				},
				getAverageFrequency: function() {
					for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
					return e / t.length
				}
			}), Object.assign(Ar.prototype, {
				accumulate: function(e, t) {
					var n = this.buffer,
						i = this.valueSize,
						r = e * i + i,
						o = this.cumulativeWeight;
					if (0 === o) {
						for (var a = 0; a !== i; ++a) n[r + a] = n[a];
						o = t
					} else {
						var s = t / (o += t);
						this._mixBufferRegion(n, r, 0, s, i)
					}
					this.cumulativeWeight = o
				},
				apply: function(e) {
					var t = this.valueSize,
						n = this.buffer,
						i = e * t + t,
						r = this.cumulativeWeight,
						o = this.binding;
					if (this.cumulativeWeight = 0, r < 1) {
						var a = 3 * t;
						this._mixBufferRegion(n, i, a, 1 - r, t)
					}
					for (var s = t, c = t + t; s !== c; ++s)
						if (n[s] !== n[s + t]) {
							o.setValue(n, i);
							break
						}
				},
				saveOriginalState: function() {
					var e = this.binding,
						t = this.buffer,
						n = this.valueSize,
						i = 3 * n;
					e.getValue(t, i);
					for (var r = n, o = i; r !== o; ++r) t[r] = t[i + r % n];
					this.cumulativeWeight = 0
				},
				restoreOriginalState: function() {
					var e = 3 * this.valueSize;
					this.binding.setValue(this.buffer, e)
				},
				_select: function(e, t, n, i, r) {
					if (i >= .5)
						for (var o = 0; o !== r; ++o) e[t + o] = e[n + o]
				},
				_slerp: function(e, t, n, i) {
					r.slerpFlat(e, t, e, t, e, n, i)
				},
				_lerp: function(e, t, n, i, r) {
					for (var o = 1 - i, a = 0; a !== r; ++a) {
						var s = t + a;
						e[s] = e[s] * o + e[n + a] * i
					}
				}
			}), Object.assign(Lr.prototype, {
				getValue: function(e, t) {
					this.bind();
					var n = this._targetGroup.nCachedObjects_,
						i = this._bindings[n];
					void 0 !== i && i.getValue(e, t)
				},
				setValue: function(e, t) {
					for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
				},
				bind: function() {
					for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
				},
				unbind: function() {
					for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
				}
			}), Object.assign(Cr, {
				Composite: Lr,
				create: function(e, t, n) {
					return e && e.isAnimationObjectGroup ? new Cr.Composite(e, t, n) : new Cr(e, t, n)
				},
				sanitizeNodeName: function(e) {
					return e.replace(/\s/g, "_").replace(/[^\w-]/g, "")
				},
				parseTrackName: function() {
					var e = /((?:[\w-]+[\/:])*)/,
						t = /([\w-\.]+)?/,
						n = /(?:\.([\w-]+)(?:\[(.+)\])?)?/,
						i = /\.([\w-]+)(?:\[(.+)\])?/,
						r = new RegExp("^" + e.source + t.source + n.source + i.source + "$"),
						o = ["material", "materials", "bones"];
					return function(e) {
						var t = r.exec(e);
						if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
						var n = {
								nodeName: t[2],
								objectName: t[3],
								objectIndex: t[4],
								propertyName: t[5],
								propertyIndex: t[6]
							},
							i = n.nodeName && n.nodeName.lastIndexOf(".");
						if (void 0 !== i && -1 !== i) {
							var a = n.nodeName.substring(i + 1); - 1 !== o.indexOf(a) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = a)
						}
						if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
						return n
					}
				}(),
				findNode: function(e, t) {
					if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
					if (e.skeleton) {
						var n = function(e) {
							for (var n = 0; n < e.bones.length; n++) {
								var i = e.bones[n];
								if (i.name === t) return i
							}
							return null
						}(e.skeleton);
						if (n) return n
					}
					if (e.children) {
						var i = function(e) {
								for (var n = 0; n < e.length; n++) {
									var r = e[n];
									if (r.name === t || r.uuid === t) return r;
									var o = i(r.children);
									if (o) return o
								}
								return null
							},
							r = i(e.children);
						if (r) return r
					}
					return null
				}
			}), Object.assign(Cr.prototype, {
				_getValue_unavailable: function() {},
				_setValue_unavailable: function() {},
				BindingType: {
					Direct: 0,
					EntireArray: 1,
					ArrayElement: 2,
					HasFromToArray: 3
				},
				Versioning: {
					None: 0,
					NeedsUpdate: 1,
					MatrixWorldNeedsUpdate: 2
				},
				GetterByBindingType: [function(e, t) {
					e[t] = this.node[this.propertyName]
				}, function(e, t) {
					for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
				}, function(e, t) {
					e[t] = this.resolvedProperty[this.propertyIndex]
				}, function(e, t) {
					this.resolvedProperty.toArray(e, t)
				}],
				SetterByBindingTypeAndVersioning: [[function(e, t) {
					this.targetObject[this.propertyName] = e[t]
				}, function(e, t) {
					this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
				}, function(e, t) {
					this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
				}], [function(e, t) {
					for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
				}, function(e, t) {
					for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
					this.targetObject.needsUpdate = !0
				}, function(e, t) {
					for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
					this.targetObject.matrixWorldNeedsUpdate = !0
				}], [function(e, t) {
					this.resolvedProperty[this.propertyIndex] = e[t]
				}, function(e, t) {
					this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
				}, function(e, t) {
					this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
				}], [function(e, t) {
					this.resolvedProperty.fromArray(e, t)
				}, function(e, t) {
					this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
				}, function(e, t) {
					this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
				}]],
				getValue: function(e, t) {
					this.bind(), this.getValue(e, t)
				},
				setValue: function(e, t) {
					this.bind(), this.setValue(e, t)
				},
				bind: function() {
					var e = this.node,
						t = this.parsedPath,
						n = t.objectName,
						i = t.propertyName,
						r = t.propertyIndex;
					if (e || (e = Cr.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
						if (n) {
							var o = t.objectIndex;
							switch (n) {
								case "materials":
									if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
									if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
									e = e.material.materials;
									break;
								case "bones":
									if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
									e = e.skeleton.bones;
									for (l = 0; l < e.length; l++)
										if (e[l].name === o) {
											o = l;
											break
										}
									break;
								default:
									if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
									e = e[n]
							}
							if (void 0 !== o) {
								if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
								e = e[o]
							}
						}
						var a = e[i];
						if (void 0 !== a) {
							var s = this.Versioning.None;
							void 0 !== e.needsUpdate ? (s = this.Versioning.NeedsUpdate, this.targetObject = e) : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e);
							var c = this.BindingType.Direct;
							if (void 0 !== r) {
								if ("morphTargetInfluences" === i) {
									if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
									if (e.geometry.isBufferGeometry) {
										if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
										for (l = 0; l < this.node.geometry.morphAttributes.position.length; l++)
											if (e.geometry.morphAttributes.position[l].name === r) {
												r = l;
												break
											}
									} else {
										if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
										for (var l = 0; l < this.node.geometry.morphTargets.length; l++)
											if (e.geometry.morphTargets[l].name === r) {
												r = l;
												break
											}
									}
								}
								c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
							} else void 0 !== a.fromArray && void 0 !== a.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
							this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][s]
						} else {
							var u = t.nodeName;
							console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e)
						}
					} else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
				},
				unbind: function() {
					this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
				}
			}), Object.assign(Cr.prototype, {
				_getValue_unbound: Cr.prototype.getValue,
				_setValue_unbound: Cr.prototype.setValue
			}), Object.assign(zr.prototype, {
				isAnimationObjectGroup: !0,
				add: function() {
					for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = 0, l = arguments.length; c !== l; ++c) {
						var u = arguments[c],
							h = u.uuid,
							d = i[h],
							f = void 0;
						if (void 0 === d) {
							d = t++, i[h] = d, e.push(u);
							for (var v = 0, p = s; v !== p; ++v) a[v].push(new Cr(u, r[v], o[v]))
						} else if (d < n) {
							f = e[d];
							var m = --n,
								g = e[m];
							i[g.uuid] = d, e[d] = g, i[h] = m, e[m] = u;
							for (var v = 0, p = s; v !== p; ++v) {
								var y = a[v],
									x = y[m],
									b = y[d];
								y[d] = x, void 0 === b && (b = new Cr(u, r[v], o[v])), y[m] = b
							}
						} else e[d] !== f && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
					}
					this.nCachedObjects_ = n
				},
				remove: function() {
					for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
						var s = arguments[o],
							c = s.uuid,
							l = n[c];
						if (void 0 !== l && l >= t) {
							var u = t++,
								h = e[u];
							n[h.uuid] = l, e[l] = h, n[c] = u, e[u] = s;
							for (var d = 0, f = r; d !== f; ++d) {
								var v = i[d],
									p = v[u],
									m = v[l];
								v[l] = p, v[u] = m
							}
						}
					}
					this.nCachedObjects_ = t
				},
				uncache: function() {
					for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
						var c = arguments[a].uuid,
							l = i[c];
						if (void 0 !== l)
							if (delete i[c], l < n) {
								var u = --n,
									h = e[u],
									d = e[g = --t];
								i[h.uuid] = l, e[l] = h, i[d.uuid] = u, e[u] = d, e.pop();
								for (var f = 0, v = o; f !== v; ++f) {
									var p = (y = r[f])[u],
										m = y[g];
									y[l] = p, y[u] = m, y.pop()
								}
							} else {
								var g = --t;
								i[(d = e[g]).uuid] = l, e[l] = d, e.pop();
								for (var f = 0, v = o; f !== v; ++f) {
									var y = r[f];
									y[l] = y[g], y.pop()
								}
							}
					}
					this.nCachedObjects_ = n
				},
				subscribe_: function(e, t) {
					var n = this._bindingsIndicesByPath,
						i = n[e],
						r = this._bindings;
					if (void 0 !== i) return r[i];
					var o = this._paths,
						a = this._parsedPaths,
						s = this._objects,
						c = s.length,
						l = this.nCachedObjects_,
						u = new Array(c);
					i = r.length, n[e] = i, o.push(e), a.push(t), r.push(u);
					for (var h = l, d = s.length; h !== d; ++h) {
						var f = s[h];
						u[h] = new Cr(f, e, t)
					}
					return u
				},
				unsubscribe_: function(e) {
					var t = this._bindingsIndicesByPath,
						n = t[e];
					if (void 0 !== n) {
						var i = this._paths,
							r = this._parsedPaths,
							o = this._bindings,
							a = o.length - 1,
							s = o[a];
						t[e[a]] = n, o[n] = s, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
					}
				}
			}), Object.assign(Rr.prototype, {
				play: function() {
					return this._mixer._activateAction(this), this
				},
				stop: function() {
					return this._mixer._deactivateAction(this), this.reset()
				},
				reset: function() {
					return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
				},
				isRunning: function() {
					return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
				},
				isScheduled: function() {
					return this._mixer._isActiveAction(this)
				},
				startAt: function(e) {
					return this._startTime = e, this
				},
				setLoop: function(e, t) {
					return this.loop = e, this.repetitions = t, this
				},
				setEffectiveWeight: function(e) {
					return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
				},
				getEffectiveWeight: function() {
					return this._effectiveWeight
				},
				fadeIn: function(e) {
					return this._scheduleFading(e, 0, 1)
				},
				fadeOut: function(e) {
					return this._scheduleFading(e, 1, 0)
				},
				crossFadeFrom: function(e, t, n) {
					if (e.fadeOut(t), this.fadeIn(t), n) {
						var i = this._clip.duration,
							r = e._clip.duration,
							o = r / i,
							a = i / r;
						e.warp(1, o, t), this.warp(a, 1, t)
					}
					return this
				},
				crossFadeTo: function(e, t, n) {
					return e.crossFadeFrom(this, t, n)
				},
				stopFading: function() {
					var e = this._weightInterpolant;
					return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
				},
				setEffectiveTimeScale: function(e) {
					return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
				},
				getEffectiveTimeScale: function() {
					return this._effectiveTimeScale
				},
				setDuration: function(e) {
					return this.timeScale = this._clip.duration / e, this.stopWarping()
				},
				syncWith: function(e) {
					return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
				},
				halt: function(e) {
					return this.warp(this._effectiveTimeScale, 0, e)
				},
				warp: function(e, t, n) {
					var i = this._mixer,
						r = i.time,
						o = this._timeScaleInterpolant,
						a = this.timeScale;
					null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
					var s = o.parameterPositions,
						c = o.sampleValues;
					return s[0] = r, s[1] = r + n, c[0] = e / a, c[1] = t / a, this
				},
				stopWarping: function() {
					var e = this._timeScaleInterpolant;
					return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
				},
				getMixer: function() {
					return this._mixer
				},
				getClip: function() {
					return this._clip
				},
				getRoot: function() {
					return this._localRoot || this._mixer._root
				},
				_update: function(e, t, n, i) {
					if (this.enabled) {
						var r = this._startTime;
						if (null !== r) {
							var o = (e - r) * n;
							if (o < 0 || 0 === n) return;
							this._startTime = null, t = n * o
						}
						t *= this._updateTimeScale(e);
						var a = this._updateTime(t),
							s = this._updateWeight(e);
						if (s > 0)
							for (var c = this._interpolants, l = this._propertyBindings, u = 0, h = c.length; u !== h; ++u) c[u].evaluate(a), l[u].accumulate(i, s)
					} else this._updateWeight(e)
				},
				_updateWeight: function(e) {
					var t = 0;
					if (this.enabled) {
						t = this.weight;
						var n = this._weightInterpolant;
						if (null !== n) {
							var i = n.evaluate(e)[0];
							t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
						}
					}
					return this._effectiveWeight = t, t
				},
				_updateTimeScale: function(e) {
					var t = 0;
					if (!this.paused) {
						t = this.timeScale;
						var n = this._timeScaleInterpolant;
						null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
					}
					return this._effectiveTimeScale = t, t
				},
				_updateTime: function(e) {
					var t = this.time + e;
					if (0 === e) return t;
					var n = this._clip.duration,
						i = this.loop,
						r = this._loopCount;
					if (2200 === i) {
						-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
						e: {
							if (t >= n) t = n;
							else {
								if (!(t < 0)) break e;
								t = 0
							}
							this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
							this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: e < 0 ? -1 : 1
							})
						}
					} else {
						var o = 2202 === i;
						if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= n || t < 0) {
							var a = Math.floor(t / n);
							t -= n * a, r += Math.abs(a);
							var s = this.repetitions - r;
							if (s < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: e > 0 ? 1 : -1
							});
							else {
								if (0 === s) {
									var c = e < 0;
									this._setEndings(c, !c, o)
								} else this._setEndings(!1, !1, o);
								this._loopCount = r, this._mixer.dispatchEvent({
									type: "loop",
									action: this,
									loopDelta: a
								})
							}
						}
						if (o && 1 == (1 & r)) return this.time = t, n - t
					}
					return this.time = t, t
				},
				_setEndings: function(e, t, n) {
					var i = this._interpolantSettings;
					n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = e ? this.zeroSlopeAtStart ? 2401 : rs : 2402, i.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : rs : 2402)
				},
				_scheduleFading: function(e, t, n) {
					var i = this._mixer,
						r = i.time,
						o = this._weightInterpolant;
					null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
					var a = o.parameterPositions,
						s = o.sampleValues;
					return a[0] = r, s[0] = t, a[1] = r + e, s[1] = n, this
				}
			}), Ir.prototype = Object.assign(Object.create(t.prototype), {
				constructor: Ir,
				_bindAction: function(e, t) {
					var n = e._localRoot || this._root,
						i = e._clip.tracks,
						r = i.length,
						o = e._propertyBindings,
						a = e._interpolants,
						s = n.uuid,
						c = this._bindingsByRootAndName,
						l = c[s];
					void 0 === l && (l = {}, c[s] = l);
					for (var u = 0; u !== r; ++u) {
						var h = i[u],
							d = h.name,
							f = l[d];
						if (void 0 !== f) o[u] = f;
						else {
							if (void 0 !== (f = o[u])) {
								null === f._cacheIndex && (++f.referenceCount, this._addInactiveBinding(f, s, d));
								continue
							}
							var v = t && t._propertyBindings[u].binding.parsedPath;
							++(f = new Ar(Cr.create(n, d, v), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(f, s, d), o[u] = f
						}
						a[u].resultBuffer = f.buffer
					}
				},
				_activateAction: function(e) {
					if (!this._isActiveAction(e)) {
						if (null === e._cacheIndex) {
							var t = (e._localRoot || this._root).uuid,
								n = e._clip.uuid,
								i = this._actionsByClip[n];
							this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
						}
						for (var r = e._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
							var s = r[o];
							0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
						}
						this._lendAction(e)
					}
				},
				_deactivateAction: function(e) {
					if (this._isActiveAction(e)) {
						for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
							var r = t[n];
							0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
						}
						this._takeBackAction(e)
					}
				},
				_initMemoryManager: function() {
					this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
					var e = this;
					this.stats = {
						actions: {
							get total() {
								return e._actions.length
							},
							get inUse() {
								return e._nActiveActions
							}
						},
						bindings: {
							get total() {
								return e._bindings.length
							},
							get inUse() {
								return e._nActiveBindings
							}
						},
						controlInterpolants: {
							get total() {
								return e._controlInterpolants.length
							},
							get inUse() {
								return e._nActiveControlInterpolants
							}
						}
					}
				},
				_isActiveAction: function(e) {
					var t = e._cacheIndex;
					return null !== t && t < this._nActiveActions
				},
				_addInactiveAction: function(e, t, n) {
					var i = this._actions,
						r = this._actionsByClip,
						o = r[t];
					if (void 0 === o) o = {
						knownActions: [e],
						actionByRoot: {}
					}, e._byClipCacheIndex = 0, r[t] = o;
					else {
						var a = o.knownActions;
						e._byClipCacheIndex = a.length, a.push(e)
					}
					e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e
				},
				_removeInactiveAction: function(e) {
					var t = this._actions,
						n = t[t.length - 1],
						i = e._cacheIndex;
					n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
					var r = e._clip.uuid,
						o = this._actionsByClip,
						a = o[r],
						s = a.knownActions,
						c = s[s.length - 1],
						l = e._byClipCacheIndex;
					c._byClipCacheIndex = l, s[l] = c, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(e)
				},
				_removeInactiveBindingsForAction: function(e) {
					for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
						var r = t[n];
						0 == --r.referenceCount && this._removeInactiveBinding(r)
					}
				},
				_lendAction: function(e) {
					var t = this._actions,
						n = e._cacheIndex,
						i = this._nActiveActions++,
						r = t[i];
					e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
				},
				_takeBackAction: function(e) {
					var t = this._actions,
						n = e._cacheIndex,
						i = --this._nActiveActions,
						r = t[i];
					e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
				},
				_addInactiveBinding: function(e, t, n) {
					var i = this._bindingsByRootAndName,
						r = i[t],
						o = this._bindings;
					void 0 === r && (r = {}, i[t] = r), r[n] = e, e._cacheIndex = o.length, o.push(e)
				},
				_removeInactiveBinding: function(e) {
					var t = this._bindings,
						n = e.binding,
						i = n.rootNode.uuid,
						r = n.path,
						o = this._bindingsByRootAndName,
						a = o[i],
						s = t[t.length - 1],
						c = e._cacheIndex;
					s._cacheIndex = c, t[c] = s, t.pop(), delete a[r];
					e: {
						for (var l in a) break e;delete o[i]
					}
				},
				_lendBinding: function(e) {
					var t = this._bindings,
						n = e._cacheIndex,
						i = this._nActiveBindings++,
						r = t[i];
					e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
				},
				_takeBackBinding: function(e) {
					var t = this._bindings,
						n = e._cacheIndex,
						i = --this._nActiveBindings,
						r = t[i];
					e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
				},
				_lendControlInterpolant: function() {
					var e = this._controlInterpolants,
						t = this._nActiveControlInterpolants++,
						n = e[t];
					return void 0 === n && ((n = new sr(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n
				},
				_takeBackControlInterpolant: function(e) {
					var t = this._controlInterpolants,
						n = e.__cacheIndex,
						i = --this._nActiveControlInterpolants,
						r = t[i];
					e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
				},
				_controlInterpolantsResultBuffer: new Float32Array(1),
				clipAction: function(e, t) {
					var n = t || this._root,
						i = n.uuid,
						r = "string" == typeof e ? hr.findByName(n, e) : e,
						o = null !== r ? r.uuid : e,
						a = this._actionsByClip[o],
						s = null;
					if (void 0 !== a) {
						var c = a.actionByRoot[i];
						if (void 0 !== c) return c;
						s = a.knownActions[0], null === r && (r = s._clip)
					}
					if (null === r) return null;
					var l = new Rr(this, r, t);
					return this._bindAction(l, s), this._addInactiveAction(l, o, i), l
				},
				existingAction: function(e, t) {
					var n = t || this._root,
						i = n.uuid,
						r = "string" == typeof e ? hr.findByName(n, e) : e,
						o = r ? r.uuid : e,
						a = this._actionsByClip[o];
					return void 0 !== a ? a.actionByRoot[i] || null : null
				},
				stopAllAction: function() {
					var e = this._actions,
						t = this._nActiveActions,
						n = this._bindings,
						i = this._nActiveBindings;
					this._nActiveActions = 0, this._nActiveBindings = 0;
					for (r = 0; r !== t; ++r) e[r].reset();
					for (var r = 0; r !== i; ++r) n[r].useCount = 0;
					return this
				},
				update: function(e) {
					e *= this.timeScale;
					for (var t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) t[a]._update(i, e, r, o);
					for (var s = this._bindings, c = this._nActiveBindings, a = 0; a !== c; ++a) s[a].apply(o);
					return this
				},
				getRoot: function() {
					return this._root
				},
				uncacheClip: function(e) {
					var t = this._actions,
						n = e.uuid,
						i = this._actionsByClip,
						r = i[n];
					if (void 0 !== r) {
						for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
							var c = o[a];
							this._deactivateAction(c);
							var l = c._cacheIndex,
								u = t[t.length - 1];
							c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = l, t[l] = u, t.pop(), this._removeInactiveBindingsForAction(c)
						}
						delete i[n]
					}
				},
				uncacheRoot: function(e) {
					var t = e.uuid,
						n = this._actionsByClip;
					for (var i in n) {
						var r = n[i].actionByRoot[t];
						void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
					}
					var o = this._bindingsByRootAndName[t];
					if (void 0 !== o)
						for (var a in o) {
							var s = o[a];
							s.restoreOriginalState(), this._removeInactiveBinding(s)
						}
				},
				uncacheAction: function(e, t) {
					var n = this.existingAction(e, t);
					null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
				}
			}), jr.prototype.clone = function() {
				return new jr(void 0 === this.value.clone ? this.value : this.value.clone())
			}, Or.prototype = Object.assign(Object.create(Te.prototype), {
				constructor: Or,
				isInstancedBufferGeometry: !0,
				copy: function(e) {
					return Te.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				}
			}), Object.defineProperties(Dr.prototype, {
				count: {
					get: function() {
						return this.data.count
					}
				},
				array: {
					get: function() {
						return this.data.array
					}
				}
			}), Object.assign(Dr.prototype, {
				isInterleavedBufferAttribute: !0,
				setX: function(e, t) {
					return this.data.array[e * this.data.stride + this.offset] = t, this
				},
				setY: function(e, t) {
					return this.data.array[e * this.data.stride + this.offset + 1] = t, this
				},
				setZ: function(e, t) {
					return this.data.array[e * this.data.stride + this.offset + 2] = t, this
				},
				setW: function(e, t) {
					return this.data.array[e * this.data.stride + this.offset + 3] = t, this
				},
				getX: function(e) {
					return this.data.array[e * this.data.stride + this.offset]
				},
				getY: function(e) {
					return this.data.array[e * this.data.stride + this.offset + 1]
				},
				getZ: function(e) {
					return this.data.array[e * this.data.stride + this.offset + 2]
				},
				getW: function(e) {
					return this.data.array[e * this.data.stride + this.offset + 3]
				},
				setXY: function(e, t, n) {
					return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
				},
				setXYZ: function(e, t, n, i) {
					return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
				},
				setXYZW: function(e, t, n, i, r) {
					return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
				}
			}), Object.defineProperty(Fr.prototype, "needsUpdate", {
				set: function(e) {
					!0 === e && this.version++
				}
			}), Object.assign(Fr.prototype, {
				isInterleavedBuffer: !0,
				setArray: function(e) {
					if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e
				},
				setDynamic: function(e) {
					return this.dynamic = e, this
				},
				copy: function(e) {
					return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
				},
				copyAt: function(e, t, n) {
					e *= this.stride, n *= t.stride;
					for (var i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
					return this
				},
				set: function(e, t) {
					return void 0 === t && (t = 0), this.array.set(e, t), this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				onUpload: function(e) {
					return this.onUploadCallback = e, this
				}
			}), Ur.prototype = Object.assign(Object.create(Fr.prototype), {
				constructor: Ur,
				isInstancedInterleavedBuffer: !0,
				copy: function(e) {
					return Fr.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
				}
			}), kr.prototype = Object.assign(Object.create(ve.prototype), {
				constructor: kr,
				isInstancedBufferAttribute: !0,
				copy: function(e) {
					return ve.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
				}
			}), Object.assign(Nr.prototype, {
				linePrecision: 1,
				set: function(e, t) {
					this.ray.set(e, t)
				},
				setFromCamera: function(e, t) {
					t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
				},
				intersectObject: function(e, t) {
					var n = [];
					return Gr(e, this, n, t), n.sort(Br), n
				},
				intersectObjects: function(e, t) {
					var n = [];
					if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
					for (var i = 0, r = e.length; i < r; i++) Gr(e[i], this, n, t);
					return n.sort(Br), n
				}
			}), Object.assign(Hr.prototype, {
				start: function() {
					this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
				},
				stop: function() {
					this.getElapsedTime(), this.running = !1, this.autoStart = !1
				},
				getElapsedTime: function() {
					return this.getDelta(), this.elapsedTime
				},
				getDelta: function() {
					var e = 0;
					if (this.autoStart && !this.running) return this.start(), 0;
					if (this.running) {
						var t = ("undefined" == typeof performance ? Date : performance).now();
						e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
					}
					return e
				}
			}), Object.assign(Vr.prototype, {
				set: function(e, t, n) {
					return this.radius = e, this.phi = t, this.theta = n, this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
				},
				makeSafe: function() {
					return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
				},
				setFromVector3: function(e) {
					return this.radius = e.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(gs.clamp(e.y / this.radius, -1, 1))), this
				}
			}), Object.assign(Wr.prototype, {
				set: function(e, t, n) {
					return this.radius = e, this.theta = t, this.y = n, this
				},
				clone: function() {
					return (new this.constructor).copy(this)
				},
				copy: function(e) {
					return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
				},
				setFromVector3: function(e) {
					return this.radius = Math.sqrt(e.x * e.x + e.z * e.z), this.theta = Math.atan2(e.x, e.z), this.y = e.y, this
				}
			}), (Yr.prototype = Object.create(le.prototype)).constructor = Yr, Yr.prototype.isImmediateRenderObject = !0, (Xr.prototype = Object.create(jt.prototype)).constructor = Xr, Xr.prototype.update = function() {
				var e = new o,
					t = new o,
					n = new a;
				return function() {
					var i = ["a", "b", "c"];
					this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
					var r = this.object.matrixWorld,
						o = this.geometry.attributes.position,
						a = this.object.geometry;
					if (a && a.isGeometry)
						for (var s = a.vertices, c = a.faces, l = 0, u = 0, h = c.length; u < h; u++)
							for (var d = c[u], f = 0, v = d.vertexNormals.length; f < v; f++) {
								var p = s[d[i[f]]],
									m = d.vertexNormals[f];
								e.copy(p).applyMatrix4(r), t.copy(m).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), o.setXYZ(l, e.x, e.y, e.z), l += 1, o.setXYZ(l, t.x, t.y, t.z), l += 1
							} else if (a && a.isBufferGeometry)
								for (var g = a.attributes.position, y = a.attributes.normal, l = 0, f = 0, v = g.count; f < v; f++) e.set(g.getX(f), g.getY(f), g.getZ(f)).applyMatrix4(r), t.set(y.getX(f), y.getY(f), y.getZ(f)), t.applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), o.setXYZ(l, e.x, e.y, e.z), l += 1, o.setXYZ(l, t.x, t.y, t.z), l += 1;
					o.needsUpdate = !0
				}
			}(), (qr.prototype = Object.create(le.prototype)).constructor = qr, qr.prototype.dispose = function() {
				this.cone.geometry.dispose(), this.cone.material.dispose()
			}, qr.prototype.update = function() {
				var e = new o,
					t = new o;
				return function() {
					this.light.updateMatrixWorld();
					var n = this.light.distance ? this.light.distance : 1e3,
						i = n * Math.tan(this.light.angle);
					this.cone.scale.set(i, i, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
				}
			}(), (Kr.prototype = Object.create(jt.prototype)).constructor = Kr, Kr.prototype.updateMatrixWorld = function() {
				var e = new o,
					t = new i,
					n = new i;
				return function(i) {
					var r = this.bones,
						o = this.geometry,
						a = o.getAttribute("position");
					n.getInverse(this.root.matrixWorld);
					for (var s = 0, c = 0; s < r.length; s++) {
						var l = r[s];
						l.parent && l.parent.isBone && (t.multiplyMatrices(n, l.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(c, e.x, e.y, e.z), t.multiplyMatrices(n, l.parent.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(c + 1, e.x, e.y, e.z), c += 2)
					}
					o.getAttribute("position").needsUpdate = !0, le.prototype.updateMatrixWorld.call(this, i)
				}
			}(), (Jr.prototype = Object.create(De.prototype)).constructor = Jr, Jr.prototype.dispose = function() {
				this.geometry.dispose(), this.material.dispose()
			}, Jr.prototype.update = function() {
				void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
			}, (Qr.prototype = Object.create(le.prototype)).constructor = Qr, Qr.prototype.dispose = function() {
				this.children[0].geometry.dispose(), this.children[0].material.dispose()
			}, Qr.prototype.update = function() {
				var e = .5 * this.light.width,
					t = .5 * this.light.height,
					n = this.line.geometry.attributes.position,
					i = n.array;
				i[0] = e, i[1] = -t, i[2] = 0, i[3] = e, i[4] = t, i[5] = 0, i[6] = -e, i[7] = t, i[8] = 0, i[9] = -e, i[10] = -t, i[11] = 0, i[12] = e, i[13] = -t, i[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
			}, ($r.prototype = Object.create(le.prototype)).constructor = $r, $r.prototype.dispose = function() {
				this.children[0].geometry.dispose(), this.children[0].material.dispose()
			}, $r.prototype.update = function() {
				var e = new o,
					t = new X,
					n = new X;
				return function() {
					var i = this.children[0];
					if (void 0 !== this.color) this.material.color.set(this.color);
					else {
						var r = i.geometry.getAttribute("color");
						t.copy(this.light.color), n.copy(this.light.groundColor);
						for (var o = 0, a = r.count; o < a; o++) {
							var s = o < a / 2 ? t : n;
							r.setXYZ(o, s.r, s.g, s.b)
						}
						r.needsUpdate = !0
					}
					i.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
				}
			}(), (eo.prototype = Object.create(jt.prototype)).constructor = eo, (to.prototype = Object.create(jt.prototype)).constructor = to, (no.prototype = Object.create(jt.prototype)).constructor = no, no.prototype.update = function() {
				var e = new o,
					t = new o,
					n = new a;
				return function() {
					this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
					for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, l = 0, u = s.length; l < u; l++) {
						var h = s[l],
							d = h.normal;
						e.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(i), t.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), r.setXYZ(c, e.x, e.y, e.z), c += 1, r.setXYZ(c, t.x, t.y, t.z), c += 1
					}
					r.needsUpdate = !0
				}
			}(), (io.prototype = Object.create(le.prototype)).constructor = io, io.prototype.dispose = function() {
				this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
			}, io.prototype.update = function() {
				var e = new o,
					t = new o,
					n = new o;
				return function() {
					e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n), this.targetLine.scale.z = n.length()
				}
			}(), (ro.prototype = Object.create(jt.prototype)).constructor = ro, ro.prototype.update = function() {
				function e(e, o, a, s) {
					i.set(o, a, s).unproject(r);
					var c = n[e];
					if (void 0 !== c)
						for (var l = t.getAttribute("position"), u = 0, h = c.length; u < h; u++) l.setXYZ(c[u], i.x, i.y, i.z)
				}
				var t, n, i = new o,
					r = new ue;
				return function() {
					t = this.geometry, n = this.pointMap;
					r.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
				}
			}(), oo.prototype = Object.create(jt.prototype), oo.prototype.constructor = oo, oo.prototype.update = function() {
				var e = new te;
				return function(t) {
					if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
						var n = e.min,
							i = e.max,
							r = this.geometry.attributes.position,
							o = r.array;
						o[0] = i.x, o[1] = i.y, o[2] = i.z, o[3] = n.x, o[4] = i.y, o[5] = i.z, o[6] = n.x, o[7] = n.y, o[8] = i.z, o[9] = i.x, o[10] = n.y, o[11] = i.z, o[12] = i.x, o[13] = i.y, o[14] = n.z, o[15] = n.x, o[16] = i.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = i.x, o[22] = n.y, o[23] = n.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
					}
				}
			}(), oo.prototype.setFromObject = function(e) {
				return this.object = e, this.update(), this
			}, (ao.prototype = Object.create(jt.prototype)).constructor = ao, ao.prototype.updateMatrixWorld = function(e) {
				var t = this.box;
				t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), le.prototype.updateMatrixWorld.call(this, e))
			}, (so.prototype = Object.create(It.prototype)).constructor = so, so.prototype.updateMatrixWorld = function(e) {
				var t = -this.plane.constant;
				Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.lookAt(this.plane.normal), le.prototype.updateMatrixWorld.call(this, e)
			};
			var nc, ic;
			(co.prototype = Object.create(le.prototype)).constructor = co, co.prototype.setDirection = function() {
				var e, t = new o;
				return function(n) {
					n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(n.z, 0, -n.x).normalize(), e = Math.acos(n.y), this.quaternion.setFromAxisAngle(t, e))
				}
			}(), co.prototype.setLength = function(e, t, n) {
				void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
			}, co.prototype.setColor = function(e) {
				this.line.material.color.copy(e), this.cone.material.color.copy(e)
			}, lo.prototype = Object.create(jt.prototype), lo.prototype.constructor = lo;
			var rc = {
				createMultiMaterialObject: function(e, t) {
					for (var n = new Ut, i = 0, r = t.length; i < r; i++) n.add(new De(e, t[i]));
					return n
				},
				detach: function(e, t, n) {
					e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
				},
				attach: function(e, t, n) {
					e.applyMatrix((new i).getInverse(n.matrixWorld)), t.remove(e), n.add(e)
				}
			};
			yi.create = function(e, t) {
				return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(yi.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
			}, Object.assign(Ni.prototype, {
				createPointsGeometry: function(e) {
					console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
					var t = this.getPoints(e);
					return this.createGeometry(t)
				},
				createSpacedPointsGeometry: function(e) {
					console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
					var t = this.getSpacedPoints(e);
					return this.createGeometry(t)
				},
				createGeometry: function(e) {
					console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
					for (var t = new fe, n = 0, i = e.length; n < i; n++) {
						var r = e[n];
						t.vertices.push(new o(r.x, r.y, r.z || 0))
					}
					return t
				}
			}), Object.assign(Bi.prototype, {
				fromPoints: function(e) {
					console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
				}
			}), uo.prototype = Object.create(Mi.prototype), ho.prototype = Object.create(Mi.prototype), fo.prototype = Object.create(Mi.prototype), Object.assign(fo.prototype, {
				initFromArray: function() {
					console.error("THREE.Spline: .initFromArray() has been removed.")
				},
				getControlPointsArray: function() {
					console.error("THREE.Spline: .getControlPointsArray() has been removed.")
				},
				reparametrizeByArcLength: function() {
					console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
				}
			}), eo.prototype.setColors = function() {
				console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
			}, Kr.prototype.update = function() {
				console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
			}, Object.assign(vr.prototype, {
				extractUrlBase: function(e) {
					return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ks.extractUrlBase(e)
				}
			}), Object.assign(q.prototype, {
				center: function(e) {
					return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
				},
				empty: function() {
					return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
				},
				isIntersectionBox: function(e) {
					return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
				},
				size: function(e) {
					return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
				}
			}), Object.assign(te.prototype, {
				center: function(e) {
					return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
				},
				empty: function() {
					return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
				},
				isIntersectionBox: function(e) {
					return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
				},
				isIntersectionSphere: function(e) {
					return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
				},
				size: function(e) {
					return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
				}
			}), je.prototype.center = function(e) {
				return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
			}, Object.assign(gs, {
				random16: function() {
					return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
				},
				nearestPowerOfTwo: function(e) {
					return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), gs.floorPowerOfTwo(e)
				},
				nextPowerOfTwo: function(e) {
					return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), gs.ceilPowerOfTwo(e)
				}
			}), Object.assign(a.prototype, {
				flattenToArrayOffset: function(e, t) {
					return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
				},
				multiplyVector3: function(e) {
					return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
				},
				multiplyVector3Array: function() {
					console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
				},
				applyToBuffer: function(e) {
					return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
				},
				applyToVector3Array: function() {
					console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
				}
			}), Object.assign(i.prototype, {
				extractPosition: function(e) {
					return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
				},
				flattenToArrayOffset: function(e, t) {
					return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
				},
				getPosition: function() {
					var e;
					return function() {
						return void 0 === e && (e = new o), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
					}
				}(),
				setRotationFromQuaternion: function(e) {
					return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
				},
				multiplyToArray: function() {
					console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
				},
				multiplyVector3: function(e) {
					return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
				},
				multiplyVector4: function(e) {
					return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
				},
				multiplyVector3Array: function() {
					console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
				},
				rotateAxis: function(e) {
					console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
				},
				crossVector: function(e) {
					return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
				},
				translate: function() {
					console.error("THREE.Matrix4: .translate() has been removed.")
				},
				rotateX: function() {
					console.error("THREE.Matrix4: .rotateX() has been removed.")
				},
				rotateY: function() {
					console.error("THREE.Matrix4: .rotateY() has been removed.")
				},
				rotateZ: function() {
					console.error("THREE.Matrix4: .rotateZ() has been removed.")
				},
				rotateByAxis: function() {
					console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
				},
				applyToBuffer: function(e) {
					return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
				},
				applyToVector3Array: function() {
					console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
				},
				makeFrustum: function(e, t, n, i, r, o) {
					return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, o)
				}
			}), ie.prototype.isIntersectionLine = function(e) {
				return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
			}, r.prototype.multiplyVector3 = function(e) {
				return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
			}, Object.assign(Ie.prototype, {
				isIntersectionBox: function(e) {
					return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
				},
				isIntersectionPlane: function(e) {
					return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
				},
				isIntersectionSphere: function(e) {
					return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
				}
			}), Object.assign(Gi.prototype, {
				extractAllPoints: function(e) {
					return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
				},
				extrude: function(e) {
					return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Dn(this, e)
				},
				makeGeometry: function(e) {
					return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Yn(this, e)
				}
			}), Object.assign(n.prototype, {
				fromAttribute: function(e, t, n) {
					return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
				},
				distanceToManhattan: function(e) {
					return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
				},
				lengthManhattan: function() {
					return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
				}
			}), Object.assign(o.prototype, {
				setEulerFromRotationMatrix: function() {
					console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
				},
				setEulerFromQuaternion: function() {
					console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
				},
				getPositionFromMatrix: function(e) {
					return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
				},
				getScaleFromMatrix: function(e) {
					return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
				},
				getColumnFromMatrix: function(e, t) {
					return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
				},
				applyProjection: function(e) {
					return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
				},
				fromAttribute: function(e, t, n) {
					return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
				},
				distanceToManhattan: function(e) {
					return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
				},
				lengthManhattan: function() {
					return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
				}
			}), Object.assign(c.prototype, {
				fromAttribute: function(e, t, n) {
					return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
				},
				lengthManhattan: function() {
					return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
				}
			}), fe.prototype.computeTangents = function() {
				console.warn("THREE.Geometry: .computeTangents() has been removed.")
			}, Object.assign(le.prototype, {
				getChildByName: function(e) {
					return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
				},
				renderDepth: function() {
					console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
				},
				translate: function(e, t) {
					return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
				}
			}), Object.defineProperties(le.prototype, {
				eulerOrder: {
					get: function() {
						return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
					},
					set: function(e) {
						console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
					}
				},
				useQuaternion: {
					get: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					},
					set: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					}
				}
			}), Object.defineProperties(At.prototype, {
				objects: {
					get: function() {
						return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
					}
				}
			}), Object.defineProperty(Lt.prototype, "useVertexTexture", {
				get: function() {
					console.warn("THREE.Skeleton: useVertexTexture has been removed.")
				},
				set: function() {
					console.warn("THREE.Skeleton: useVertexTexture has been removed.")
				}
			}), Object.defineProperty(yi.prototype, "__arcLengthDivisions", {
				get: function() {
					return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
				},
				set: function(e) {
					console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
				}
			}), pt.prototype.setLens = function(e, t) {
				console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
			}, Object.defineProperties(Hi.prototype, {
				onlyShadow: {
					set: function() {
						console.warn("THREE.Light: .onlyShadow has been removed.")
					}
				},
				shadowCameraFov: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
					}
				},
				shadowCameraLeft: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
					}
				},
				shadowCameraRight: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
					}
				},
				shadowCameraTop: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
					}
				},
				shadowCameraBottom: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
					}
				},
				shadowCameraNear: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
					}
				},
				shadowCameraFar: {
					set: function(e) {
						console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
					}
				},
				shadowCameraVisible: {
					set: function() {
						console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
					}
				},
				shadowBias: {
					set: function(e) {
						console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
					}
				},
				shadowDarkness: {
					set: function() {
						console.warn("THREE.Light: .shadowDarkness has been removed.")
					}
				},
				shadowMapWidth: {
					set: function(e) {
						console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
					}
				},
				shadowMapHeight: {
					set: function(e) {
						console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
					}
				}
			}), Object.defineProperties(ve.prototype, {
				length: {
					get: function() {
						return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
					}
				}
			}), Object.assign(Te.prototype, {
				addIndex: function(e) {
					console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
				},
				addDrawCall: function(e, t, n) {
					void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
				},
				clearDrawCalls: function() {
					console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
				},
				computeTangents: function() {
					console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
				},
				computeOffsets: function() {
					console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
				}
			}), Object.defineProperties(Te.prototype, {
				drawcalls: {
					get: function() {
						return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
					}
				},
				offsets: {
					get: function() {
						return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
					}
				}
			}), Object.defineProperties(jr.prototype, {
				dynamic: {
					set: function() {
						console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
					}
				},
				onUpdate: {
					value: function() {
						return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
					}
				}
			}), Object.defineProperties(Q.prototype, {
				wrapAround: {
					get: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					},
					set: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					}
				},
				wrapRGB: {
					get: function() {
						return console.warn("THREE.Material: .wrapRGB has been removed."), new X
					}
				},
				shading: {
					get: function() {
						console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
					},
					set: function(e) {
						console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
					}
				}
			}), Object.defineProperties(ai.prototype, {
				metal: {
					get: function() {
						return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
					},
					set: function() {
						console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
					}
				}
			}), Object.defineProperties(Re.prototype, {
				derivatives: {
					get: function() {
						return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
					},
					set: function(e) {
						console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
					}
				}
			}), Object.assign(wt.prototype, {
				getCurrentRenderTarget: function() {
					return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
				},
				getMaxAnisotropy: function() {
					return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
				},
				getPrecision: function() {
					return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
				},
				resetGLState: function() {
					return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
				},
				supportsFloatTextures: function() {
					return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
				},
				supportsHalfFloatTextures: function() {
					return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
				},
				supportsStandardDerivatives: function() {
					return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
				},
				supportsCompressedTextureS3TC: function() {
					return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
				},
				supportsCompressedTexturePVRTC: function() {
					return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
				},
				supportsBlendMinMax: function() {
					return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
				},
				supportsVertexTextures: function() {
					return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
				},
				supportsInstancedArrays: function() {
					return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
				},
				enableScissorTest: function(e) {
					console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
				},
				initMaterial: function() {
					console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
				},
				addPrePlugin: function() {
					console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
				},
				addPostPlugin: function() {
					console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
				},
				updateShadowMap: function() {
					console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
				}
			}), Object.defineProperties(wt.prototype, {
				shadowMapEnabled: {
					get: function() {
						return this.shadowMap.enabled
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
					}
				},
				shadowMapType: {
					get: function() {
						return this.shadowMap.type
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
					}
				},
				shadowMapCullFace: {
					get: function() {
						return this.shadowMap.cullFace
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = e
					}
				}
			}), Object.defineProperties(oe.prototype, {
				cullFace: {
					get: function() {
						return this.renderReverseSided ? yo : go
					},
					set: function(e) {
						var t = e !== go;
						console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + t + "."), this.renderReverseSided = t
					}
				}
			}), Object.defineProperties(l.prototype, {
				wrapS: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
					}
				},
				wrapT: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
					}
				},
				magFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
					}
				},
				minFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
					}
				},
				anisotropy: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
					}
				},
				offset: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
					}
				},
				repeat: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
					}
				},
				format: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
					}
				},
				type: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
					}
				},
				generateMipmaps: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
					},
					set: function(e) {
						console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
					}
				}
			}), Object.assign(gt.prototype, {
				getStandingMatrix: function() {
					console.warn("THREE.WebVRManager: .getStandingMatrix() has been removed.")
				}
			}), Object.defineProperties(gt.prototype, {
				standing: {
					set: function() {
						console.warn("THREE.WebVRManager: .standing has been removed.")
					}
				}
			}), Er.prototype.load = function(e) {
				console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
				var t = this;
				return (new wr).load(e, function(e) {
					t.setBuffer(e)
				}), this
			}, Pr.prototype.getData = function() {
				return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
			}, _r.prototype.updateCubeMap = function(e, t) {
				return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
			};
			var oc = {
					merge: function(e, t, n) {
						console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
						var i;
						t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), i = t.matrix, t = t.geometry), e.merge(t, i, n)
					},
					center: function(e) {
						return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
					}
				},
				ac = {
					crossOrigin: void 0,
					loadTexture: function(e, t, n, i) {
						console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
						var r = new gi;
						r.setCrossOrigin(this.crossOrigin);
						var o = r.load(e, n, void 0, i);
						return t && (o.mapping = t), o
					},
					loadTextureCube: function(e, t, n, i) {
						console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
						var r = new mi;
						r.setCrossOrigin(this.crossOrigin);
						var o = r.load(e, n, void 0, i);
						return t && (o.mapping = t), o
					},
					loadCompressedTexture: function() {
						console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
					},
					loadCompressedTextureCube: function() {
						console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
					}
				};
			e.WebGLRenderTargetCube = u, e.WebGLRenderTarget = l, e.WebGLRenderer = wt, e.ShaderLib = Cs, e.UniformsLib = Ps, e.UniformsUtils = As, e.ShaderChunk = Ls, e.FogExp2 = Mt, e.Fog = _t, e.Scene = St, e.LensFlare = Et, e.Sprite = Pt, e.LOD = At, e.SkinnedMesh = zt, e.Skeleton = Lt, e.Bone = Ct, e.Mesh = De, e.LineSegments = jt, e.LineLoop = Ot, e.Line = It, e.Points = Ft, e.Group = Ut, e.VideoTexture = kt, e.DataTexture = h, e.CompressedTexture = Nt, e.CubeTexture = d, e.CanvasTexture = K, e.DepthTexture = Bt, e.Texture = s, e.CompressedTextureLoader = fi, e.DataTextureLoader = vi, e.CubeTextureLoader = mi, e.TextureLoader = gi, e.ObjectLoader = mr, e.MaterialLoader = dr, e.BufferGeometryLoader = fr, e.DefaultLoadingManager = Bs, e.LoadingManager = hi, e.JSONLoader = pr, e.ImageLoader = pi, e.ImageBitmapLoader = gr, e.FontLoader = br, e.FileLoader = di, e.Loader = vr, e.LoaderUtils = Ks, e.Cache = Ns, e.AudioLoader = wr, e.SpotLightShadow = Yi, e.SpotLight = Xi, e.PointLight = qi, e.RectAreaLight = Qi, e.HemisphereLight = Vi, e.DirectionalLightShadow = Zi, e.DirectionalLight = Ki, e.AmbientLight = Ji, e.LightShadow = Wi, e.Light = Hi, e.StereoCamera = Mr, e.PerspectiveCamera = pt, e.OrthographicCamera = he, e.CubeCamera = _r, e.ArrayCamera = mt, e.Camera = ue, e.AudioListener = Sr, e.PositionalAudio = Tr, e.AudioContext = tc, e.AudioAnalyser = Pr, e.Audio = Er, e.VectorKeyframeTrack = ur, e.StringKeyframeTrack = $i, e.QuaternionKeyframeTrack = ir, e.NumberKeyframeTrack = or, e.ColorKeyframeTrack = rr, e.BooleanKeyframeTrack = er, e.PropertyMixer = Ar, e.PropertyBinding = Cr, e.KeyframeTrack = lr, e.AnimationUtils = qs, e.AnimationObjectGroup = zr, e.AnimationMixer = Ir, e.AnimationClip = hr, e.Uniform = jr, e.InstancedBufferGeometry = Or, e.BufferGeometry = Te, e.Geometry = fe, e.InterleavedBufferAttribute = Dr, e.InstancedInterleavedBuffer = Ur, e.InterleavedBuffer = Fr, e.InstancedBufferAttribute = kr, e.Face3 = de, e.Object3D = le, e.Raycaster = Nr, e.Layers = ce, e.EventDispatcher = t, e.Clock = Hr, e.QuaternionLinearInterpolant = nr, e.LinearInterpolant = sr, e.DiscreteInterpolant = cr, e.CubicInterpolant = ar, e.Interpolant = tr, e.Triangle = Oe, e.Math = gs, e.Spherical = Vr, e.Cylindrical = Wr, e.Plane = ie, e.Frustum = re, e.Sphere = ne, e.Ray = Ie, e.Matrix4 = i, e.Matrix3 = a, e.Box3 = te, e.Box2 = q, e.Line3 = je, e.Euler = se, e.Vector4 = c, e.Vector3 = o, e.Vector2 = n, e.Quaternion = r, e.Color = X, e.ImmediateRenderObject = Yr, e.VertexNormalsHelper = Xr, e.SpotLightHelper = qr, e.SkeletonHelper = Kr, e.PointLightHelper = Jr, e.RectAreaLightHelper = Qr, e.HemisphereLightHelper = $r, e.GridHelper = eo, e.PolarGridHelper = to, e.FaceNormalsHelper = no, e.DirectionalLightHelper = io, e.CameraHelper = ro, e.BoxHelper = oo, e.Box3Helper = ao, e.PlaneHelper = so, e.ArrowHelper = co, e.AxesHelper = lo, e.Shape = Gi, e.Path = Bi, e.ShapePath = yr, e.Font = xr, e.CurvePath = Ni, e.Curve = yi, e.ShapeUtils = Fs, e.SceneUtils = rc, e.WebGLUtils = bt, e.WireframeGeometry = Gt, e.ParametricGeometry = Ht, e.ParametricBufferGeometry = Vt, e.TetrahedronGeometry = Xt, e.TetrahedronBufferGeometry = qt, e.OctahedronGeometry = Zt, e.OctahedronBufferGeometry = Kt, e.IcosahedronGeometry = Jt, e.IcosahedronBufferGeometry = Qt, e.DodecahedronGeometry = $t, e.DodecahedronBufferGeometry = en, e.PolyhedronGeometry = Wt, e.PolyhedronBufferGeometry = Yt, e.TubeGeometry = tn, e.TubeBufferGeometry = nn, e.TorusKnotGeometry = rn, e.TorusKnotBufferGeometry = on, e.TorusGeometry = an, e.TorusBufferGeometry = sn, e.TextGeometry = Un, e.TextBufferGeometry = kn, e.SphereGeometry = Nn, e.SphereBufferGeometry = Bn, e.RingGeometry = Gn, e.RingBufferGeometry = Hn, e.PlaneGeometry = Le, e.PlaneBufferGeometry = Ce, e.LatheGeometry = Vn, e.LatheBufferGeometry = Wn, e.ShapeGeometry = Yn, e.ShapeBufferGeometry = Xn, e.ExtrudeGeometry = Dn, e.ExtrudeBufferGeometry = Fn, e.EdgesGeometry = Zn, e.ConeGeometry = Qn, e.ConeBufferGeometry = $n, e.CylinderGeometry = Kn, e.CylinderBufferGeometry = Jn, e.CircleGeometry = ei, e.CircleBufferGeometry = ti, e.BoxGeometry = Pe, e.BoxBufferGeometry = Ae, e.ShadowMaterial = ni, e.SpriteMaterial = Tt, e.RawShaderMaterial = ii, e.ShaderMaterial = Re, e.PointsMaterial = Dt, e.MeshPhysicalMaterial = oi, e.MeshStandardMaterial = ri, e.MeshPhongMaterial = ai, e.MeshToonMaterial = si, e.MeshNormalMaterial = ci, e.MeshLambertMaterial = li, e.MeshDepthMaterial = $, e.MeshDistanceMaterial = ee, e.MeshBasicMaterial = ze, e.LineDashedMaterial = ui, e.LineBasicMaterial = Rt, e.Material = Q, e.Float64BufferAttribute = _e, e.Float32BufferAttribute = Me, e.Uint32BufferAttribute = we, e.Int32BufferAttribute = be, e.Uint16BufferAttribute = xe, e.Int16BufferAttribute = ye, e.Uint8ClampedBufferAttribute = ge, e.Uint8BufferAttribute = me, e.Int8BufferAttribute = pe, e.BufferAttribute = ve, e.ArcCurve = bi, e.CatmullRomCurve3 = Mi, e.CubicBezierCurve = Ii, e.CubicBezierCurve3 = ji, e.EllipseCurve = xi, e.LineCurve = Oi, e.LineCurve3 = Di, e.QuadraticBezierCurve = Fi, e.QuadraticBezierCurve3 = Ui, e.SplineCurve = ki, e.REVISION = vo, e.MOUSE = po, e.CullFaceNone = mo, e.CullFaceBack = go, e.CullFaceFront = yo, e.CullFaceFrontBack = 3, e.FrontFaceDirectionCW = xo, e.FrontFaceDirectionCCW = 1, e.BasicShadowMap = 0, e.PCFShadowMap = bo, e.PCFSoftShadowMap = wo, e.FrontSide = Mo, e.BackSide = _o, e.DoubleSide = So, e.FlatShading = 1, e.SmoothShading = 2, e.NoColors = Eo, e.FaceColors = To, e.VertexColors = Po, e.NoBlending = Ao, e.NormalBlending = Lo, e.AdditiveBlending = Co, e.SubtractiveBlending = zo, e.MultiplyBlending = Ro, e.CustomBlending = Io, e.AddEquation = jo, e.SubtractEquation = Oo, e.ReverseSubtractEquation = Do, e.MinEquation = Fo, e.MaxEquation = Uo, e.ZeroFactor = ko, e.OneFactor = No, e.SrcColorFactor = Bo, e.OneMinusSrcColorFactor = Go, e.SrcAlphaFactor = Ho, e.OneMinusSrcAlphaFactor = Vo, e.DstAlphaFactor = Wo, e.OneMinusDstAlphaFactor = Yo, e.DstColorFactor = Xo, e.OneMinusDstColorFactor = qo, e.SrcAlphaSaturateFactor = Zo, e.NeverDepth = Ko, e.AlwaysDepth = Jo, e.LessDepth = Qo, e.LessEqualDepth = $o, e.EqualDepth = ea, e.GreaterEqualDepth = ta, e.GreaterDepth = na, e.NotEqualDepth = ia, e.MultiplyOperation = ra, e.MixOperation = oa, e.AddOperation = aa, e.NoToneMapping = sa, e.LinearToneMapping = ca, e.ReinhardToneMapping = la, e.Uncharted2ToneMapping = ua, e.CineonToneMapping = ha, e.UVMapping = 300, e.CubeReflectionMapping = da, e.CubeRefractionMapping = fa, e.EquirectangularReflectionMapping = va, e.EquirectangularRefractionMapping = pa, e.SphericalReflectionMapping = ma, e.CubeUVReflectionMapping = ga, e.CubeUVRefractionMapping = ya, e.RepeatWrapping = xa, e.ClampToEdgeWrapping = ba, e.MirroredRepeatWrapping = wa, e.NearestFilter = Ma, e.NearestMipMapNearestFilter = _a, e.NearestMipMapLinearFilter = Sa, e.LinearFilter = Ea, e.LinearMipMapNearestFilter = Ta, e.LinearMipMapLinearFilter = Pa, e.UnsignedByteType = Aa, e.ByteType = La, e.ShortType = Ca, e.UnsignedShortType = za, e.IntType = Ra, e.UnsignedIntType = Ia, e.FloatType = ja, e.HalfFloatType = Oa, e.UnsignedShort4444Type = Da, e.UnsignedShort5551Type = Fa, e.UnsignedShort565Type = Ua, e.UnsignedInt248Type = ka, e.AlphaFormat = Na, e.RGBFormat = Ba, e.RGBAFormat = Ga, e.LuminanceFormat = Ha, e.LuminanceAlphaFormat = Va, e.RGBEFormat = Wa, e.DepthFormat = Ya, e.DepthStencilFormat = Xa, e.RGB_S3TC_DXT1_Format = qa, e.RGBA_S3TC_DXT1_Format = Za, e.RGBA_S3TC_DXT3_Format = Ka, e.RGBA_S3TC_DXT5_Format = Ja, e.RGB_PVRTC_4BPPV1_Format = Qa, e.RGB_PVRTC_2BPPV1_Format = $a, e.RGBA_PVRTC_4BPPV1_Format = es, e.RGBA_PVRTC_2BPPV1_Format = ts, e.RGB_ETC1_Format = ns, e.LoopOnce = 2200, e.LoopRepeat = is, e.LoopPingPong = 2202, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.ZeroCurvatureEnding = rs, e.ZeroSlopeEnding = 2401, e.WrapAroundEnding = 2402, e.TrianglesDrawMode = os, e.TriangleStripDrawMode = as, e.TriangleFanDrawMode = ss, e.LinearEncoding = cs, e.sRGBEncoding = ls, e.GammaEncoding = us, e.RGBEEncoding = hs, e.LogLuvEncoding = 3003, e.RGBM7Encoding = ds, e.RGBM16Encoding = fs, e.RGBDEncoding = vs, e.BasicDepthPacking = ps, e.RGBADepthPacking = ms, e.CubeGeometry = Pe, e.Face4 = function(e, t, n, i, r, o, a) {
				return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new de(e, t, n, r, o, a)
			}, e.LineStrip = 0, e.LinePieces = 1, e.MeshFaceMaterial = function(e) {
				return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
			}, e.MultiMaterial = function(e) {
				return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
					return e.slice()
				}, e
			}, e.PointCloud = function(e, t) {
				return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ft(e, t)
			}, e.Particle = function(e) {
				return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Pt(e)
			}, e.ParticleSystem = function(e, t) {
				return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ft(e, t)
			}, e.PointCloudMaterial = function(e) {
				return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Dt(e)
			}, e.ParticleBasicMaterial = function(e) {
				return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Dt(e)
			}, e.ParticleSystemMaterial = function(e) {
				return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Dt(e)
			}, e.Vertex = function(e, t, n) {
				return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new o(e, t, n)
			}, e.DynamicBufferAttribute = function(e, t) {
				return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ve(e, t).setDynamic(!0)
			}, e.Int8Attribute = function(e, t) {
				return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new pe(e, t)
			}, e.Uint8Attribute = function(e, t) {
				return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new me(e, t)
			}, e.Uint8ClampedAttribute = function(e, t) {
				return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new ge(e, t)
			}, e.Int16Attribute = function(e, t) {
				return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new ye(e, t)
			}, e.Uint16Attribute = function(e, t) {
				return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new xe(e, t)
			}, e.Int32Attribute = function(e, t) {
				return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new be(e, t)
			}, e.Uint32Attribute = function(e, t) {
				return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new we(e, t)
			}, e.Float32Attribute = function(e, t) {
				return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Me(e, t)
			}, e.Float64Attribute = function(e, t) {
				return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new _e(e, t)
			}, e.ClosedSplineCurve3 = uo, e.SplineCurve3 = ho, e.Spline = fo, e.AxisHelper = function(e) {
				return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new lo(e)
			}, e.BoundingBoxHelper = function(e, t) {
				return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new oo(e, t)
			}, e.EdgesHelper = function(e, t) {
				return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new jt(new Zn(e.geometry), new Rt({
					color: void 0 !== t ? t : 16777215
				}))
			}, e.WireframeHelper = function(e, t) {
				return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new jt(new Gt(e.geometry), new Rt({
					color: void 0 !== t ? t : 16777215
				}))
			}, e.XHRLoader = function(e) {
				return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new di(e)
			}, e.BinaryTextureLoader = function(e) {
				return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new vi(e)
			}, e.GeometryUtils = oc, e.ImageUtils = ac, e.Projector = function() {
				console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
					console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
				}, this.unprojectVector = function(e, t) {
					console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
				}, this.pickingRay = function() {
					console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
				}
			}, e.CanvasRenderer = function() {
				console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
			}, Object.defineProperty(e, "__esModule", {
				value: !0
			})
		})
	}, {}],
	9: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				i = e("../modules/old/ForceCamera"),
				c = document.getElementById("canvas-webgl"),
				l = new a.WebGLRenderer({
					antialias: !0,
					canvas: c
				}),
				u = new a.Scene,
				h = new i(35, window.innerWidth / window.innerHeight, 1, 1e4),
				d = (new a.Clock, null),
				f = function() {
					for (var e = new a.BufferGeometry, i = [], r = [], o = [], s = [], c = 0; c < Math.pow(1e3, 2); c++) i.push(0, 0, 0), r.push(c % 1e3 * (1 / 999), Math.floor(c / 1e3) * (1 / 999)), o.push(n.getRandomInt(0, 120) / 360, .8, 1), s.push(n.getRandomInt(1, 100));
					var l = new Float32Array(i);
					e.addAttribute("position", new a.BufferAttribute(l, 3));
					var u = new Float32Array(r);
					e.addAttribute("uv2", new a.BufferAttribute(u, 2));
					var h = new Float32Array(o);
					e.addAttribute("color", new a.BufferAttribute(h, 3));
					var d = new Float32Array(s);
					e.addAttribute("mass", new a.BufferAttribute(d, 1));
					var f = new a.ShaderMaterial({
						uniforms: {
							time: {
								type: "f",
								value: 0
							},
							velocity: {
								type: "t",
								value: new a.Texture
							},
							acceleration: {
								type: "t",
								value: new a.Texture
							}
						},
						vertexShader: t(["#define GLSLIFY 1\nattribute vec2 uv2;\nattribute vec3 color;\nattribute float mass;\n\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\n\nvarying float vAcceleration;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main(void) {\n  vec4 update_position = modelViewMatrix * texture2D(velocity, uv2);\n  vAcceleration = length(texture2D(acceleration, uv2).xyz) * mass;\n  vColor = color;\n  vOpacity = 0.6 * (300.0 / length(update_position.xyz));\n  gl_PointSize = 2.0 * (300.0 / length(update_position.xyz));\n  gl_Position = projectionMatrix * update_position;\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nvarying float vAcceleration;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nuniform float time;\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(hsv2rgb(vec3(vColor.x + time / 3600.0, vColor.y, vColor.z)), vOpacity);\n}\n"]),
						transparent: !0,
						depthWrite: !1,
						blending: a.AdditiveBlending
					});
					return new a.Points(e, f)
				}(),
				v = function() {
					for (var e = [], t = 0; t < Math.pow(1e3, 2); t++) {
						var i = n.getPolarCoord(n.getRadian(n.getRandomInt(0, 360)), n.getRadian(n.getRandomInt(0, 360)), n.getRandomInt(10, 1e3));
						e.push(i.x, i.y / 10, i.z)
					}
					return e
				},
				p = function() {
					(d = new o.default(t(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]), t(["#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform vec2 anchor;\n\nvarying vec2 vUv;\n\n#define PRECISION 0.000001\n\n#ifndef PRECISION\n#define PRECISION 0.000001\n#endif\n\nvec3 drag(vec3 a, float value) {\n  return normalize(a * -1.0 + PRECISION) * length(a) * value;\n}\n\nvoid main(void) {\n  vec3 v = texture2D(velocity, vUv).xyz;\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  vec3 a2 = a + normalize(vec3(\n    anchor.x * resolution.x / 6.0 + PRECISION,\n    0.0,\n    anchor.y * resolution.y / -2.0 + PRECISION\n  ) - v) / 2.0;\n  vec3 a3 = a2 + drag(a2, 0.003);\n  gl_FragColor = vec4(a3, 1.0);\n}\n"]), t(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]), t(["#define GLSLIFY 1\nuniform float time;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  gl_FragColor = vec4(texture2D(acceleration, vUv).xyz + texture2D(velocity, vUv).xyz, 1.0);\n}\n"]))).init(l, v()), d.accelerationMesh.material.uniforms.anchor = {
						type: "v2",
						value: new a.Vector2
					}, u.add(f), h.force.position.anchor.set(0, 15, 600), h.force.look.anchor.set(0, 0, 0)
				},
				m = function() {
					c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), l.setSize(window.innerWidth, window.innerHeight)
				},
				g = function() {
					d.render(l), f.material.uniforms.time.value++, f.material.uniforms.velocity.value = d.getCurrentVelocity(), f.material.uniforms.acceleration.value = d.getCurrentAcceleration(), h.force.position.applyHook(0, .025), h.force.position.applyDrag(.2), h.force.position.updateVelocity(), h.updatePosition(), h.force.look.applyHook(0, .2), h.force.look.applyDrag(.4), h.force.look.updateVelocity(), h.updateLook(), l.render(u, h)
				},
				y = function e() {
					g(), requestAnimationFrame(e)
				},
				x = function() {
					var e = new a.Vector2,
						t = new a.Vector2,
						n = new a.Vector2,
						i = function(t, n, i) {
							e.set(t, n), (0, r.default)(e)
						},
						o = function(e, n, i) {
							t.set(e, n), (0, r.default)(t), d.accelerationMesh.material.uniforms.anchor.value.copy(t)
						},
						l = function(e, t, i) {
							n.set(e, t)
						},
						u = function() {
							n.set(0, 0), d.accelerationMesh.material.uniforms.anchor.value.set(0, 0, 0)
						};
					window.addEventListener("resize", s(function() {
						m()
					}), 1e3), c.addEventListener("mousedown", function(e) {
						e.preventDefault(), i(e.clientX, e.clientY)
					}), c.addEventListener("mousemove", function(e) {
						e.preventDefault(), o(e.clientX, e.clientY)
					}), c.addEventListener("mouseup", function(e) {
						e.preventDefault(), l(e.clientX, e.clientY)
					}), c.addEventListener("touchstart", function(e) {
						e.preventDefault(), i(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchmove", function(e) {
						e.preventDefault(), o(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchend", function(e) {
						e.preventDefault(), l(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), u()
					})
				};
			l.setSize(window.innerWidth, window.innerHeight), l.setClearColor(1118481, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new a.Vector3), x(), p(), m(), y()
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/common/PhysicsRenderer")),
			a = e("three/build/three.js"),
			s = e("js-util/debounce")
	}, {
		"../modules/common/PhysicsRenderer": 40,
		"../modules/common/normalizeVector2": 43,
		"../modules/old/ForceCamera": 54,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	10: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = document.getElementById("canvas-webgl"),
				n = new i.WebGLRenderer({
					antialias: !0,
					canvas: t
				}),
				a = new i.Scene,
				s = new i.PerspectiveCamera(120, 1, 1, 1e4),
				c = new i.Clock,
				l = new i.Vector2,
				u = new i.Vector2,
				h = new i.Vector2,
				d = !1,
				f = new o,
				v = function() {
					var e = c.getDelta();
					f.render(e), n.render(a, s)
				},
				p = function e() {
					v(), requestAnimationFrame(e)
				},
				m = function() {
					s.aspect = e.x / e.y, s.updateProjectionMatrix()
				},
				g = function() {
					e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, m(), n.setSize(e.x, e.y)
				},
				y = function(e) {
					d = !0
				},
				x = function(e) {},
				b = function(e) {
					d = !1
				};
			(function() {
				window.addEventListener("resize", r(g), 1e3), t.addEventListener("mousedown", function(e) {
					e.preventDefault(), l.set(e.clientX, e.clientY), y()
				}), document.addEventListener("mousemove", function(e) {
					e.preventDefault(), u.set(e.clientX, e.clientY), x()
				}), document.addEventListener("mouseup", function(e) {
					e.preventDefault(), h.set(e.clientX, e.clientY), b()
				}), t.addEventListener("touchstart", function(e) {
					e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY), y()
				}), t.addEventListener("touchmove", function(e) {
					e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), x()
				}), t.addEventListener("touchend", function(e) {
					e.preventDefault(), h.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), b()
				})
			})(), g(), f.createObj(), a.add(f.obj), n.setClearColor(921102, 1), s.position.set(0, 0, 100), s.lookAt(new i.Vector3(0, 0, 0)), p()
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("../modules/sketch/beam/Beam").default
	}, {
		"../modules/sketch/beam/Beam": 65,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	11: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = document.getElementById("canvas-webgl"),
				n = new i.WebGLRenderer({
					antialias: !1,
					canvas: t
				}),
				a = new i.Scene,
				s = new i.PerspectiveCamera(90, 1, 1, 1e4),
				c = new i.Clock,
				l = new i.Vector2,
				u = new i.Vector2,
				h = new i.Vector2,
				d = !1,
				f = new o,
				v = function() {
					var e = c.getDelta();
					f.render(e), n.render(a, s)
				},
				p = function e() {
					v(), requestAnimationFrame(e)
				},
				m = function() {
					s.aspect = e.x / e.y, s.updateProjectionMatrix()
				},
				g = function() {
					e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, m(), n.setSize(e.x, e.y)
				},
				y = function(e) {
					d = !0
				},
				x = function(e) {},
				b = function(e) {
					d = !1
				};
			(function() {
				window.addEventListener("resize", r(g), 1e3), t.addEventListener("mousedown", function(e) {
					e.preventDefault(), l.set(e.clientX, e.clientY), y()
				}), document.addEventListener("mousemove", function(e) {
					e.preventDefault(), u.set(e.clientX, e.clientY), x()
				}), document.addEventListener("mouseup", function(e) {
					e.preventDefault(), h.set(e.clientX, e.clientY), b()
				}), t.addEventListener("touchstart", function(e) {
					e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY), y()
				}), t.addEventListener("touchmove", function(e) {
					e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), x()
				}), t.addEventListener("touchend", function(e) {
					e.preventDefault(), h.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), b()
				})
			})(), g(), f.createObj(), a.add(f.obj), n.setClearColor(15329769, 1), s.position.set(10, 10, 50), s.lookAt(new i.Vector3), p()
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("../modules/sketch/blink/Points").default
	}, {
		"../modules/sketch/blink/Points": 66,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	12: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = {
					x: 0,
					y: 0
				},
				t = document.getElementById("canvas-webgl"),
				n = new h.WebGLRenderer({
					antialias: !1,
					canvas: t,
					alpha: !0
				}),
				i = new h.WebGLRenderTarget(0, 0),
				f = new h.WebGLRenderTarget(0, 0),
				v = new h.WebGLRenderTarget(0, 0),
				p = new h.Scene,
				m = new h.Scene,
				g = new h.OrthographicCamera(-1, 1, 1, -1, 0, 1),
				y = new h.PerspectiveCamera(30, 1, 1, 15e3),
				x = new h.Clock,
				b = new h.TextureLoader,
				w = new h.Vector2,
				M = new h.Vector2,
				_ = new h.Vector2,
				S = !1,
				E = [],
				T = new a.default(720),
				P = new s.default(e),
				A = new c.default(i.texture),
				L = new l.default(f.texture, 1, 0, 1),
				C = new l.default(v.texture, 0, 1, 1),
				z = new u.default(i.texture, f.texture),
				R = function() {
					y.aspect = e.x / e.y, y.updateProjectionMatrix(), P.resize(e)
				},
				I = function() {
					e.x = document.body.clientWidth, e.y = window.innerHeight, t.width = e.x, t.height = e.y, R(), L.resize(e), C.resize(e), i.setSize(e.x, e.y), f.setSize(e.x, e.y), v.setSize(e.x, e.y), n.setSize(e.x, e.y)
				},
				j = function() {
					for (var e = x.getDelta(), t = 0; t < E.length; t++) E[t].render(n, e);
					T.render(e), P.render(n, p, m, g, e), n.render(m, y, i), A.render(n, p, g, f), L.render(n, p, g, v), C.render(n, p, g, f), z.render(n, p, g)
				},
				O = function e() {
					j(), requestAnimationFrame(e)
				},
				D = function(e) {
					S = !0
				},
				F = function(e) {},
				U = function(e) {
					S = !1
				},
				k = function() {
					S = !1
				},
				N = function() {
					window.addEventListener("resize", d(I), 1e3), t.addEventListener("mousedown", function(e) {
						e.preventDefault(), w.set(e.clientX, e.clientY), (0, r.default)(w), D()
					}), t.addEventListener("mousemove", function(e) {
						e.preventDefault(), M.set(e.clientX, e.clientY), (0, r.default)(M), F()
					}), t.addEventListener("mouseup", function(e) {
						e.preventDefault(), _.set(e.clientX, e.clientY), (0, r.default)(_), U()
					}), t.addEventListener("touchstart", function(e) {
						e.preventDefault(), w.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(w), D(e.touches[0].clientX, e.touches[0].clientY)
					}), t.addEventListener("touchmove", function(e) {
						e.preventDefault(), M.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(M), F()
					}), t.addEventListener("touchend", function(e) {
						e.preventDefault(), _.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), (0, r.default)(_), U()
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), _.set(0, 0), k()
					})
				};
			I(), N(), n.setClearColor(15658734, 1), y.position.set(400, 500, 800), P.mirrorCamera.position.set(y.position.x, -1 * y.position.y, y.position.z), y.lookAt(new h.Vector3(0, 100, 0)), P.mirrorCamera.lookAt(new h.Vector3(0, -100, 0)), b.load("/sketch-threejs/img/sketch/butterfly/tex.png", function(e) {
				e.magFilter = h.NearestFilter, e.minFilter = h.NearestFilter;
				for (var t = 0; t < 12; t++) E[t] = new o.default(t, e), E[t].obj.position.x = 280 * (2 * Math.random() - 1), E[t].obj.position.z = 150 * t, m.add(E[t].obj);
				T.addButterflies(E), m.add(T.obj), P.add(p, m), p.add(A.obj), p.add(L.obj), p.add(C.obj), p.add(z.obj), O()
			})
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/sketch/butterfly/Butterfly")),
			a = i(e("../modules/sketch/butterfly/Points")),
			s = i(e("../modules/sketch/butterfly/Floor.js")),
			c = i(e("../modules/sketch/butterfly/PostEffectBright.js")),
			l = i(e("../modules/sketch/butterfly/PostEffectBlur.js")),
			u = i(e("../modules/sketch/butterfly/PostEffectBloom.js")),
			h = e("three/build/three.js"),
			d = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/butterfly/Butterfly": 67,
		"../modules/sketch/butterfly/Floor.js": 68,
		"../modules/sketch/butterfly/Points": 69,
		"../modules/sketch/butterfly/PostEffectBloom.js": 70,
		"../modules/sketch/butterfly/PostEffectBlur.js": 71,
		"../modules/sketch/butterfly/PostEffectBright.js": 72,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	13: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				a = e("../modules/old/Force2"),
				s = e("../modules/old/Mover"),
				c = e("../modules/old/Points.js"),
				l = e("../modules/old/ForceHemisphereLight"),
				u = e("../modules/old/ForcePointLight"),
				h = e("../modules/old/ForceCamera"),
				d = document.getElementById("canvas-webgl"),
				f = new r.WebGLRenderer({
					antialias: !0,
					canvas: d
				}),
				v = new r.Scene,
				p = new h(35, window.innerWidth / window.innerHeight, 1, 1e4),
				m = (new r.Clock, []),
				g = 2,
				y = new c,
				x = null,
				b = null,
				w = null,
				M = new Float32Array(3e4),
				_ = new Float32Array(3e4),
				S = new Float32Array(1e4),
				E = new Float32Array(1e4),
				T = null,
				P = new a,
				A = null,
				L = Date.now(),
				C = Date.now(),
				z = Date.now(),
				R = Date.now(),
				I = 0,
				j = !1,
				O = !1,
				D = !0,
				F = function() {
					for (var e = 0; e < m.length; e++) {
						var t = m[e];
						new r.Vector3;
						t.is_active && (t.time++, t.applyDrag(.1), t.updateVelocity(), t.time > 10 && (t.size -= 2), t.size <= 0 && (t.init(new r.Vector3(0, 0, 0)), t.time = 0, t.a = 0, t.inactivate())), M[3 * e + 0] = t.velocity.x - y.velocity.x, M[3 * e + 1] = t.velocity.y - y.velocity.y, M[3 * e + 2] = t.velocity.z - y.velocity.z, _[3 * e + 0] = t.color.r, _[3 * e + 1] = t.color.g, _[3 * e + 2] = t.color.b, S[e] = t.a, E[e] = t.size
					}
					y.updatePoints()
				},
				U = function() {
					var e = 0;
					if (Date.now() - L > 10) {
						for (var t = 0; t < m.length; t++) {
							var i = m[t];
							if (!i.is_active) {
								var r = n.getRadian(n.getRandomInt(0, 360)),
									o = n.getRadian(n.getRandomInt(0, 360)),
									a = n.getRandomInt(1, 30),
									s = n.getPolarCoord(r, o, a),
									c = n.getPolarCoord(r, o, a / 20),
									l = n.getRandomInt(95, 185) - I / 1.5,
									u = n.getRandomInt(60, 80);
								if (s.add(y.velocity), i.activate(), i.init(s), i.color.setHSL(l / 360, u / 100, .7), i.applyForce(c), i.a = 1, i.size = 25, ++e >= g) break
							}
						}
						L = Date.now()
					}
				},
				k = function() {
					return T.rotation.x += .03 + I / 1e3, T.rotation.y += .01 + I / 1e3, T.rotation.z += .01 + I / 1e3, y.rad1_base += n.getRadian(.6), y.rad1 = n.getRadian(45 * Math.sin(y.rad1_base) + I / 100), y.rad2 += n.getRadian(.8 + I / 100), y.rad3 += .01, n.getPolarCoord(y.rad1, y.rad2, 350)
				},
				N = function() {
					b.position.copy(n.getPolarCoord(n.getRadian(0), n.getRadian(0), 24).add(y.velocity)), w.position.copy(n.getPolarCoord(n.getRadian(180), n.getRadian(0), 24).add(y.velocity))
				},
				B = function() {
					Date.now() - z > 1e3 - 3 * I && (P.applyForce(new r.Vector2(.08 + I / 5e3, 0)), z = Date.now(), O = !0, C = Date.now()), g = O && Date.now() - C < 500 ? 6 + Math.floor(I / 40) : 1 + Math.floor(I / 40), P.applyHook(0, .1), P.applyDrag(.12), P.updateVelocity(), T.scale.set(1 + P.velocity.x, 1 + P.velocity.x, 1 + P.velocity.x)
				},
				G = function() {
					var e = document.createElement("canvas"),
						t = e.getContext("2d"),
						n = null,
						i = null;
					return e.width = 200, e.height = 200, (n = t.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.9, "rgba(255, 255, 255, 1)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(100, 100, 100, 0, Math.PI / 180, !0), t.fill(), i = new r.Texture(e), i.minFilter = r.NearestFilter, i.needsUpdate = !0, i
				},
				H = function() {
					for (var e = new r.OctahedronGeometry(30, 2), t = new r.BufferGeometry, n = new r.MeshPhongMaterial({
							color: new r.Color("hsl(140, 100%, 100%)"),
							flatShading: !0
						}), i = new Float32Array(3 * e.vertices.length), o = 0; o < e.vertices.length; o++) i[3 * o] = e.vertices[o].x, i[3 * o + 1] = e.vertices[o].y, i[3 * o + 2] = e.vertices[o].z;
					for (var a = new Uint32Array(3 * e.faces.length), s = 0; s < e.faces.length; s++) a[3 * s] = e.faces[s].a, a[3 * s + 1] = e.faces[s].b, a[3 * s + 2] = e.faces[s].c;
					return t.addAttribute("position", new r.BufferAttribute(i, 3)), t.attributes.position.dynamic = !0, t.setIndex(new r.BufferAttribute(a, 1)), t.index.dynamic = !0, new r.Mesh(t, n)
				},
				V = function() {
					var e = new r.OctahedronGeometry(250, 4),
						t = new r.MeshPhongMaterial({
							color: 2236962,
							flatShading: !0
						});
					return new r.Mesh(e, t)
				},
				W = function() {
					j && I < 200 ? I += 1 : I > 0 && (I -= 1)
				},
				Y = function() {
					T = H(), v.add(T), A = V(), v.add(A);
					for (var e = 0; e < 1e4; e++) {
						var i = new s,
							o = n.getRandomInt(95, 185),
							a = n.getRandomInt(60, 80);
						i.init(new r.Vector3(n.getRandomInt(-100, 100), 0, 0)), i.color = new r.Color("hsl(" + o + ", " + a + "%, 70%)"), m.push(i), M[3 * e + 0] = i.velocity.x, M[3 * e + 1] = i.velocity.y, M[3 * e + 2] = i.velocity.z, _[3 * e + 0] = i.color.r, _[3 * e + 1] = i.color.g, _[3 * e + 2] = i.color.b, S[e] = i.a, E[e] = i.size
					}
					y.init({
						scene: v,
						vs: t(["#define GLSLIFY 1\nattribute vec3 customColor;\nattribute float vertexOpacity;\nattribute float size;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  vColor = customColor;\n  fOpacity = vertexOpacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
						fs: t(["#define GLSLIFY 1\nuniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(color * vColor, fOpacity);\n  gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n}\n"]),
						positions: M,
						colors: _,
						opacities: S,
						sizes: E,
						texture: G(),
						blending: r.NormalBlending
					}), y.rad1 = 0, y.rad1_base = 0, y.rad2 = 0, y.rad3 = 0, x = new l(new r.Color("hsl(95, 50%, 60%)").getHex(), new r.Color("hsl(185, 50%, 60%)").getHex(), 1), v.add(x), b = new u("hsl(95, 60%, 50%)", 1, 500, 1), v.add(b), w = new u("hsl(95, 60%, 50%)", 1, 500, 1), v.add(w), p.anchor = new r.Vector3(1500, 0, 0)
				},
				X = function() {
					d.width = window.innerWidth, d.height = window.innerHeight, p.aspect = window.innerWidth / window.innerHeight, p.updateProjectionMatrix(), f.setSize(window.innerWidth, window.innerHeight)
				},
				q = function() {
					W(), y.velocity = k(), !0 === D && (p.force.position.anchor.copy(y.velocity.clone().add(y.velocity.clone().sub(y.obj.position).normalize().multiplyScalar(-400))), p.force.position.anchor.y += 2 * y.velocity.y, p.force.look.anchor.copy(y.velocity)), y.updatePoints(), T.position.copy(y.velocity), x.color.setHSL((95 - I / 1.5) / 360, .5, .6), x.groundColor.setHSL((185 - I / 1.5) / 360, .5, .6), b.position.copy(y.velocity), b.color.setHSL((95 - I / 1.5) / 360, .5, .6), w.position.copy(y.velocity), w.color.setHSL((185 - I / 1.5) / 360, .5, .6), U(), F(), p.force.position.applyHook(0, .025), p.force.position.applyDrag(.2), p.force.position.updateVelocity(), p.updatePosition(), p.force.look.applyHook(0, .2), p.force.look.applyDrag(.4), p.force.look.updateVelocity(), p.updateLook(), N(), B(), f.render(v, p)
				},
				Z = function e() {
					q(), requestAnimationFrame(e)
				},
				K = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), j = !0, R = Date.now()
						},
						s = function(e, n, r) {
							t.set(e, n), (0, i.default)(t)
						},
						c = function(e, t, i) {
							n.set(e, t), j = !1, Date.now() - R < 100 && (!0 === D ? (p.force.position.anchor.set(1200, 1200, 0), p.force.look.anchor.set(0, 0, 0), D = !1) : D = !0)
						},
						l = function() {
							n.set(0, 0), j = !1, Date.now() - R < 100 && (!0 === D ? (p.force.position.anchor.set(1200, 1200, 0), p.force.look.anchor.set(0, 0, 0), D = !1) : D = !0)
						};
					window.addEventListener("resize", o(function() {
						X()
					}), 1e3), d.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), d.addEventListener("mousemove", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), d.addEventListener("mouseup", function(e) {
						e.preventDefault(), c(e.clientX, e.clientY)
					}), d.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), d.addEventListener("touchmove", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), d.addEventListener("touchend", function(e) {
						e.preventDefault(), c(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), l()
					})
				};
			f.setSize(window.innerWidth, window.innerHeight), f.setClearColor(0, 1), p.position.set(1e3, 1e3, 1e3), p.lookAt(new r.Vector3), K(), Y(), X(), Z()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/Force2": 52,
		"../modules/old/ForceCamera": 54,
		"../modules/old/ForceHemisphereLight": 55,
		"../modules/old/ForcePointLight": 56,
		"../modules/old/Mover": 57,
		"../modules/old/Points.js": 58,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	14: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {}
	}, {}],
	15: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = document.getElementById("canvas-webgl");
			e.addEventListener("contextmenu", function(e) {
				e.preventDefault()
			}), e.addEventListener("selectstart", function(e) {
				e.preventDefault()
			})
		}
	}, {}],
	16: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = new i.Vector2,
				n = document.getElementById("canvas-webgl"),
				g = new i.WebGLRenderer({
					alpha: !0,
					antialias: !0,
					canvas: n
				}),
				y = new i.Scene,
				x = new c,
				b = new u(x),
				w = new i.Clock;
			x.far = 5e4, x.setFocalLength(24);
			var M = new h,
				_ = new d,
				S = new f,
				E = new v,
				T = new p,
				P = new m,
				A = new m,
				L = function() {
					var e = w.getDelta();
					M.render(e), _.render(e), S.render(e), E.render(e), T.render(e), P.render(e, .1, .1, .3), A.render(e, -.2, .02, -.8), b.render(e, t), g.render(y, x)
				},
				C = function e() {
					L(), requestAnimationFrame(e)
				},
				z = function() {
					x.aspect = e.x / e.y, x.updateProjectionMatrix()
				},
				R = function() {
					e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, z(), g.setSize(e.x, e.y)
				},
				I = function() {
					window.addEventListener("resize", r(R), 1e3), a() || s() ? window.addEventListener("deviceorientation", function(n) {
						e.x / e.y < 1 ? t.set(n.gamma / 60, o.clamp(Math.abs(n.beta) - 90, -90, 90) / -30) : t.set(0, 0)
					}) : (window.addEventListener("mousemove", function(n) {
						t.set(n.clientX / e.x * 2 - 1, -(n.clientY / e.y * 2 - 1))
					}), window.addEventListener("mouseout", function(e) {
						t.set(0, 0)
					}))
				};
			l({
				gui1: "../img/sketch/cyberspace/tex_gui01.png",
				gui2: "../img/sketch/cyberspace/tex_gui02.png",
				gui3: "../img/sketch/cyberspace/tex_gui03.png"
			}, function(e) {
				M.createObj([e.gui1, e.gui2, e.gui3]), _.createObj(), S.createObj(), E.createObj(), T.createObj(), P.createObj(1200, 284.1, 398.6, 601.2, 828.4), A.createObj(2400, 222.6, 412.4, 683.9, 961.2), y.add(M.obj), y.add(_.obj), y.add(S.obj), y.add(S.objWire), y.add(S.objPoints), y.add(E.obj), y.add(T.obj), y.add(P.obj), y.add(A.obj), T.obj.position.set(0, 0, -2e3), g.setClearColor(0, 1), b.init([0, 0, 1e3], [0, 0, 0]), w.start(), I(), R(), C()
			})
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("js-util/MathEx"),
			a = e("js-util/isiOS"),
			s = e("js-util/isAndroid"),
			c = e("../modules/common/ForcePerspectiveCamera").default,
			l = e("../modules/common/loadTexs").default,
			u = e("../modules/sketch/cyberspace/CameraController").default,
			h = e("../modules/sketch/cyberspace/GUI").default,
			d = e("../modules/sketch/cyberspace/Beam").default,
			f = e("../modules/sketch/cyberspace/Node").default,
			v = e("../modules/sketch/cyberspace/FloatPoints").default,
			p = e("../modules/sketch/cyberspace/Bg").default,
			m = e("../modules/sketch/cyberspace/BgLine").default
	}, {
		"../modules/common/ForcePerspectiveCamera": 39,
		"../modules/common/loadTexs": 42,
		"../modules/sketch/cyberspace/Beam": 73,
		"../modules/sketch/cyberspace/Bg": 74,
		"../modules/sketch/cyberspace/BgLine": 75,
		"../modules/sketch/cyberspace/CameraController": 76,
		"../modules/sketch/cyberspace/FloatPoints": 77,
		"../modules/sketch/cyberspace/GUI": 78,
		"../modules/sketch/cyberspace/Node": 79,
		"js-util/MathEx": 3,
		"js-util/debounce": 4,
		"js-util/isAndroid": 5,
		"js-util/isiOS": 7,
		"three/build/three.js": 8
	}],
	17: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = (e("../modules/old/util"), e("../modules/old/Force2")),
				a = e("../modules/old/ForceCamera"),
				s = document.getElementById("canvas-webgl"),
				c = new r.WebGLRenderer({
					antialias: !0,
					canvas: s
				}),
				l = new r.Scene,
				u = new a(35, window.innerWidth / window.innerHeight, 1, 1e4),
				h = (new r.Clock, null),
				d = null,
				f = new r.HemisphereLight(16777215, 6710886, 1),
				v = new r.Scene,
				p = new a(45, window.innerWidth / window.innerHeight, 1, 1e4),
				m = new r.HemisphereLight(16777215, 6710886, 1),
				g = new n,
				y = 1,
				x = new r.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
					magFilter: r.NearestFilter,
					minFilter: r.NearestFilter,
					wrapS: r.ClampToEdgeWrapping,
					wrapT: r.ClampToEdgeWrapping
				}),
				b = null,
				w = function() {
					var e = new r.BufferGeometry;
					e.fromGeometry(new r.OctahedronGeometry(200, 5));
					var n = new r.ShaderMaterial({
						uniforms: r.UniformsUtils.merge([r.UniformsLib.lights, {
							time: {
								type: "f",
								value: 0
							},
							radius: {
								type: "f",
								value: 1
							},
							distort: {
								type: "f",
								value: .4
							}
						}]),
						vertexShader: t(["#define GLSLIFY 1\nuniform float time;\nuniform float radius;\nuniform float distort;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float updateTime = time / 1000.0;\n  float noise = snoise(vec3(position / 400.1 + updateTime * 5.0));\n  vec4 mvPosition = modelViewMatrix * vec4(position * (noise * pow(distort, 2.0) + radius), 1.0);\n\n  vColor = hsv2rgb(vec3(noise * distort * 0.3 + updateTime, 0.2, 1.0));\n  vNormal = normal;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct HemisphereLight {\n  vec3 direction;\n  vec3 groundColor;\n  vec3 skyColor;\n};\nuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\n\nvoid main() {\n  vec3 light = vec3(0.0);\n  light += (dot(hemisphereLights[0].direction, vNormal) + 1.0) * hemisphereLights[0].skyColor * 0.5;\n  light += (-dot(hemisphereLights[0].direction, vNormal) + 1.0) * hemisphereLights[0].groundColor * 0.5;\n  gl_FragColor = vec4(vColor * light, 1.0);\n}\n"]),
						lights: !0
					});
					return new r.Mesh(e, n)
				},
				M = function() {
					var e = new r.SphereGeometry(1800),
						t = new r.MeshPhongMaterial({
							side: r.BackSide
						});
					return new r.Mesh(e, t)
				},
				_ = function() {
					var e = new r.PlaneGeometry(2, 2),
						n = new r.BufferGeometry;
					n.fromGeometry(e);
					var i = new r.ShaderMaterial({
						uniforms: {
							time: {
								type: "f",
								value: 0
							},
							resolution: {
								type: "v2",
								value: new r.Vector2(window.innerWidth, window.innerHeight)
							},
							acceleration: {
								type: "f",
								value: 0
							},
							texture: {
								type: "t",
								value: x
							}
						},
						vertexShader: t(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nuniform float time;\nuniform vec2 resolution;\nuniform float acceleration;\nuniform sampler2D texture;\n\nconst float blur = 16.0;\n\nvarying vec2 vUv;\n\nfloat random2(vec2 c){\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec2 diffUv(float v, float diff) {\n  return vUv + (vec2(v + snoise(vec2(gl_FragCoord.y + time) / 100.0), 0.0) * diff + vec2(v * 3.0, 0.0)) / resolution;\n}\n\nfloat randomNoise(vec2 p) {\n  return (random2(p - vec2(sin(time))) * 2.0 - 1.0) * max(length(acceleration), 0.08);\n}\n\nvoid main() {\n  float diff = 300.0 * length(acceleration);\n  vec2 uv_r = diffUv(0.0, diff);\n  vec2 uv_g = diffUv(1.0, diff);\n  vec2 uv_b = diffUv(-1.0, diff);\n  float r = texture2D(texture, uv_r).r + randomNoise(uv_r);\n  float g = texture2D(texture, uv_g).g + randomNoise(uv_g);\n  float b = texture2D(texture, uv_b).b + randomNoise(uv_b);\n  gl_FragColor = vec4(r, g, b, 1.0);\n}\n"])
					});
					return new r.Mesh(n, i)
				},
				S = function() {
					document.body.className = "bg-white", h = w(), v.add(h), d = M(), v.add(d), v.add(m), p.force.position.anchor.set(1800, 1800, 0), p.force.look.anchor.set(0, 0, 0), b = _(), l.add(b), l.add(f), u.force.position.anchor.set(1800, 1800, 0), u.force.look.anchor.set(0, 0, 0), g.anchor.set(1, 0), g.anchor.set(1, 0), g.velocity.set(1, 0), g.k = .045, g.d = .16
				},
				E = function() {
					s.width = window.innerWidth, s.height = window.innerHeight, u.aspect = window.innerWidth / window.innerHeight, u.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight), x.setSize(window.innerWidth, window.innerHeight), p.resize(window.innerWidth, window.innerHeight), b.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
				},
				T = function() {
					g.applyHook(0, g.k), g.applyDrag(g.d), g.updateVelocity(), h.material.uniforms.time.value += y, h.material.uniforms.radius.value = g.velocity.x, h.material.uniforms.distort.value = g.velocity.x / 2 - .1, p.force.position.applyHook(0, .025), p.force.position.applyDrag(.2), p.force.position.updateVelocity(), p.updatePosition(), p.force.look.applyHook(0, .2), p.force.look.applyDrag(.4), p.force.look.updateVelocity(), p.updateLook(), b.material.uniforms.time.value += y, b.material.uniforms.acceleration.value = g.acceleration.length(), u.force.position.applyHook(0, .025), u.force.position.applyDrag(.2), u.force.position.updateVelocity(), u.updatePosition(), u.force.look.applyHook(0, .2), u.force.look.applyDrag(.4), u.force.look.updateVelocity(), u.lookAt(u.force.look.velocity), c.render(v, p, x), c.render(l, u)
				},
				P = function e() {
					T(), requestAnimationFrame(e)
				},
				A = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), g.anchor.x < 3 ? (g.k += .005, g.d -= .02, g.anchor.x += .8, y += .4) : (g.k = .05, g.d = .16, g.anchor.x = 1, y = 1)
						},
						c = function(e, n, r) {
							t.set(e, n), (0, i.default)(t)
						},
						l = function(e, t, i) {
							n.set(e, t)
						},
						u = function() {
							n.set(0, 0)
						};
					window.addEventListener("resize", o(function() {
						E()
					}), 1e3), s.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), s.addEventListener("mousemove", function(e) {
						e.preventDefault(), c(e.clientX, e.clientY)
					}), s.addEventListener("mouseup", function(e) {
						e.preventDefault(), l(e.clientX, e.clientY)
					}), s.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), s.addEventListener("touchmove", function(e) {
						e.preventDefault(), c(e.touches[0].clientX, e.touches[0].clientY)
					}), s.addEventListener("touchend", function(e) {
						e.preventDefault(), l(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), u()
					})
				};
			c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(15658734, 1), u.position.set(1e3, 1e3, 1e3), u.lookAt(new r.Vector3), A(), S(), E(), P()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/Force2": 52,
		"../modules/old/ForceCamera": 54,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	18: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = {
					x: 0,
					y: 0
				},
				t = document.getElementById("canvas-webgl"),
				n = new r.WebGLRenderer({
					antialias: !1,
					canvas: t
				}),
				a = new r.Scene,
				s = new r.OrthographicCamera(-1, 1, 1, -1, 1, 1e4),
				c = new r.Clock,
				l = new r.Vector2,
				u = new r.Vector2,
				h = new r.Vector2,
				d = !1,
				f = new i.default,
				v = function() {
					var e = c.getDelta();
					f.render(e), n.render(a, s)
				},
				p = function e() {
					v(), requestAnimationFrame(e)
				},
				m = function() {
					var t = 640 * Math.min(e.x / e.y / (640 / 480), 1),
						n = 480 * Math.min(e.y / e.x / .75, 1);
					s.left = -.5 * t, s.right = .5 * t, s.top = .5 * n, s.bottom = -.5 * n, s.updateProjectionMatrix()
				},
				g = function() {
					e.x = document.body.clientWidth, e.y = window.innerHeight, t.width = e.x, t.height = e.y, m(), n.setSize(e.x, e.y)
				},
				y = function(e) {
					d = !0
				},
				x = function(e) {},
				b = function(e) {
					d = !1
				};
			(function() {
				window.addEventListener("resize", o(g), 1e3), t.addEventListener("mousedown", function(e) {
					e.preventDefault(), l.set(e.clientX, e.clientY), y()
				}), document.addEventListener("mousemove", function(e) {
					e.preventDefault(), u.set(e.clientX, e.clientY), x()
				}), document.addEventListener("mouseup", function(e) {
					e.preventDefault(), h.set(e.clientX, e.clientY), b()
				}), t.addEventListener("touchstart", function(e) {
					e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY), y()
				}), t.addEventListener("touchmove", function(e) {
					e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), x()
				}), t.addEventListener("touchend", function(e) {
					e.preventDefault(), h.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), b()
				})
			})(), g(), n.setClearColor(16711406, 1), s.position.set(0, 0, 100), s.lookAt(new r.Vector3), a.add(f.obj), p()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/sketch/egg/Egg.js")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/sketch/egg/Egg.js": 80,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	19: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				a = e("../modules/old/Mover"),
				s = e("../modules/old/Points"),
				c = e("../modules/old/ForcePointLight"),
				l = e("../modules/old/ForceCamera"),
				u = document.getElementById("canvas-webgl"),
				h = new r.WebGLRenderer({
					antialias: !0,
					canvas: u
				}),
				d = new r.Scene,
				f = new l(35, window.innerWidth / window.innerHeight, 1, 1e4),
				v = (new r.Clock, []),
				p = new s,
				m = new c(16737792, 1, 1800, 1),
				g = new Float32Array(3e4),
				y = new Float32Array(3e4),
				x = new Float32Array(1e4),
				b = new Float32Array(1e4),
				w = new r.Vector3(0, .1, 0),
				M = null,
				_ = Date.now(),
				S = !1,
				E = function() {
					for (var e = 0; e < v.length; e++) {
						var t = v[e];
						t.is_active && (t.time++, t.applyForce(w), t.applyDrag(.01), t.updateVelocity(), t.time > 50 && (t.size -= .7, t.a -= .009), t.a <= 0 && (t.init(new r.Vector3(0, 0, 0)), t.time = 0, t.a = 0, t.inactivate())), g[3 * e + 0] = t.velocity.x - p.velocity.x, g[3 * e + 1] = t.velocity.y - p.velocity.y, g[3 * e + 2] = t.velocity.z - p.velocity.z, x[e] = t.a, b[e] = t.size
					}
					p.updatePoints()
				},
				T = function() {
					var e = 0;
					if (Date.now() - _ > 10) {
						for (var t = 0; t < v.length; t++) {
							var i = v[t];
							if (!i.is_active) {
								var o = n.getRadian(Math.log(n.getRandomInt(0, 256)) / Math.log(256) * 260),
									a = n.getRadian(n.getRandomInt(0, 360)),
									s = 12 * (1 - Math.log(n.getRandomInt(32, 256)) / Math.log(256)),
									c = new r.Vector3,
									l = n.getPolarCoord(o, a, s);
								if (c.add(p.velocity), i.activate(), i.init(c), i.applyForce(l), i.a = .2, i.size = Math.pow(12 - s, 2) * n.getRandomInt(1, 24) / 10, ++e >= 6) break
							}
						}
						_ = Date.now()
					}
				},
				P = function(e) {
					var t = e.y * window.innerHeight / 3,
						n = e.x * window.innerWidth / -3;
					p.anchor.y = t, p.anchor.z = n, m.force.anchor.y = t, m.force.anchor.z = n
				},
				A = function() {
					var e = document.createElement("canvas"),
						t = e.getContext("2d"),
						n = null,
						i = null;
					return e.width = 200, e.height = 200, (n = t.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(100, 100, 100, 0, Math.PI / 180, !0), t.fill(), i = new r.Texture(e), i.minFilter = r.NearestFilter, i.needsUpdate = !0, i
				},
				L = function() {
					var e = new r.OctahedronGeometry(1500, 3),
						t = new r.MeshPhongMaterial({
							color: 16777215,
							flatShading: !0,
							side: r.BackSide
						});
					return new r.Mesh(e, t)
				},
				C = function() {
					for (var e = 0; e < 1e4; e++) {
						var i = new a,
							o = n.getRandomInt(0, 45),
							s = n.getRandomInt(60, 90),
							c = new r.Color("hsl(" + o + ", " + s + "%, 50%)");
						i.init(new r.Vector3(n.getRandomInt(-100, 100), 0, 0)), v.push(i), g[3 * e + 0] = i.velocity.x, g[3 * e + 1] = i.velocity.y, g[3 * e + 2] = i.velocity.z, c.toArray(y, 3 * e), x[e] = i.a, b[e] = i.size
					}
					p.init({
						scene: d,
						vs: t(["#define GLSLIFY 1\nattribute vec3 customColor;\nattribute float vertexOpacity;\nattribute float size;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  vColor = customColor;\n  fOpacity = vertexOpacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
						fs: t(["#define GLSLIFY 1\nuniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(color * vColor, fOpacity);\n  gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n}\n"]),
						positions: g,
						colors: y,
						opacities: x,
						sizes: b,
						texture: A(),
						blending: r.AdditiveBlending
					}), d.add(m), M = L(), d.add(M), f.setPolarCoord(n.getRadian(25), 0, 1e3), m.setPolarCoord(n.getRadian(25), 0, 200)
				},
				z = function() {
					u.width = window.innerWidth, u.height = window.innerHeight, f.aspect = window.innerWidth / window.innerHeight, f.updateProjectionMatrix(), h.setSize(window.innerWidth, window.innerHeight)
				},
				R = function() {
					p.applyHook(0, .08), p.applyDrag(.2), p.updateVelocity(), m.force.applyHook(0, .08), m.force.applyDrag(.2), m.force.updateVelocity(), m.updatePosition(), T(), E(), f.force.position.applyHook(0, .004), f.force.position.applyDrag(.1), f.force.position.updateVelocity(), f.updatePosition(), f.lookAtCenter(), h.render(d, f)
				},
				I = function e() {
					R(), requestAnimationFrame(e)
				},
				j = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), P(e), S = !0
						},
						s = function(e, n, r) {
							t.set(e, n), (0, i.default)(t), S && P(t)
						},
						c = function(e, t, i) {
							n.set(e, t), S = !1, p.anchor.set(0, 0, 0), m.force.anchor.set(0, 0, 0)
						},
						l = function() {
							n.set(0, 0), S = !1, p.anchor.set(0, 0, 0), m.force.anchor.set(0, 0, 0)
						};
					window.addEventListener("resize", o(function() {
						z()
					}), 1e3), u.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), u.addEventListener("mousemove", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), u.addEventListener("mouseup", function(e) {
						e.preventDefault(), c(e.clientX, e.clientY)
					}), u.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), u.addEventListener("touchmove", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), u.addEventListener("touchend", function(e) {
						e.preventDefault(), c(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), l()
					})
				};
			h.setSize(window.innerWidth, window.innerHeight), h.setClearColor(0, 1), f.position.set(1e3, 1e3, 1e3), f.lookAt(new r.Vector3), j(), C(), z(), I()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/ForceCamera": 54,
		"../modules/old/ForcePointLight": 56,
		"../modules/old/Mover": 57,
		"../modules/old/Points": 58,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	20: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = new i.Vector2,
				n = document.getElementById("canvas-webgl"),
				v = new i.WebGLRenderer({
					alpha: !0,
					antialias: !0,
					canvas: n
				}),
				p = new i.Scene,
				m = new c,
				g = new l(m),
				y = new i.Clock;
			m.far = 5e4, m.setFocalLength(35);
			var x = new u,
				b = new h,
				w = new d,
				M = new f,
				_ = function() {
					var e = y.getDelta();
					x.render(e), b.render(e), w.render(e), M.render(e), g.render(e, t), v.render(p, m)
				},
				S = function e() {
					_(), requestAnimationFrame(e)
				},
				E = function() {
					m.aspect = e.x / e.y, m.updateProjectionMatrix()
				},
				T = function() {
					e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, E(), v.setSize(e.x, e.y)
				},
				P = function() {
					window.addEventListener("resize", r(T), 1e3), a() || s() ? window.addEventListener("deviceorientation", function(n) {
						e.x / e.y < 1 ? t.set(n.gamma / 60, -.02 * o.clamp(Math.abs(n.beta) - 90, -90, 90)) : t.set(0, 0)
					}) : (window.addEventListener("mousemove", function(n) {
						t.set(n.clientX / e.x * 2 - 1, -(n.clientY / e.y * 2 - 1))
					}), window.addEventListener("mouseout", function(e) {
						t.set(0, 0)
					}))
				};
			x.createObj(), b.createObj(), w.createObj(), M.createObj(), p.add(x.obj), p.add(b.obj), p.add(w.obj), p.add(M.obj), v.setClearColor(0, 1), g.init([0, 1500, 3e3], [0, -100, 0]), y.start(), P(), T(), S()
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("js-util/MathEx"),
			a = e("js-util/isiOS"),
			s = e("js-util/isAndroid"),
			c = e("../modules/common/ForcePerspectiveCamera").default,
			l = e("../modules/sketch/Flame/CameraController").default,
			u = e("../modules/sketch/Flame/FlameCore").default,
			h = e("../modules/sketch/Flame/FlameCylinder").default,
			d = e("../modules/sketch/Flame/FlameStone").default,
			f = e("../modules/sketch/Flame/BackgroundSphere").default
	}, {
		"../modules/common/ForcePerspectiveCamera": 39,
		"../modules/sketch/Flame/BackgroundSphere": 60,
		"../modules/sketch/Flame/CameraController": 61,
		"../modules/sketch/Flame/FlameCore": 62,
		"../modules/sketch/Flame/FlameCylinder": 63,
		"../modules/sketch/Flame/FlameStone": 64,
		"js-util/MathEx": 3,
		"js-util/debounce": 4,
		"js-util/isAndroid": 5,
		"js-util/isiOS": 7,
		"three/build/three.js": 8
	}],
	21: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = document.getElementById("canvas-webgl"),
				n = new i.WebGLRenderer({
					alpha: !0,
					antialias: !0,
					canvas: t
				}),
				s = new i.Scene,
				c = new i.PerspectiveCamera,
				l = new i.Clock;
			c.far = 5e4, c.setFocalLength(24);
			var u = {
					fog: "../img/sketch/fog/fog.png"
				},
				h = new a,
				d = function() {
					var e = l.getDelta();
					h.render(e), n.render(s, c)
				},
				f = function e() {
					d(), requestAnimationFrame(e)
				},
				v = function() {
					c.aspect = e.x / e.y, c.updateProjectionMatrix()
				},
				p = function() {
					e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, v(), n.setSize(e.x, e.y)
				},
				m = function() {
					window.addEventListener("resize", r(p), 1e3)
				};
			o(u, function(e) {
				h.createObj(e.fog), s.add(h.obj), n.setClearColor(1118481, 1), c.position.set(0, 0, 1e3), c.lookAt(new i.Vector3), l.start(), m(), p(), f()
			})
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("../modules/common/loadTexs").default,
			a = e("../modules/sketch/fog/Fog").default
	}, {
		"../modules/common/loadTexs": 42,
		"../modules/sketch/fog/Fog": 81,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	22: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("../modules/old/util"),
				n = e("../modules/old/Force3"),
				a = e("../modules/old/ForceHemisphereLight"),
				s = e("../modules/old/ForceCamera"),
				c = document.getElementById("canvas-webgl"),
				l = new r.WebGLRenderer({
					antialias: !0,
					canvas: c
				}),
				u = new r.Scene,
				h = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
				d = (new r.Clock, []),
				f = null,
				v = new r.Raycaster,
				p = -1,
				m = -1,
				g = !1,
				y = !1,
				x = !1,
				b = function() {
					this.rad = 0, this.obj = null, this.is_entered = !1, n.call(this)
				},
				w = new r.PlaneGeometry(100, 100);
			(b.prototype = Object.create(n.prototype)).constructor = b, b.prototype.init = function(e) {
				var n = new r.MeshPhongMaterial({
					side: r.DoubleSide,
					map: (new r.TextureLoader).load("../img/sketch/gallery/image0" + t.getRandomInt(1, 9) + ".jpg")
				});
				this.obj = new r.Mesh(w, n), this.velocity = e.clone(), this.anchor = e.clone(), this.acceleration.set(0, 0, 0)
			};
			var M = function(e) {
					for (var n = 0; n < 300; n++) {
						var i = null,
							o = t.getRadian(n % 45 * 8 + 180),
							a = 1e3 * Math.cos(o),
							s = 5 * n - 750,
							c = 1e3 * Math.sin(o),
							l = new r.Vector3(a, s, c);
						(i = new b).init(new r.Vector3), i.rad = o, i.obj.position.copy(l), e.add(i.obj), d.push(i)
					}
				},
				_ = function(e) {
					if (!x) {
						var t = null;
						v.setFromCamera(e, h), (t = v.intersectObjects(u.children)).length > 0 && 0 == y ? (document.body.classList.add("is-pointed"), p = t[0].object.id) : E()
					}
				},
				S = function(e, t) {
					x = !0, e.force.position.anchor.set(780 * Math.cos(t.rad), t.obj.position.y, 780 * Math.sin(t.rad)), e.force.look.anchor.copy(t.obj.position), E()
				},
				E = function() {
					document.body.classList.remove("is-pointed"), p = -1
				},
				T = function() {
					M(u), f = new a(16777215, 16777215, 1), u.add(f), h.force.position.anchor.set(0, 0, 0), h.rotate_rad1 = t.getRadian(-35), h.rotate_rad1_base = h.rotate_rad1, h.rotate_rad2 = t.getRadian(180), h.rotate_rad2_base = h.rotate_rad2
				},
				P = function() {
					c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), l.setSize(window.innerWidth, window.innerHeight)
				},
				A = function() {
					for (var e = 0; e < 300; e++) d[e].applyHook(0, .14), d[e].applyDrag(.4), d[e].updateVelocity(), d[e].obj.lookAt(0, d[e].obj.position.y, 0), d[e].obj.id == p && 0 == y && 0 == x ? 1 == g ? m = e : d[e].obj.material.color.set(11184810) : d[e].obj.material.color.set(16777215);
					h.force.position.applyHook(0, .08), h.force.position.applyDrag(.4), h.force.position.updateVelocity(), h.updatePosition(), !1 === x && h.force.look.anchor.copy(t.getPolarCoord(h.rotate_rad1, h.rotate_rad2, 1e3)), h.force.look.applyHook(0, .08), h.force.look.applyDrag(.4), h.force.look.updateVelocity(), h.updateLook(), l.render(u, h)
				},
				L = function e() {
					A(), requestAnimationFrame(e)
				},
				C = function() {
					var e = new r.Vector2,
						n = new r.Vector2,
						a = new r.Vector2,
						s = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), _(e), g = !0
						},
						l = function(r, o, a) {
							n.set(r, o), (0, i.default)(n), _(u), g && e.clone().sub(n).length() > .01 && (g = !1, y = !0), 1 == y && 0 == x && (h.rotate_rad1 = h.rotate_rad1_base + t.getRadian(50 * (e.y - n.y)), h.rotate_rad2 = h.rotate_rad2_base + t.getRadian(50 * (e.x - n.x)), h.rotate_rad1 < t.getRadian(-50) && (h.rotate_rad1 = t.getRadian(-50)), h.rotate_rad1 > t.getRadian(50) && (h.rotate_rad1 = t.getRadian(50)))
						},
						f = function(e, t, n) {
							a.set(e, t), E(), x ? (h.force.position.anchor.set(0, 0, 0), m = -1, x = !1) : g && m > -1 ? S(h, d[m]) : y && (h.rotate_rad1_base = h.rotate_rad1, h.rotate_rad2_base = h.rotate_rad2), g = !1, y = !1
						},
						v = function() {
							a.set(0, 0), E(), x ? (h.force.position.anchor.set(0, 0, 0), m = -1, x = !1) : g && m > -1 ? S(h, d[m]) : y && (h.rotate_rad1_base = h.rotate_rad1, h.rotate_rad2_base = h.rotate_rad2), g = !1, y = !1
						};
					window.addEventListener("resize", o(function() {
						P()
					}), 1e3), c.addEventListener("mousedown", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), c.addEventListener("mousemove", function(e) {
						e.preventDefault(), l(e.clientX, e.clientY)
					}), c.addEventListener("mouseup", function(e) {
						e.preventDefault(), f(e.clientX, e.clientY)
					}), c.addEventListener("touchstart", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchmove", function(e) {
						e.preventDefault(), l(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchend", function(e) {
						e.preventDefault(), f(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), v()
					})
				};
			l.setSize(window.innerWidth, window.innerHeight), l.setClearColor(1118481, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), C(), T(), P(), L()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/Force3": 53,
		"../modules/old/ForceCamera": 54,
		"../modules/old/ForceHemisphereLight": 55,
		"../modules/old/util": 59,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	23: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = document.getElementById("canvas-webgl"),
				t = new s.WebGLRenderer({
					antialias: !1,
					canvas: e
				}),
				n = new s.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				i = new s.Scene,
				l = new s.Scene,
				u = new s.OrthographicCamera(-1, 1, 1, -1, 0, 1),
				h = new s.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
				d = new s.Clock,
				f = new s.Vector2,
				v = new s.Vector2,
				p = new s.Vector2,
				m = !1,
				g = new o.default,
				y = new a.default(n.texture),
				x = function() {
					e.width = document.body.clientWidth, e.height = window.innerHeight, h.aspect = document.body.clientWidth / window.innerHeight, h.updateProjectionMatrix(), g.resize(), y.resize(), n.setSize(document.body.clientWidth, window.innerHeight), t.setSize(document.body.clientWidth, window.innerHeight)
				},
				b = function() {
					var e = d.getDelta();
					t.render(l, h, n), y.render(e), t.render(i, u)
				},
				w = function e() {
					b(), requestAnimationFrame(e)
				},
				M = function(e) {
					m = !0
				},
				_ = function(e) {},
				S = function(e) {
					m = !1
				},
				E = function() {
					window.addEventListener("resize", c(function() {
						x()
					}), 1e3), e.addEventListener("mousedown", function(e) {
						e.preventDefault(), f.set(e.clientX, e.clientY), (0, r.default)(f), M()
					}), document.addEventListener("mousemove", function(e) {
						e.preventDefault(), v.set(e.clientX, e.clientY), (0, r.default)(v), _()
					}), document.addEventListener("mouseup", function(e) {
						e.preventDefault(), p.set(e.clientX, e.clientY), (0, r.default)(p), S()
					}), e.addEventListener("touchstart", function(e) {
						e.preventDefault(), f.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(f), M(e.touches[0].clientX, e.touches[0].clientY)
					}), e.addEventListener("touchmove", function(e) {
						e.preventDefault(), v.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(v), _()
					}), e.addEventListener("touchend", function(e) {
						e.preventDefault(), p.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), (0, r.default)(p), S()
					})
				};
			t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(5592405, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new s.Vector3), g.init(function() {
				l.add(g.obj), i.add(y.obj)
			}), E(), x(), w()
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/sketch/glitch/BackgroundImage.js")),
			a = i(e("../modules/sketch/glitch/PostEffect.js")),
			s = e("three/build/three.js"),
			c = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/glitch/BackgroundImage.js": 82,
		"../modules/sketch/glitch/PostEffect.js": 83,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	24: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				a = e("../modules/old/Force2"),
				s = e("../modules/old/ForceCamera"),
				c = document.getElementById("canvas-webgl"),
				l = new r.WebGLRenderer({
					antialias: !0,
					canvas: c
				}),
				u = new r.Scene,
				h = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
				d = (new r.Clock, null),
				f = null,
				v = null,
				p = null,
				m = new r.DirectionalLight(16777215, 1),
				g = new r.Scene,
				y = new s(45, 1, 1, 1e4),
				x = new r.WebGLRenderTarget(1200, 1200),
				b = null,
				w = new r.Scene,
				M = new s(45, 1, 1, 1e4),
				_ = new r.HemisphereLight(268435455, 13421772, 1),
				S = new r.WebGLRenderTarget(1200, 1200),
				E = null,
				T = null,
				P = new a,
				A = function() {
					for (var e = new r.BufferGeometry, i = [], o = [], a = 0; a < 32; a++) {
						i.push(0, 0, 0);
						var s = n.getRadian(n.getRandomInt(0, 360)),
							c = n.getRadian(n.getRandomInt(0, 360)),
							l = n.getRadian(n.getRandomInt(0, 360));
						o.push(s, c, l)
					}
					var u = new Float32Array(i);
					e.addAttribute("position", new r.BufferAttribute(u, 3));
					var h = new Float32Array(o);
					e.addAttribute("radian", new r.BufferAttribute(h, 3));
					var d = new r.ShaderMaterial({
						uniforms: {
							time: {
								type: "f",
								value: 0
							},
							resolution: {
								type: "v2",
								value: new r.Vector2(window.innerWidth, window.innerHeight)
							},
							size: {
								type: "f",
								value: 28
							},
							force: {
								type: "v2",
								value: P.velocity
							}
						},
						vertexShader: t(["#define GLSLIFY 1\nattribute vec3 radian;\n\nuniform float time;\nuniform vec2 resolution;\nuniform float size;\nuniform vec2 force;\n\nvoid main() {\n  float radius = 300.0;\n  float radian_base = radians(time * 2.0);\n  vec3 update_positon = position + vec3(\n    cos(radian_base + radian.x) * cos(radian_base + radian.y) * radius,\n    cos(radian_base + radian.x) * sin(radian_base + radian.y) * radius,\n    sin(radian_base + radian.x) * radius\n  ) * force.x;\n  vec4 mvPosition = modelViewMatrix * vec4(update_positon, 1.0);\n\n  gl_PointSize = (size + force.y) * (abs(sin(radian_base + radian.z))) * (size / length(mvPosition.xyz)) * 480.0;\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nuniform float size;\n\nvoid main() {\n  vec3 n;\n  n.xy = gl_PointCoord.xy * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(1.0);\n}\n"]),
						transparent: !0,
						depthWrite: !1,
						blending: r.AdditiveBlending
					});
					return new r.Points(e, d)
				},
				L = function() {
					for (var e = new r.SphereBufferGeometry(2, 4, 4), i = e.attributes, o = new r.BufferGeometry, a = [], s = [], c = [], l = [], u = [], h = 0; h < 16; h++) {
						var d, f, v;
						! function(t) {
							for (m = n.getRandomInt(300, 1e3), d = n.getRadian(n.getRandomInt(0, 3600) / 10), f = n.getRandomInt(60, 120) / 100, v = 0; v < i.position.array.length; v += 3) a.push(i.position.array[v + 0], i.position.array[v + 1], i.position.array[v + 2]), s.push(m), c.push(d), l.push(f);
							e.index.array.map(function(e) {
								u.push(e + t * i.position.array.length / 3)
							})
						}(h)
					}
					var p = new Float32Array(a);
					o.addAttribute("position", new r.BufferAttribute(p, 3));
					var m = new Float32Array(s);
					o.addAttribute("radius", new r.BufferAttribute(m, 1));
					var g = new Float32Array(c);
					o.addAttribute("radian", new r.BufferAttribute(g, 1));
					var y = new Float32Array(l);
					o.addAttribute("scale", new r.BufferAttribute(y, 1));
					var x = new Uint32Array(u);
					o.setIndex(new r.BufferAttribute(x, 1));
					var b = new r.ShaderMaterial({
						uniforms: r.UniformsUtils.merge([r.UniformsLib.lights, {
							time: {
								type: "f",
								value: 0
							}
						}]),
						vertexShader: t(["#define GLSLIFY 1\nattribute float radius;\nattribute float radian;\nattribute float scale;\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nmat4 translateMatrix(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 rotationMatrixX(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotationMatrixY(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotationMatrixZ(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotationMatrix(float radian_x, float radian_y, float radian_z) {\n  return rotationMatrixX(radian_x) * rotationMatrixY(radian_y) * rotationMatrixZ(radian_z);\n}\n\nmat4 scaleMatrix(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec4 move(vec3 position) {\n  return translateMatrix(\n    vec3(\n      cos(radians(time * 0.5) + radian) * radius,\n      sin(radians(time * 0.5) + radian * 10.0) * radius * 0.3,\n      sin(radians(time * 0.5) + radian) * radius\n    )\n  ) * rotationMatrix(\n    radians(time * radian) + radian, radians(time) + radian, radians(time) + radian\n  ) * scaleMatrix(\n    vec3(20.0 * scale) + vec3(10.0) * snoise((position + sin(radian)))\n  ) * vec4(position, 1.0);\n}\n\nvoid main() {\n  vec4 update_position = move(position);\n  vPosition = position;\n  vInvertMatrix = inverse(rotationMatrix(\n    radians(time * radian) + radian, radians(time) + radian, radians(time) + radian\n  ));\n  gl_Position = projectionMatrix * modelViewMatrix * update_position;\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\nuniform DirectionalLight directionalLights[1];\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 inv_light = normalize(vInvertMatrix * vec4(directionalLights[0].direction, 1.0)).xyz;\n  float diff = (dot(normal, inv_light) + 1.0) / 2.0 * 0.25 + 0.75;\n  gl_FragColor = vec4(vec3(1.0) * diff, 1.0);\n}\n"]),
						flatShading: !0,
						lights: !0
					});
					return new r.Mesh(o, b)
				},
				C = function() {
					var e = new r.SphereGeometry(1200, 64, 64),
						n = new r.ShaderMaterial({
							uniforms: {
								time: {
									type: "f",
									value: 0
								}
							},
							vertexShader: t(["#define GLSLIFY 1\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  vColor = vec3((position.y / 1000.0 + 1.0) * 0.12 + 0.88);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]),
							fragmentShader: t(["#define GLSLIFY 1\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"]),
							side: r.BackSide
						});
					return new r.Mesh(e, n)
				},
				z = function() {
					var e = new r.SphereGeometry(1100, 64, 64),
						t = new r.MeshBasicMaterial({
							color: 14540253,
							wireframe: !0
						});
					return new r.Mesh(e, t)
				},
				R = function() {
					for (var e = new r.BufferGeometry, i = [], o = 0; o < 2e3; o++) i.push(n.getRadian(n.getRandomInt(0, 120) + 120), n.getRadian(n.getRandomInt(0, 3600) / 10), n.getRandomInt(200, 1e3));
					var a = new Float32Array(i);
					e.addAttribute("position", new r.BufferAttribute(a, 3));
					var s = new r.ShaderMaterial({
						uniforms: {
							time: {
								type: "f",
								value: 0
							}
						},
						vertexShader: t(["#define GLSLIFY 1\nuniform float time;\n\nvec3 getPolarCoord(float rad1, float rad2, float r) {\n  return vec3(\n    cos(rad1) * cos(rad2) * r,\n    sin(rad1) * r,\n    cos(rad1) * sin(rad2) * r\n  );\n}\n\nvoid main() {\n  vec3 update_position = getPolarCoord(\n    position.x,\n    position.y + radians(time / 2.0),\n    position.z + sin(radians(time * 2.0) + position.x + position.y) * position.z / 4.0\n  );\n  vec4 mv_position = modelViewMatrix * vec4(update_position, 1.0);\n\n  gl_PointSize = 2.0 * (1000.0 / length(mv_position.xyz));\n  gl_Position = projectionMatrix * mv_position;\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nvoid main() {\n  vec3 n;\n  n.xy = gl_PointCoord.xy * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(1.0);\n}\n"])
					});
					return new r.Points(e, s)
				},
				I = function() {
					var e = new r.SphereGeometry(1e3, 128, 128),
						n = new r.BufferGeometry;
					n.fromGeometry(e);
					var i = new r.ShaderMaterial({
						uniforms: {
							time: {
								type: "f",
								value: 0
							}
						},
						vertexShader: t(["#define GLSLIFY 1\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main() {\n  float noise = snoise(\n    vec3(position.x + time * 10.0, position.y + cos(time / 20.0) * 100.0, position.z + time * 10.0) / 800.0\n  );\n  vColor = hsv2rgb(vec3(noise * 0.2 + 0.75, 0.4, noise * 0.3 + 0.5));\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"]),
						side: r.BackSide
					});
					return new r.Mesh(n, i)
				},
				j = function() {
					var e = new r.PlaneGeometry(1e3, 1e3),
						n = new r.BufferGeometry;
					n.fromGeometry(e);
					var i = new r.ShaderMaterial({
						uniforms: {
							time: {
								type: "f",
								value: 0
							},
							resolution: {
								type: "v2",
								value: new r.Vector2(window.innerWidth, window.innerHeight)
							},
							texture: {
								type: "t",
								value: x.texture
							},
							texture2: {
								type: "t",
								value: S.texture
							}
						},
						vertexShader: t(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]),
						fragmentShader: t(["#define GLSLIFY 1\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\nuniform sampler2D texture2;\n\nconst float blur = 20.0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  for (float x = 0.0; x < blur; x++){\n    for (float y = 0.0; y < blur; y++){\n      color += texture2D(texture, vUv - (vec2(x, y) - vec2(blur / 2.0)) / resolution);\n    }\n  }\n  vec4 color2 = color / pow(blur, 2.0);\n  vec4 color3 = texture2D(texture2, vUv);\n  gl_FragColor = vec4(color3.rgb, floor(length(color2.rgb)));\n}\n"]),
						transparent: !0
					});
					return new r.Mesh(n, i)
				},
				O = function() {
					P.anchor.set(1, 0), M.force.position.anchor.set(1e3, 300, 0), M.force.look.anchor.set(0, 0, 0), E = I(), T = R(), w.add(E), w.add(T), w.add(_), d = A(), g.add(d), y.position.set(0, 0, 3e3), y.force.look.anchor.set(0, 0, 0), b = j(), u.add(b), f = C(), u.add(f), v = z(), u.add(v), p = L(), u.add(p), m.position.set(0, 1, 0), u.add(m), h.force.position.anchor.set(1e3, 300, 0), h.force.look.anchor.set(0, 0, 0)
				},
				D = function() {
					c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), l.setSize(window.innerWidth, window.innerHeight), d.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight), b.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
				},
				F = function() {
					d.material.uniforms.time.value++, b.lookAt(h.position), b.material.uniforms.time.value++, E.material.uniforms.time.value++, T.material.uniforms.time.value++, v.rotation.y = d.material.uniforms.time.value / 1e3, p.material.uniforms.time.value++, P.applyHook(0, .12), P.applyDrag(.18), P.updateVelocity(), h.force.position.applyHook(0, .025), h.force.position.applyDrag(.2), h.force.position.updateVelocity(), h.updatePosition(), h.force.look.anchor.y = 100 * Math.sin(d.material.uniforms.time.value / 100), h.force.look.applyHook(0, .2), h.force.look.applyDrag(.4), h.updateLook(), M.force.position.applyHook(0, .1), M.force.position.applyDrag(.2), M.force.position.updateVelocity(), M.updatePosition(), M.force.look.applyHook(0, .2), M.force.look.applyDrag(.4), M.force.look.updateVelocity(), M.updateLook(), l.render(w, M, S), l.render(g, y, x), l.render(u, h)
				},
				U = function e() {
					F(), requestAnimationFrame(e)
				},
				k = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), P.anchor.set(2, 30)
						},
						s = function(e, n, r) {
							t.set(e, n), (0, i.default)(t)
						},
						l = function(e, t, i) {
							n.set(e, t), P.anchor.set(1, 0)
						},
						u = function() {
							n.set(0, 0), P.anchor.set(1, 0)
						};
					window.addEventListener("resize", o(function() {
						D()
					}), 1e3), c.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), c.addEventListener("mousemove", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), c.addEventListener("mouseup", function(e) {
						e.preventDefault(), l(e.clientX, e.clientY)
					}), c.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchmove", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchend", function(e) {
						e.preventDefault(), l(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), u()
					})
				};
			l.setSize(window.innerWidth, window.innerHeight), l.setClearColor(15658734, 0), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), k(), O(), D(), U()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/Force2": 52,
		"../modules/old/ForceCamera": 54,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	25: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				a = e("../modules/old/Mover"),
				s = e("../modules/old/Points.js"),
				c = e("../modules/old/ForceCamera"),
				l = document.getElementById("canvas-webgl"),
				u = new r.WebGLRenderer({
					antialias: !0,
					canvas: l
				}),
				h = new r.Scene,
				d = new c(35, window.innerWidth / window.innerHeight, 1, 1e4),
				f = (new r.Clock, []),
				v = new s,
				p = new Float32Array(6e4),
				m = new Float32Array(6e4),
				g = new Float32Array(2e4),
				y = new Float32Array(2e4),
				x = new r.Vector3(1.5, 0, 0),
				b = Date.now(),
				w = !1,
				M = function() {
					for (var e = 0; e < f.length; e++) {
						var t = f[e];
						t.is_active && (t.time++, t.applyForce(x), t.applyDrag(.1), t.updateVelocity(), t.a < .8 && (t.a += .02), t.velocity.x > 1e3 && (t.init(new r.Vector3(0, 0, 0)), t.time = 0, t.a = 0, t.inactivate())), p[3 * e + 0] = t.velocity.x, p[3 * e + 1] = t.velocity.y, p[3 * e + 2] = t.velocity.z, g[e] = t.a, y[e] = t.size
					}
					v.updatePoints()
				},
				_ = function() {
					var e = 0;
					if (Date.now() - b > 16 * x.x) {
						for (var t = 0; t < f.length; t++) {
							var i = f[t];
							if (!i.is_active) {
								var o = n.getRadian(3 * n.getRandomInt(0, 120)),
									a = Math.log(n.getRandomInt(2, 128)) / Math.log(128) * 160 + 60,
									s = Math.sin(o) * a,
									c = Math.cos(o) * a,
									l = new r.Vector3(-1e3, s, c);
								if (l.add(v.velocity), i.activate(), i.init(l), i.a = 0, i.size = n.getRandomInt(5, 60), ++e >= Math.pow(3 * x.x, .4 * x.x)) break
							}
						}
						b = Date.now()
					}
				},
				S = function() {
					var e = document.createElement("canvas"),
						t = e.getContext("2d"),
						n = null,
						i = null;
					return e.width = 256, e.height = 256, (n = t.createRadialGradient(128, 128, 20, 128, 128, 128)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(128, 128, 128, 0, Math.PI / 180, !0), t.fill(), i = new r.Texture(e), i.needsUpdate = !0, i
				},
				E = function() {
					w ? x.x < 6 && (x.x += .02) : x.x > 1.5 && (x.x -= .1)
				},
				T = function() {
					for (var e = 0; e < 2e4; e++) {
						var i = new a,
							o = n.getRandomInt(60, 210),
							s = n.getRandomInt(30, 90),
							c = new r.Color("hsl(" + o + ", " + s + "%, 50%)");
						i.init(new r.Vector3(n.getRandomInt(-100, 100), 0, 0)), f.push(i), p[3 * e + 0] = i.velocity.x, p[3 * e + 1] = i.velocity.y, p[3 * e + 2] = i.velocity.z, c.toArray(m, 3 * e), g[e] = i.a, y[e] = i.size
					}
					v.init({
						scene: h,
						vs: t(["#define GLSLIFY 1\nattribute vec3 customColor;\nattribute float vertexOpacity;\nattribute float size;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  vColor = customColor;\n  fOpacity = vertexOpacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
						fs: t(["#define GLSLIFY 1\nuniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(color * vColor, fOpacity);\n  gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n}\n"]),
						positions: p,
						colors: m,
						opacities: g,
						sizes: y,
						texture: S(),
						blending: r.AdditiveBlending
					}), d.force.position.anchor.set(800, 0, 0)
				},
				P = function() {
					l.width = window.innerWidth, l.height = window.innerHeight, d.aspect = window.innerWidth / window.innerHeight, d.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
				},
				A = function() {
					E(), _(), M(), d.force.position.applyHook(0, .008), d.force.position.applyDrag(.1), d.force.position.updateVelocity(), d.updatePosition(), d.lookAtCenter(), u.render(h, d)
				},
				L = function e() {
					A(), requestAnimationFrame(e)
				},
				C = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), w = !0
						},
						s = function(e, n, r) {
							t.set(e, n), (0, i.default)(t), d.force.position.anchor.z = 120 * t.x, d.force.position.anchor.y = -120 * t.y
						},
						c = function(e, t, i) {
							n.set(e, t), d.force.position.anchor.z = 0, d.force.position.anchor.y = 0, w = !1
						},
						u = function() {
							n.set(0, 0), d.force.position.anchor.z = 0, d.force.position.anchor.y = 0
						};
					window.addEventListener("resize", o(function() {
						P()
					}), 1e3), l.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), l.addEventListener("mousemove", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), l.addEventListener("mouseup", function(e) {
						e.preventDefault(), c(e.clientX, e.clientY)
					}), l.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), l.addEventListener("touchmove", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), l.addEventListener("touchend", function(e) {
						e.preventDefault(), c(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), u()
					})
				};
			u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(0, 1), d.position.set(1e3, 1e3, 1e3), d.lookAt(new r.Vector3), C(), T(), P(), L()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/ForceCamera": 54,
		"../modules/old/Mover": 57,
		"../modules/old/Points.js": 58,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	26: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				a = e("../modules/old/Mover"),
				s = e("../modules/old/Points.js"),
				c = e("../modules/old/ForceCamera"),
				l = document.getElementById("canvas-webgl"),
				u = new r.WebGLRenderer({
					antialias: !0,
					canvas: l
				}),
				h = new r.Scene,
				d = new c(35, window.innerWidth / window.innerHeight, 1, 1e4),
				f = (new r.Clock, new Image),
				v = [],
				p = [],
				m = null,
				g = null,
				y = null,
				x = null,
				b = new s,
				w = !1,
				M = function(e) {
					f.src = "../img/sketch/image_data/elephant.png", f.onload = function() {
						e()
					}
				},
				_ = function() {
					var e = document.createElement("canvas"),
						t = e.getContext("2d");
					e.width = 400, e.height = 400, t.drawImage(f, 0, 0);
					for (var n = t.getImageData(0, 0, 400, 400), i = 0; i < 400; i++)
						if (!(i % 3 > 0))
							for (var r = 0; r < 400; r++) r % 3 > 0 || n.data[4 * (r + 400 * i)] > 0 && v.push(0, -1 * (i - 200), -1 * (r - 200))
				},
				S = function(e) {
					m = new Float32Array(v), g = new Float32Array(v.length), y = new Float32Array(v.length / 3), x = new Float32Array(v.length / 3);
					for (var n = 0; n < v.length / 3; n++) {
						var i = new a,
							o = new r.Color("hsl(" + (v[3 * n + 2] + v[3 * n + 1] + 400) / 5 + ", 60%, 80%)");
						i.init(new r.Vector3(v[3 * n], v[3 * n + 1], v[3 * n + 2])), i.is_activate = !0, p.push(i), o.toArray(g, 3 * n), y[n] = 1, x[n] = 12
					}
					b.init({
						scene: e,
						vs: t(["#define GLSLIFY 1\nattribute vec3 customColor;\nattribute float vertexOpacity;\nattribute float size;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  vColor = customColor;\n  fOpacity = vertexOpacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
						fs: t(["#define GLSLIFY 1\nuniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(color * vColor, fOpacity);\n  gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n}\n"]),
						positions: m,
						colors: g,
						opacities: y,
						sizes: x,
						texture: P(),
						blending: r.NormalBlending
					}), w = !0
				},
				E = function() {
					for (var e = 0; e < p.length; e++) {
						var t = p[e],
							i = n.getRadian(n.getRandomInt(0, 360)),
							r = n.getRadian(n.getRandomInt(0, 360)),
							o = n.getRandomInt(40, 80);
						t.is_activate = !1, t.applyForce(n.getPolarCoord(i, r, o))
					}
				},
				T = function() {
					for (var e = 0; e < p.length; e++) {
						var t = p[e];
						t.time++, t.acceleration.length() < 1 && (t.is_activate = !0), t.is_activate ? (t.applyHook(0, .18), t.applyDrag(.26)) : t.applyDrag(.035), t.updateVelocity(), t.velocity.sub(b.velocity), m[3 * e + 0] = t.velocity.x - b.velocity.x, m[3 * e + 1] = t.velocity.y - b.velocity.x, m[3 * e + 2] = t.velocity.z - b.velocity.x, t.size = Math.log(n.getRandomInt(1, 128)) / Math.log(128) * Math.sqrt(document.body.clientWidth), x[e] = t.size
					}
					b.updatePoints()
				},
				P = function() {
					var e = document.createElement("canvas"),
						t = e.getContext("2d"),
						n = null,
						i = null;
					return e.width = 200, e.height = 200, (n = t.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(100, 100, 100, 0, Math.PI / 180, !0), t.fill(), i = new r.Texture(e), i.minFilter = r.NearestFilter, i.needsUpdate = !0, i
				},
				A = function() {
					M(function() {
						_(), S(h)
					}), d.setPolarCoord(0, 0, 1400)
				},
				L = function() {
					l.width = window.innerWidth, l.height = window.innerHeight, d.aspect = window.innerWidth / window.innerHeight, d.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
				},
				C = function() {
					w && (T(), b.updatePoints()), d.force.position.applyHook(0, .025), d.force.position.applyDrag(.2), d.force.position.updateVelocity(), d.updatePosition(), d.lookAtCenter(), u.render(h, d)
				},
				z = function e() {
					C(), requestAnimationFrame(e)
				},
				R = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e), E()
						},
						s = function(e, n, r) {
							t.set(e, n), (0, i.default)(t), d.force.position.anchor.z = 1e3 * t.x, d.force.position.anchor.y = -1e3 * t.y
						},
						c = function(e, t, i) {
							n.set(e, t), d.force.position.anchor.z = 0, d.force.position.anchor.y = 0
						},
						u = function() {
							n.set(0, 0), d.force.position.anchor.z = 0, d.force.position.anchor.y = 0
						};
					window.addEventListener("resize", o(function() {
						L()
					}), 1e3), l.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), l.addEventListener("mousemove", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), l.addEventListener("mouseup", function(e) {
						e.preventDefault(), c(e.clientX, e.clientY)
					}), l.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), l.addEventListener("touchmove", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), l.addEventListener("touchend", function(e) {
						e.preventDefault(), c(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), u()
					})
				};
			u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(1118481, 1), d.position.set(1e3, 1e3, 1e3), d.lookAt(new r.Vector3), R(), A(), L(), z()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/ForceCamera": 54,
		"../modules/old/Mover": 57,
		"../modules/old/Points.js": 58,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	27: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new r.default,
				t = document.getElementById("canvas-webgl"),
				n = new d.WebGLRenderer({
					antialias: !1,
					canvas: t
				}),
				i = new d.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				v = new d.Scene,
				p = new d.Scene,
				m = new d.OrthographicCamera(-1, 1, 1, -1, 0, 1),
				g = new d.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
				y = new d.Clock,
				x = new o.default,
				b = (new a.default, new s.default),
				w = new c.default,
				M = new l.default,
				_ = [new u.default(400, -500, 200), new u.default(-350, -600, -50), new u.default(-150, -700, -150), new u.default(-500, -900, 0), new u.default(100, -1100, 250), new u.default(-100, -1200, -300), new u.default(150, -1500, -100)],
				S = new h.default(i.texture),
				E = document.getElementsByClassName("js-transition-intro"),
				T = function() {
					t.width = document.body.clientWidth, t.height = window.innerHeight, g.aspect = document.body.clientWidth / window.innerHeight, g.updateProjectionMatrix(), i.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight), S.resize()
				},
				P = function() {
					var e = y.getDelta();
					x.render(e), b.render(e), w.render(e), M.render(e);
					for (var t = 0; t < _.length; t++) _[t].render(e);
					n.render(p, g, i), S.render(e), n.render(v, m)
				},
				A = function e() {
					P(), requestAnimationFrame(e)
				},
				L = function() {
					window.addEventListener("resize", f(function() {
						T()
					}), 1e3), e.renderNext = function() {
						e.isValidSmooth() ? g.position.y = .6 * e.hookes.contents.velocity[1] : g.position.y = -1 * e.scrollTop
					}
				},
				C = function() {
					for (var e = 0; e < E.length; e++) E[e].classList.add("is-shown")
				};
			n.setSize(document.body.clientWidth, window.innerHeight), n.setClearColor(1118481, 1), g.position.z = 800, v.add(S.obj), x.loadTexture(function() {
				p.add(x.obj), p.add(b.obj), p.add(w.obj), p.add(M.obj);
				for (var e = 0; e < _.length; e++) p.add(_[e].obj);
				C()
			}), y.start(), L(), T(), A(), e.start()
		};
		var r = i(e("../modules/smooth_scroll_manager/SmoothScrollManager")),
			o = i(e("../modules/index/TitleObject")),
			a = i(e("../modules/index/FrameObject")),
			s = i(e("../modules/index/SkyOctahedron")),
			c = i(e("../modules/index/SkyOctahedronShell")),
			l = i(e("../modules/index/Ground")),
			u = i(e("../modules/index/Debris")),
			h = i(e("../modules/index/PostEffect")),
			d = e("three/build/three.js"),
			f = e("js-util/debounce")
	}, {
		"../modules/index/Debris": 45,
		"../modules/index/FrameObject": 46,
		"../modules/index/Ground": 47,
		"../modules/index/PostEffect": 48,
		"../modules/index/SkyOctahedron": 49,
		"../modules/index/SkyOctahedronShell": 50,
		"../modules/index/TitleObject": 51,
		"../modules/smooth_scroll_manager/SmoothScrollManager": 112,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	28: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = document.getElementById("canvas-webgl"),
				t = new u.WebGLRenderer({
					antialias: !1,
					canvas: e,
					alpha: !0
				}),
				n = new u.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				i = new u.Scene,
				d = new u.Scene,
				f = new u.OrthographicCamera(-1, 1, 1, -1, 0, 1),
				v = new o.default(45, document.body.clientWidth / window.innerHeight, 1, 1e5),
				p = new a.default(v),
				m = new u.Clock,
				g = new u.Vector2,
				y = new u.Vector2,
				x = new u.Vector2,
				b = !1,
				w = new u.CubeTextureLoader,
				M = new s.default,
				_ = new c.default,
				S = new l.default(n.texture),
				E = function() {
					e.width = document.body.clientWidth, e.height = window.innerHeight, v.aspect = document.body.clientWidth / window.innerHeight, v.updateProjectionMatrix(), S.resize(), t.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight)
				},
				T = function() {
					var e = m.getDelta();
					p.render(), M.render(e), _.render(e), S.render(e), S.uniforms.strengthZoom.value = p.computeZoomLength(), S.uniforms.strengthGlitch.value = p.computeAcceleration(), t.render(d, v, n), t.render(i, f)
				},
				P = function e() {
					T(), requestAnimationFrame(e)
				},
				A = function(e) {
					b = !0
				},
				L = function(e) {
					b && p.rotate(g.x - y.x, g.y - y.y)
				},
				C = function(e) {
					b = !1, p.touchEnd()
				},
				z = function(e) {
					p.zoom(e.deltaY)
				},
				R = function() {
					window.addEventListener("resize", h(function() {
						E()
					}), 1e3), e.addEventListener("mousedown", function(e) {
						e.preventDefault(), g.set(e.clientX, e.clientY), (0, r.default)(g), A()
					}), document.addEventListener("mousemove", function(e) {
						e.preventDefault(), y.set(e.clientX, e.clientY), (0, r.default)(y), L()
					}), document.addEventListener("mouseup", function(e) {
						e.preventDefault(), x.set(e.clientX, e.clientY), (0, r.default)(x), C()
					}), e.addEventListener("wheel", function(e) {
						e.preventDefault(), z(e)
					}), e.addEventListener("touchstart", function(e) {
						e.preventDefault(), g.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(g), A(e.touches[0].clientX, e.touches[0].clientY)
					}), e.addEventListener("touchmove", function(e) {
						e.preventDefault(), y.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(y), L()
					}), e.addEventListener("touchend", function(e) {
						e.preventDefault(), x.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), (0, r.default)(x), C()
					})
				};
			t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(15658734, 1), w.setPath("../img/sketch/instancing/").load(["cubemap_px.png", "cubemap_nx.png", "cubemap_py.png", "cubemap_ny.png", "cubemap_pz.png", "cubemap_nz.png"], function(e) {
				M.init(e), _.init(e), i.add(S.obj), d.add(M.obj), d.add(_.obj)
			}), R(), E(), P()
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/common/ForcePerspectiveCamera")),
			a = i(e("../modules/sketch/instancing/CameraController")),
			s = i(e("../modules/sketch/instancing/Debris")),
			c = i(e("../modules/sketch/instancing/SkyBox")),
			l = i(e("../modules/sketch/instancing/PostEffect.js")),
			u = e("three/build/three.js"),
			h = e("js-util/debounce")
	}, {
		"../modules/common/ForcePerspectiveCamera": 39,
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/instancing/CameraController": 84,
		"../modules/sketch/instancing/Debris": 85,
		"../modules/sketch/instancing/PostEffect.js": 86,
		"../modules/sketch/instancing/SkyBox": 87,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	29: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var t = e("glslify"),
				n = e("../modules/old/util"),
				a = e("../modules/old/Force3"),
				s = e("../modules/old/ForceCamera"),
				c = document.getElementById("canvas-webgl"),
				l = new r.WebGLRenderer({
					antialias: !0,
					canvas: c
				}),
				u = new r.Scene,
				h = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
				d = (new r.Clock, new r.Raycaster),
				f = null,
				v = new a,
				p = new a,
				m = null;
			v.mass = 1.4;
			var g = function(e, t, i) {
					v.acceleration.length() > .1 || !i || (d.setFromCamera(i, t), (f = d.intersectObjects(e.children)[0]) && "MetalCube" == f.object.name && (v.anchor.copy(n.getPolarCoord(n.getRadian(n.getRandomInt(-20, 20)), n.getRadian(n.getRandomInt(0, 360)), n.getRandomInt(30, 90) / 10)), p.applyForce(new r.Vector3(1, 0, 0))))
				},
				y = function() {
					var e = new r.PlaneBufferGeometry(6, 6),
						n = new r.ShaderMaterial({
							uniforms: {
								time: {
									type: "f",
									value: 0
								},
								time2: {
									type: "f",
									value: 0
								},
								acceleration: {
									type: "f",
									value: 0
								},
								resolution: {
									type: "v2",
									value: new r.Vector2(window.innerWidth, window.innerHeight)
								}
							},
							vertexShader: t(["#define GLSLIFY 1\nvarying mat4 m_matrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  m_matrix = inverse(modelMatrix);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]),
							fragmentShader: t(["#define GLSLIFY 1\nuniform float time;\nuniform float time2;\nuniform float acceleration;\nuniform vec2 resolution;\n\nvarying mat4 m_matrix;\n\n// const vec3 cPos = vec3(0.0, 0.0, 10.0);\nconst float targetDepth = 3.5;\nconst vec3 lightDir = vec3(0.577, -0.577, 0.577);\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 rotate(vec3 p, float radian_x, float radian_y, float radian_z) {\n  mat3 mx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, cos(radian_x), -sin(radian_x),\n    0.0, sin(radian_x), cos(radian_x)\n  );\n  mat3 my = mat3(\n    cos(radian_y), 0.0, sin(radian_y),\n    0.0, 1.0, 0.0,\n    -sin(radian_y), 0.0, cos(radian_y)\n  );\n  mat3 mz = mat3(\n    cos(radian_z), -sin(radian_z), 0.0,\n    sin(radian_z), cos(radian_z), 0.0,\n    0.0, 0.0, 1.0\n  );\n  return mx * my * mz * p;\n}\n\nfloat dBox(vec3 p, vec3 size) {\n  return length(max(abs(p) - size, 0.0));\n}\n\nfloat getNoise(vec3 p) {\n  return snoise(p * (0.4 + acceleration * 0.1) + time / 100.0);\n}\n\nvec3 getRotate(vec3 p) {\n  return rotate(p, radians(time2), radians(time2 * 2.0), radians(time2));\n}\n\nfloat distanceFunc(vec3 p) {\n  vec4 p1 = m_matrix * vec4(p, 1.0);\n  float n1 = getNoise(p1.xyz);\n  vec3 p2 = getRotate(p1.xyz);\n  float d1 = dBox(p2, vec3(0.8 - min(acceleration, 0.8))) - 0.2;\n  float d2 = dBox(p2, vec3(1.0)) - n1;\n  float d3 = dBox(p2, vec3(0.5 + acceleration * 0.4)) - n1;\n  return min(max(d1, -d2), d3);\n}\n\nfloat distanceFuncForFill(vec3 p) {\n  vec4 p1 = m_matrix * vec4(p, 1.0);\n  float n = getNoise(p1.xyz);\n  vec3 p2 = getRotate(p1.xyz);\n  return dBox(p2, vec3(0.5 + acceleration * 0.4)) - n;\n}\n\nvec3 getNormal(vec3 p) {\n  const float d = 0.1;\n  return normalize(vec3(\n    distanceFunc(p + vec3(d, 0.0, 0.0)) - distanceFunc(p + vec3(-d, 0.0, 0.0)),\n    distanceFunc(p + vec3(0.0, d, 0.0)) - distanceFunc(p + vec3(0.0, -d, 0.0)),\n    distanceFunc(p + vec3(0.0, 0.0, d)) - distanceFunc(p + vec3(0.0, 0.0, -d))\n  ));\n}\n\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n  vec3 cDir = normalize(cameraPosition * -1.0);\n  vec3 cUp  = vec3(0.0, 1.0, 0.0);\n  vec3 cSide = cross(cDir, cUp);\n\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n  float distance = 0.0;\n  float rLen = 0.0;\n  vec3 rPos = cameraPosition;\n  for(int i = 0; i < 64; i++){\n    distance = distanceFunc(rPos);\n    rLen += distance;\n    rPos = cameraPosition + ray * rLen * 0.2;\n  }\n\n  vec3 normal = getNormal(rPos);\n  if(abs(distance) < 0.5){\n    if (distanceFuncForFill(rPos) > 0.5) {\n      gl_FragColor = vec4(hsv2rgb(vec3(dot(normal, cUp) * 0.8 + time / 400.0, 0.2, dot(normal, cUp) * 0.8 + 0.1)), 1.0);\n    } else {\n      gl_FragColor = vec4(hsv2rgb(vec3(dot(normal, cUp) * 0.1 + time / 400.0, 0.8, dot(normal, cUp) * 0.2 + 0.8)), 1.0);\n    }\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}\n"]),
							transparent: !0
						}),
						i = new r.Mesh(e, n);
					return i.name = "MetalCube", i
				}(),
				x = function() {
					var e = new r.OctahedronGeometry(30, 4),
						n = new r.BufferGeometry;
					n.fromGeometry(e);
					var i = new r.ShaderMaterial({
							uniforms: {
								time: {
									type: "f",
									value: 0
								},
								acceleration: {
									type: "f",
									value: 0
								}
							},
							vertexShader: t(["#define GLSLIFY 1\nuniform float time;\nuniform float acceleration;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvec3 rotate(vec3 p, float radian_x, float radian_y, float radian_z) {\n  mat3 mx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, cos(radian_x), -sin(radian_x),\n    0.0, sin(radian_x), cos(radian_x)\n  );\n  mat3 my = mat3(\n    cos(radian_y), 0.0, sin(radian_y),\n    0.0, 1.0, 0.0,\n    -sin(radian_y), 0.0, cos(radian_y)\n  );\n  mat3 mz = mat3(\n    cos(radian_z), -sin(radian_z), 0.0,\n    sin(radian_z), cos(radian_z), 0.0,\n    0.0, 0.0, 1.0\n  );\n  return mx * my * mz * p;\n}\n\nvec3 getRotate(vec3 p) {\n  return rotate(p, radians(time / 6.0), radians(time / 7.0), radians(time / 8.0));\n}\n\nvoid main() {\n  float updateTime = time / 400.0;\n  vec3 p_rotate = getRotate(position);\n  float noise = snoise(vec3(p_rotate / 12.1 + updateTime * 0.5));\n  vec3 p_noise = p_rotate + p_rotate * noise / 20.0 * (min(acceleration, 6.0) + 1.0);\n\n  vPosition = p_noise;\n  vColor = hsv2rgb(vec3(updateTime + position.y / 400.0, 0.05 + min(acceleration / 10.0, 0.25), 1.0));\n  invertMatrix = inverse(modelMatrix);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(p_noise, 1.0);\n}\n"]),
							fragmentShader: t(["#define GLSLIFY 1\nuniform float time;\nuniform float acceleration;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 inv_light = normalize(invertMatrix * vec4(0.7, -0.7, 0.7, 1.0)).xyz;\n  float diff = (dot(normal, inv_light) + 1.0) / 4.0 + 0.4;\n  gl_FragColor = vec4(vColor * diff, 1.0);\n}\n"]),
							flatShading: !0,
							side: r.BackSide
						}),
						o = new r.Mesh(n, i);
					return o.name = "Background", o
				}(),
				b = function() {
					u.add(y), u.add(x), h.setPolarCoord(0, n.getRadian(90), 24)
				},
				w = function() {
					c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), l.setSize(window.innerWidth, window.innerHeight), y.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
				},
				M = function() {
					g(u, h, m), v.applyHook(0, .12), v.applyDrag(.01), v.updateVelocity(), p.applyHook(0, .005), p.applyDrag(.2), p.updateVelocity(), y.position.copy(v.velocity), y.material.uniforms.time.value++, y.material.uniforms.time2.value += 1 + Math.floor(4 * v.acceleration.length()), y.material.uniforms.acceleration.value = v.acceleration.length(), x.material.uniforms.time.value++, x.material.uniforms.acceleration.value = p.velocity.length(), h.force.position.applyHook(0, .025), h.force.position.applyDrag(.2), h.force.position.updateVelocity(), h.updatePosition(), h.lookAtCenter(), l.render(u, h)
				},
				_ = function e() {
					M(), requestAnimationFrame(e)
				},
				S = function() {
					var e = new r.Vector2,
						t = new r.Vector2,
						n = new r.Vector2,
						a = function(t, n, r) {
							e.set(t, n), (0, i.default)(e)
						},
						s = function(e, n, r) {
							t.set(e, n), (0, i.default)(t), m = t
						},
						l = function(e, t, i) {
							n.set(e, t)
						},
						u = function() {
							n.set(0, 0)
						};
					window.addEventListener("resize", o(function() {
						w()
					}), 1e3), c.addEventListener("mousedown", function(e) {
						e.preventDefault(), a(e.clientX, e.clientY)
					}), c.addEventListener("mousemove", function(e) {
						e.preventDefault(), s(e.clientX, e.clientY)
					}), c.addEventListener("mouseup", function(e) {
						e.preventDefault(), l(e.clientX, e.clientY)
					}), c.addEventListener("touchstart", function(e) {
						e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchmove", function(e) {
						e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
					}), c.addEventListener("touchend", function(e) {
						e.preventDefault(), l(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), u()
					})
				};
			l.setSize(window.innerWidth, window.innerHeight), l.setClearColor(15658734, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), S(), b(), w(), _()
		};
		var i = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../modules/common/normalizeVector2")),
			r = e("three/build/three.js"),
			o = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/old/Force3": 53,
		"../modules/old/ForceCamera": 54,
		"../modules/old/util": 59,
		glslify: 2,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	30: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = document.getElementById("canvas-webgl"),
				n = new i.WebGLRenderer({
					alpha: !0,
					antialias: !0,
					canvas: t
				}),
				s = new i.Scene,
				c = new i.PerspectiveCamera,
				l = new i.Clock,
				u = new i.FontLoader;
			c.far = 5e4, c.setFocalLength(24);
			var h = new o,
				d = new a,
				f = function() {
					var e = l.getDelta();
					h.render(e), n.render(s, c)
				},
				v = function e() {
					f(), requestAnimationFrame(e)
				},
				p = function() {
					c.aspect = e.x / e.y, c.updateProjectionMatrix()
				},
				m = function() {
					e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, p(), n.setSize(e.x, e.y)
				},
				g = function() {
					window.addEventListener("resize", r(m), 1e3), window.addEventListener("click", function() {
						h.transform()
					})
				};
			u.load("https://threejs.org/examples/fonts/helvetiker_bold.typeface.json", function(e) {
				h.createObj(e), d.createObj(), s.add(h.objWire), s.add(h.objPoints), s.add(d.obj), n.setClearColor(1118481, 1), c.position.set(0, 0, 1e3), c.lookAt(new i.Vector3), l.start(), g(), m(), v()
			})
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("../modules/sketch/node_text/NodeText").default,
			a = e("../modules/sketch/node_text/BackgroundSphere").default
	}, {
		"../modules/sketch/node_text/BackgroundSphere": 88,
		"../modules/sketch/node_text/NodeText": 89,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	31: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = document.getElementById("canvas-webgl"),
				t = new l.WebGLRenderer({
					antialias: !1,
					canvas: e
				}),
				n = new l.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				i = new l.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				h = new l.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				d = new l.Scene,
				f = new l.Scene,
				v = new l.OrthographicCamera(-1, 1, 1, -1, 0, 1),
				p = new l.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
				m = new l.Clock,
				g = new l.Vector2,
				y = new l.Vector2,
				x = new l.Vector2,
				b = !1,
				w = new c.default,
				M = new o.default(n.texture),
				_ = new a.default(i.texture, 1, 0),
				S = new a.default(h.texture, 0, 1),
				E = new s.default(n.texture, i.texture);
			w.init(t);
			var T = function() {
					e.width = document.body.clientWidth, e.height = window.innerHeight, p.aspect = document.body.clientWidth / window.innerHeight, p.updateProjectionMatrix(), _.resize(), S.resize(), n.setSize(document.body.clientWidth, window.innerHeight), i.setSize(document.body.clientWidth, window.innerHeight), h.setSize(document.body.clientWidth, window.innerHeight), t.setSize(document.body.clientWidth, window.innerHeight)
				},
				P = function() {
					var e = m.getDelta();
					w.render(t, e), t.render(f, p, n), d.add(M.obj), t.render(d, p, i), d.remove(M.obj), d.add(_.obj), t.render(d, p, h), d.remove(_.obj), d.add(S.obj), t.render(d, p, i), d.remove(S.obj), d.add(E.obj), t.render(d, v), d.remove(E.obj)
				},
				A = function e() {
					P(), requestAnimationFrame(e)
				},
				L = function(e) {
					b = !0, w.touchStart(g)
				},
				C = function(e) {
					b && w.touchMove(y)
				},
				z = function(e) {
					b = !1, w.touchEnd()
				},
				R = function() {
					b = !1, w.touchEnd()
				},
				I = function() {
					window.addEventListener("resize", u(function() {
						T()
					}), 1e3), e.addEventListener("mousedown", function(e) {
						e.preventDefault(), g.set(e.clientX, e.clientY), (0, r.default)(g), L()
					}), e.addEventListener("mousemove", function(e) {
						e.preventDefault(), y.set(e.clientX, e.clientY), (0, r.default)(y), C()
					}), e.addEventListener("mouseup", function(e) {
						e.preventDefault(), x.set(e.clientX, e.clientY), (0, r.default)(x), z()
					}), e.addEventListener("touchstart", function(e) {
						e.preventDefault(), g.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(g), L(e.touches[0].clientX, e.touches[0].clientY)
					}), e.addEventListener("touchmove", function(e) {
						e.preventDefault(), y.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(y), C()
					}), e.addEventListener("touchend", function(e) {
						e.preventDefault(), (0, r.default)(x), x.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), z()
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), x.set(0, 0), R()
					})
				};
			t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(1118481, 1), p.position.set(0, 0, 1e3), p.lookAt(new l.Vector3), f.add(w.obj), I(), T(), A()
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/sketch/particle/PostEffectBright.js")),
			a = i(e("../modules/sketch/particle/PostEffectBlur.js")),
			s = i(e("../modules/sketch/particle/PostEffectBloom.js")),
			c = i(e("../modules/sketch/particle/Points")),
			l = e("three/build/three.js"),
			u = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/particle/Points": 90,
		"../modules/sketch/particle/PostEffectBloom.js": 91,
		"../modules/sketch/particle/PostEffectBlur.js": 92,
		"../modules/sketch/particle/PostEffectBright.js": 93,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	32: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			for (var e = document.getElementById("canvas-webgl"), t = new a.WebGLRenderer({
					antialias: !1,
					canvas: e,
					alpha: !0
				}), n = new a.Scene, i = new a.PerspectiveCamera(90, document.body.clientWidth / window.innerHeight, 1, 1e4), c = new a.Clock, l = new a.Vector2, u = new a.Vector2, h = new a.Vector2, d = !1, f = 0, v = 0, p = [], m = function(e) {
					(v += e) > 1 && (p[f].show(), f = f + 1 >= p.length - 1 ? 0 : f + 1, v = 0)
				}, g = 0; g < 20; g++) p[g] = new o.default, n.add(p[g].obj);
			var y = function() {
					e.width = document.body.clientWidth, e.height = window.innerHeight, i.aspect = document.body.clientWidth / window.innerHeight, i.updateProjectionMatrix(), t.setSize(document.body.clientWidth, window.innerHeight)
				},
				x = function() {
					var e = c.getDelta();
					m(e);
					for (var r = 0; r < p.length; r++) p[r].render(e);
					t.render(n, i)
				},
				b = function e() {
					x(), requestAnimationFrame(e)
				},
				w = function(e) {
					d = !0
				},
				M = function(e) {},
				_ = function(e) {
					d = !1
				},
				S = function() {
					window.addEventListener("resize", s(function() {
						y()
					}), 1e3), e.addEventListener("mousedown", function(e) {
						e.preventDefault(), l.set(e.clientX, e.clientY), (0, r.default)(l), w()
					}), document.addEventListener("mousemove", function(e) {
						e.preventDefault(), u.set(e.clientX, e.clientY), (0, r.default)(u), M()
					}), document.addEventListener("mouseup", function(e) {
						e.preventDefault(), h.set(e.clientX, e.clientY), (0, r.default)(h), _()
					}), e.addEventListener("touchstart", function(e) {
						e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(l), w(e.touches[0].clientX, e.touches[0].clientY)
					}), e.addEventListener("touchmove", function(e) {
						e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(u), M()
					}), e.addEventListener("touchend", function(e) {
						e.preventDefault(), h.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), (0, r.default)(h), _()
					})
				};
			t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(15856113, 1), i.position.set(0, 0, 1e3), i.lookAt(new a.Vector3), S(), y(), b()
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/sketch/puddle/Puddle.js")),
			a = e("three/build/three.js"),
			s = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/puddle/Puddle.js": 94,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	33: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = document.getElementById("canvas-webgl"),
				t = new s.WebGLRenderer({
					antialias: !0,
					canvas: e
				}),
				n = new s.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
				i = new s.Scene,
				l = new s.Scene,
				u = new s.PerspectiveCamera(24, document.body.clientWidth / window.innerHeight, 1, 15e3),
				h = new s.Clock,
				d = new s.Vector2,
				f = new s.Vector2,
				v = new s.Vector2,
				p = new s.Vector2,
				m = new Uint8Array(4),
				g = !1,
				y = new r.default,
				x = new o.default,
				b = new a.default,
				w = function() {
					e.width = document.body.clientWidth, e.height = window.innerHeight, u.aspect = document.body.clientWidth / window.innerHeight, u.updateProjectionMatrix(), t.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight), x.resize()
				},
				M = function() {
					var e = h.getDelta();
					t.setClearColor(15856113, 1), y.render(e), x.render(t, i, e), b.render(t, i, e), t.render(i, u)
				},
				_ = function e() {
					M(), requestAnimationFrame(e)
				},
				S = function(e) {
					g = !0
				},
				E = function(e) {
					g ? e && y.rotate(2 * (f.x - v.x)) : (t.setClearColor(16777215, 1), t.render(l, u, n), t.readRenderTargetPixels(n, f.x, n.height - f.y, 1, 1, m), y.picked(m[0] << 16 | m[1] << 8 | m[2]))
				},
				T = function(e) {
					g = !1
				},
				P = function(e) {
					y.rotate(e.deltaY)
				},
				A = function() {
					window.addEventListener("resize", c(function() {
						w()
					}), 1e3), e.addEventListener("mousedown", function(e) {
						e.preventDefault(), d.set(e.clientX, e.clientY), S()
					}), document.addEventListener("mousemove", function(e) {
						e.preventDefault(), f.set(e.clientX, e.clientY), E(!1)
					}), document.addEventListener("mouseup", function(e) {
						e.preventDefault(), p.set(e.clientX, e.clientY), T()
					}), e.addEventListener("wheel", function(e) {
						e.preventDefault(), P(e)
					}), e.addEventListener("touchstart", function(e) {
						e.preventDefault(), d.set(e.touches[0].clientX, e.touches[0].clientY), f.set(e.touches[0].clientX, e.touches[0].clientY), v.set(e.touches[0].clientX, e.touches[0].clientY), S(e.touches[0].clientX, e.touches[0].clientY)
					}), e.addEventListener("touchmove", function(e) {
						e.preventDefault(), f.set(e.touches[0].clientX, e.touches[0].clientY), E(!0), v.set(e.touches[0].clientX, e.touches[0].clientY)
					}), e.addEventListener("touchend", function(e) {
						e.preventDefault(), p.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), T()
					})
				};
			t.setSize(document.body.clientWidth, window.innerHeight), u.position.set(0, 400, -3e3), u.lookAt(new s.Vector3(0, 0, 0)), x.mirrorCamera.position.set(0, -400, -3e3), x.mirrorCamera.lookAt(new s.Vector3(0, 0, 0)), y.core.obj.position.set(0, 80, 0), y.wire.obj.position.set(0, 80, 0), y.wire.objPicked.position.set(0, 80, 0), x.obj.rotation.set(-.5 * Math.PI, 0, 0), i.add(y.core.obj), i.add(y.wire.obj), i.add(x.obj), i.add(b.obj), i.add(b.cubeCamera), l.add(y.wire.objPicked), A(), w(), _()
		};
		i(e("../modules/common/normalizeVector2"));
		var r = i(e("../modules/sketch/reel/Boxes.js")),
			o = i(e("../modules/sketch/reel/Floor.js")),
			a = i(e("../modules/sketch/reel/Hill.js")),
			s = e("three/build/three.js"),
			c = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/reel/Boxes.js": 95,
		"../modules/sketch/reel/Floor.js": 97,
		"../modules/sketch/reel/Hill.js": 98,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	34: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = new i.Vector2,
				t = new i.Vector2,
				n = document.getElementById("canvas-webgl"),
				s = new i.WebGLRenderer({
					alpha: !0,
					antialias: !0,
					canvas: n
				}),
				c = new i.Scene,
				l = new i.PerspectiveCamera,
				u = new i.Clock;
			l.far = 5e4, l.setFocalLength(24);
			var h = {
					points: "../img/sketch/image_data/elephant.png"
				},
				d = new a,
				f = function() {
					var e = u.getDelta();
					d.render(e, l, t), s.render(c, l)
				},
				v = function e() {
					f(), requestAnimationFrame(e)
				},
				p = function() {
					l.aspect = e.x / e.y, l.updateProjectionMatrix()
				},
				m = function() {
					e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, p(), s.setSize(e.x, e.y)
				},
				g = function(n) {
					t.set(n.clientX / e.x * 2 - 1, -n.clientY / e.y * 2 + 1)
				},
				y = function() {
					window.addEventListener("resize", r(m), 1e3), window.addEventListener("mousemove", g)
				};
			o(h, function(e) {
				s.setClearColor(8037324, 1), l.position.set(0, 0, 1e3), l.lookAt(0, 0, 0), u.start(), d.createObj(e.points), c.add(d.obj), y(), m(), v()
			})
		};
		var i = e("three/build/three.js"),
			r = e("js-util/debounce"),
			o = e("../modules/common/loadTexs").default,
			a = e("../modules/sketch/repel/Points").default
	}, {
		"../modules/common/loadTexs": 42,
		"../modules/sketch/repel/Points": 100,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	35: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			var e = {
					x: 0,
					y: 0
				},
				t = document.getElementById("canvas-webgl"),
				n = new h.WebGLRenderer({
					antialias: !0,
					canvas: t,
					alpha: !0
				}),
				i = new h.WebGLRenderTarget(0, 0),
				f = new h.WebGLRenderTarget(0, 0),
				v = new h.WebGLRenderTarget(0, 0),
				p = new h.Scene,
				m = new h.Scene,
				g = new h.OrthographicCamera(-1, 1, 1, -1, 0, 1),
				y = new h.PerspectiveCamera(30, 1, 1, 15e3),
				x = new h.Clock,
				b = new h.TextureLoader,
				w = new h.Vector2,
				M = new h.Vector2,
				_ = new h.Vector2,
				S = !1,
				E = [],
				T = new a.default(32),
				P = new s.default(e),
				A = new c.default(.7, i.texture),
				L = new l.default(f.texture, 1, 0, 1),
				C = new l.default(v.texture, 0, 1, 1),
				z = new u.default(.7, i.texture, f.texture),
				R = ["/sketch-threejs/img/sketch/transform/tex.png", "/sketch-threejs/img/sketch/transform/flower.jpg"],
				I = [],
				j = function() {
					y.aspect = e.x / e.y, y.updateProjectionMatrix(), P.resize(e)
				},
				O = function() {
					e.x = document.body.clientWidth, e.y = window.innerHeight, t.width = e.x, t.height = e.y, j(), L.resize(e), C.resize(e), i.setSize(e.x, e.y), f.setSize(e.x, e.y), v.setSize(e.x, e.y), n.setSize(e.x, e.y)
				},
				D = function() {
					for (var e = x.getDelta(), t = 0; t < E.length; t++) E[t].render(n, e);
					T.render(e), P.render(n, p, m, g, e), n.render(m, y, i), A.render(n, p, g, f), L.render(n, p, g, v), C.render(n, p, g, f), z.render(n, p, g)
				},
				F = function e() {
					D(), requestAnimationFrame(e)
				},
				U = function(e) {
					S = !0, E[0].isTransform = !E[0].isTransform
				},
				k = function(e) {},
				N = function(e) {
					S = !1
				},
				B = function() {
					S = !1
				},
				G = function() {
					window.addEventListener("resize", d(O), 1e3), t.addEventListener("mousedown", function(e) {
						e.preventDefault(), w.set(e.clientX, e.clientY), (0, r.default)(w), U()
					}), t.addEventListener("mousemove", function(e) {
						e.preventDefault(), M.set(e.clientX, e.clientY), (0, r.default)(M), k()
					}), t.addEventListener("mouseup", function(e) {
						e.preventDefault(), _.set(e.clientX, e.clientY), (0, r.default)(_), N()
					}), t.addEventListener("touchstart", function(e) {
						e.preventDefault(), w.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(w), U(e.touches[0].clientX, e.touches[0].clientY)
					}), t.addEventListener("touchmove", function(e) {
						e.preventDefault(), M.set(e.touches[0].clientX, e.touches[0].clientY), (0, r.default)(M), k()
					}), t.addEventListener("touchend", function(e) {
						e.preventDefault(), _.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), (0, r.default)(_), N()
					}), window.addEventListener("mouseout", function() {
						event.preventDefault(), _.set(0, 0), B()
					})
				};
			! function() {
				O(), G(), n.setClearColor(16382457, 1), y.position.set(400.1, 60, -400), P.mirrorCamera.position.set(y.position.x, -1 * y.position.y, y.position.z), y.lookAt(new h.Vector3(0, 60, 0)), P.mirrorCamera.lookAt(new h.Vector3(0, -60, 0));
				for (var e = 0, t = 0; t < R.length; t++) ! function() {
					var n = t;
					b.load(R[t], function(t) {
						if (t.magFilter = h.NearestFilter, t.minFilter = h.NearestFilter, t.repeat = h.RepeatWrapping, I[n] = t, ++e >= R.length) {
							for (var i = 0; i < 1; i++) E[i] = new o.default(i, I[0], I[1]), m.add(E[i].obj);
							T.addButterflies(E), m.add(T.obj), P.add(p, m), p.add(A.obj), p.add(L.obj), p.add(C.obj), p.add(z.obj), F()
						}
					})
				}()
			}()
		};
		var r = i(e("../modules/common/normalizeVector2")),
			o = i(e("../modules/sketch/transform/Butterfly")),
			a = i(e("../modules/sketch/transform/Points")),
			s = i(e("../modules/sketch/transform/Floor.js")),
			c = i(e("../modules/sketch/transform/PostEffectBright.js")),
			l = i(e("../modules/sketch/transform/PostEffectBlur.js")),
			u = i(e("../modules/sketch/transform/PostEffectBloom.js")),
			h = e("three/build/three.js"),
			d = e("js-util/debounce")
	}, {
		"../modules/common/normalizeVector2": 43,
		"../modules/sketch/transform/Butterfly": 101,
		"../modules/sketch/transform/Floor.js": 102,
		"../modules/sketch/transform/Points": 103,
		"../modules/sketch/transform/PostEffectBloom.js": 104,
		"../modules/sketch/transform/PostEffectBlur.js": 105,
		"../modules/sketch/transform/PostEffectBright.js": 106,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	36: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}
		var r = i(e("./modules/common/ConsoleSignature.js")),
			o = i(e("./modules/common/redirectOldSketches.js")),
			a = document.querySelector(".l-page").dataset.id;
		new r.default;
		! function() {
			if (e("./init/common.js").default(), "index" == a) e("./init/index.js").default();
			else switch (e("./init/commonSketch.js").default(), a) {
				case "fog":
					e("./init/fog.js").default();
					break;
				case "node_text":
					e("./init/nodeText.js").default();
					break;
				case "repel":
					e("./init/repel.js").default();
					break;
				case "flame":
					e("./init/flame.js").default();
					break;
				case "cyberspace":
					e("./init/cyberspace.js").default();
					break;
				case "beam":
					e("./init/beam.js").default();
					break;
				case "blink":
					e("./init/blink.js").default();
					break;
				case "transform":
					e("./init/transform.js").default();
					break;
				case "egg":
					e("./init/egg.js").default();
					break;
				case "butterfly":
					e("./init/butterfly.js").default();
					break;
				case "puddle":
					e("./init/puddle.js").default();
					break;
				case "reel":
					e("./init/reel.js").default();
					break;
				case "glitch":
					e("./init/glitch.js").default();
					break;
				case "instancing":
					e("./init/instancing.js").default();
					break;
				case "particle":
					e("./init/particle.js").default();
					break;
				case "attract":
					e("./init/attract.js").default();
					break;
				case "hole":
					e("./init/hole.js").default();
					break;
				case "metal_cube":
					e("./init/metalCube.js").default();
					break;
				case "distort":
					e("./init/distort.js").default();
					break;
				case "image_data":
					e("./init/imageData.js").default();
					break;
				case "gallery":
					e("./init/gallery.js").default();
					break;
				case "comet":
					e("./init/comet.js").default();
					break;
				case "hyper_space":
					e("./init/hyperSpace.js").default();
					break;
				case "fire_ball":
					e("./init/fireBall.js").default()
			}(0, o.default)()
		}()
	}, {
		"./init/attract.js": 9,
		"./init/beam.js": 10,
		"./init/blink.js": 11,
		"./init/butterfly.js": 12,
		"./init/comet.js": 13,
		"./init/common.js": 14,
		"./init/commonSketch.js": 15,
		"./init/cyberspace.js": 16,
		"./init/distort.js": 17,
		"./init/egg.js": 18,
		"./init/fireBall.js": 19,
		"./init/flame.js": 20,
		"./init/fog.js": 21,
		"./init/gallery.js": 22,
		"./init/glitch.js": 23,
		"./init/hole.js": 24,
		"./init/hyperSpace.js": 25,
		"./init/imageData.js": 26,
		"./init/index.js": 27,
		"./init/instancing.js": 28,
		"./init/metalCube.js": 29,
		"./init/nodeText.js": 30,
		"./init/particle.js": 31,
		"./init/puddle.js": 32,
		"./init/reel.js": 33,
		"./init/repel.js": 34,
		"./init/transform.js": 35,
		"./modules/common/ConsoleSignature.js": 37,
		"./modules/common/redirectOldSketches.js": 44
	}],
	37: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = function() {
				function e() {
					i(this, e), this.message = "created by yoichi kobayashi", this.url = "http://www.tplh.net", this.show()
				}
				return r(e, [{
					key: "show",
					value: function() {
						if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
							var e = ["\n%c " + this.message + " %c%c " + this.url + " \n\n", "color: #fff; background: #222; padding:3px 0;", "padding:3px 1px;", "color: #fff; background: #47c; padding:3px 0;"];
							console.log.apply(console, e)
						} else window.console && console.log(this.message + " " + this.url)
					}
				}]), e
			}();
		n.default = o
	}, {}],
	38: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var i = e("gl-matrix");
		n.default = {
			updateVelocity: function(e, t, n) {
				i.vec3.scale(t, t, 1 / n), i.vec3.add(e, e, t)
			},
			applyFriction: function(e, t, n) {
				var r = [0, 0, 0];
				i.vec3.scale(r, e, -1);
				i.vec3.normalize(r, r), i.vec3.scale(r, r, t), i.vec3.add(e, e, r)
			},
			applyDrag: function(e, t) {
				var n = [0, 0, 0];
				i.vec3.scale(n, e, -1), i.vec3.normalize(n, n), i.vec3.scale(n, n, i.vec3.length(e) * t), i.vec3.add(e, e, n)
			},
			applyHook: function(e, t, n, r, o) {
				var a = [0, 0, 0];
				i.vec3.sub(a, e, n);
				var s = i.vec3.length(a) - r;
				i.vec3.normalize(a, a), i.vec3.scale(a, a, -1 * o * s), i.vec3.add(t, t, a)
			}
		}
	}, {
		"gl-matrix": 1
	}],
	39: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}

		function r(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			return !t || "object" != typeof t && "function" != typeof t ? e : t
		}

		function o(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
			e.prototype = Object.create(t && t.prototype, {
				constructor: {
					value: e,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var a = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			s = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("./force3")),
			c = e("three/build/three.js"),
			l = function(e) {
				function t(e, n, o, a) {
					i(this, t);
					var s = r(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, o, a));
					return s.k = .02, s.d = .2, s.velocity = [0, 0, 0], s.acceleration = [0, 0, 0], s.anchor = [0, 0, 0], s.lookK = .02, s.lookD = .2, s.lookVelocity = [0, 0, 0], s.lookAcceleration = [0, 0, 0], s.lookAnchor = [0, 0, 0], s
				}
				return o(t, c.PerspectiveCamera), a(t, [{
					key: "updatePosition",
					value: function() {
						s.default.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), s.default.applyDrag(this.acceleration, this.d), s.default.updateVelocity(this.velocity, this.acceleration, 1)
					}
				}, {
					key: "updateLook",
					value: function() {
						s.default.applyHook(this.lookVelocity, this.lookAcceleration, this.lookAnchor, 0, this.lookK), s.default.applyDrag(this.lookAcceleration, this.lookD), s.default.updateVelocity(this.lookVelocity, this.lookAcceleration, 1)
					}
				}, {
					key: "render",
					value: function() {
						this.updatePosition(), this.updateLook(), this.position.set(this.velocity[0], this.velocity[1], this.velocity[2]), this.lookAt(this.lookVelocity[0], this.lookVelocity[1], this.lookVelocity[2])
					}
				}]), t
			}();
		n.default = l
	}, {
		"./force3": 41,
		"three/build/three.js": 8
	}],
	40: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n, r, a) {
					i(this, e), this.side = 0, this.aScene = new o.Scene, this.vScene = new o.Scene, this.camera = new o.PerspectiveCamera(45, 1, 1, 1e3), this.option = {
						type: o.FloatType,
						minFilter: o.LinearFilter,
						magFilter: o.NearestFilter
					}, this.acceleration = [new o.WebGLRenderTarget(0, 0, this.option), new o.WebGLRenderTarget(0, 0, this.option)], this.velocity = [new o.WebGLRenderTarget(0, 0, this.option), new o.WebGLRenderTarget(0, 0, this.option)], this.aUniforms = {
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						velocity: {
							type: "t",
							value: null
						},
						acceleration: {
							type: "t",
							value: null
						},
						time: {
							type: "f",
							value: 0
						}
					}, this.vUniforms = {
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						side: {
							type: "f",
							value: 0
						},
						velocityInit: {
							type: "t",
							value: null
						},
						velocity: {
							type: "t",
							value: null
						},
						acceleration: {
							type: "t",
							value: null
						},
						time: {
							type: "f",
							value: 0
						}
					}, this.accelerationMesh = this.createMesh(this.aUniforms, t, n), this.velocityMesh = this.createMesh(this.vUniforms, r, a), this.uvs = [], this.targetIndex = 0
				}
				return r(e, [{
					key: "init",
					value: function(e, t, n, i) {
						this.side = Math.ceil(Math.sqrt(t.length / 3)), this.vUniforms.side.value = this.side;
						for (var r = [], s = 0; s < 3 * Math.pow(this.side, 2); s += 3) void 0 != t[s] ? (r[s + 0] = t[s + 0], r[s + 1] = t[s + 1], r[s + 2] = t[s + 2], this.uvs[s / 3 * 2 + 0] = s / 3 % this.side / (this.side - 1), this.uvs[s / 3 * 2 + 1] = Math.floor(s / 3 / this.side) / (this.side - 1)) : (r[s + 0] = 0, r[s + 1] = 0, r[s + 2] = 0);
						if (n) {
							var c = Object.keys(n);
							if (c.length)
								for (s = 0; s < c.length; s++) {
									for (var l = n[c[s]], u = l.array.length; u < r.length / 3 * l.itemSize; u++) l.array.push(0);
									this.accelerationMesh.geometry.addAttribute(c[s], new o.BufferAttribute(new Float32Array(l.array), l.itemSize))
								}
						}
						if (i) {
							var h = Object.keys(i);
							if (h.length)
								for (s = 0; s < h.length; s++) {
									for (var d = i[h[s]], u = d.array.length; u < r.length / 3 * d.itemSize; u++) d.array.push(0);
									this.velocityMesh.geometry.addAttribute(h[s], new o.BufferAttribute(new Float32Array(d.array), d.itemSize))
								}
						}
						this.vUniforms.velocityInit.value = new o.DataTexture(new Float32Array(r), this.side, this.side, o.RGBFormat, o.FloatType), this.vUniforms.velocityInit.value.needsUpdate = !0;
						for (var f = new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.ShaderMaterial({
								uniforms: {
									velocity: {
										type: "t",
										value: this.vUniforms.velocityInit.value
									}
								},
								vertexShader: a(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
								fragmentShader: a(["#define GLSLIFY 1\nuniform sampler2D velocity;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  gl_FragColor = texture2D(velocity, vUv);\n}\n"])
							})), s = 0; s < 2; s++) this.acceleration[s].setSize(this.side, this.side), this.velocity[s].setSize(this.side, this.side);
						this.vScene.add(this.camera), this.vScene.add(f), e.render(this.vScene, this.camera, this.velocity[0]), e.render(this.vScene, this.camera, this.velocity[1]), this.vScene.remove(f), this.vScene.add(this.velocityMesh), this.aScene.add(this.accelerationMesh)
					}
				}, {
					key: "createMesh",
					value: function(e, t, n) {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.ShaderMaterial({
							uniforms: e,
							vertexShader: t,
							fragmentShader: n
						}))
					}
				}, {
					key: "render",
					value: function(e, t) {
						var n = Math.abs(this.targetIndex - 1),
							i = this.targetIndex;
						this.aUniforms.acceleration.value = this.acceleration[n].texture, this.aUniforms.velocity.value = this.velocity[i].texture, e.render(this.aScene, this.camera, this.acceleration[i]), this.vUniforms.acceleration.value = this.acceleration[i].texture, this.vUniforms.velocity.value = this.velocity[i].texture, e.render(this.vScene, this.camera, this.velocity[n]), this.targetIndex = n, this.aUniforms.time.value += t, this.vUniforms.time.value += t
					}
				}, {
					key: "getBufferAttributeUv",
					value: function() {
						return new o.BufferAttribute(new Float32Array(this.uvs), 2)
					}
				}, {
					key: "getCurrentVelocity",
					value: function() {
						return this.velocity[Math.abs(this.targetIndex - 1)].texture
					}
				}, {
					key: "getCurrentAcceleration",
					value: function() {
						return this.acceleration[Math.abs(this.targetIndex - 1)].texture
					}
				}, {
					key: "mergeAUniforms",
					value: function(e) {
						this.aUniforms = Object.assign(this.aUniforms, e)
					}
				}, {
					key: "mergeVUniforms",
					value: function(e) {
						this.vUniforms = Object.assign(this.vUniforms, e)
					}
				}, {
					key: "resize",
					value: function(e) {
						this.aUniforms.resolution.value.set(document.body.clientWidth, window.clientHeight), this.vUniforms.resolution.value.set(document.body.clientWidth, window.clientHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	41: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var i = e("gl-matrix");
		n.default = {
			updateVelocity: function(e, t, n) {
				i.vec3.scale(t, t, 1 / n), i.vec3.add(e, e, t)
			},
			applyFriction: function(e, t, n) {
				var r = [0, 0, 0];
				i.vec3.scale(r, e, -1);
				i.vec3.normalize(r, r), i.vec3.scale(r, r, t), i.vec3.add(e, e, r)
			},
			applyDrag: function(e, t) {
				var n = [0, 0, 0];
				i.vec3.scale(n, e, -1), i.vec3.normalize(n, n), i.vec3.scale(n, n, i.vec3.length(e) * t), i.vec3.add(e, e, n)
			},
			applyHook: function(e, t, n, r, o) {
				var a = [0, 0, 0];
				i.vec3.sub(a, e, n);
				var s = i.vec3.length(a) - r;
				i.vec3.normalize(a, a), i.vec3.scale(a, a, -1 * o * s), i.vec3.add(t, t, a)
			}
		}
	}, {
		"gl-matrix": 1
	}],
	42: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function(e, t) {
			var n = Object.keys(e).length,
				o = {},
				a = 0;
			for (var s in e) ! function() {
				var c = s;
				e.hasOwnProperty(c) && r.load(e[c], function(e) {
					e.repeat = i.RepeatWrapping, o[c] = e, ++a >= n && t(o)
				})
			}()
		};
		var i = e("three/build/three.js"),
			r = new i.TextureLoader
	}, {
		"three/build/three.js": 8
	}],
	43: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function(e) {
			e.x = e.x / document.body.clientWidth * 2 - 1, e.y = -e.y / window.innerHeight * 2 + 1
		}
	}, {}],
	44: [function(e, t, n) {
		"use strict";
		Object.defineProperty(n, "__esModule", {
			value: !0
		}), n.default = function() {
			for (var e = decodeURIComponent(location.search.substring(1)).split("&"), t = 0; t < e.length; t++)
				if (!(e[t].indexOf("sketch_id") < 0)) {
					var n = e[t].replace("sketch_id=", "");
					switch (n = parseInt(n, 10)) {
						case 9:
							location.href = "/sketch-threejs/sketch/attract.html";
							break;
						case 8:
							location.href = "/sketch-threejs/sketch/hole.html";
							break;
						case 7:
							location.href = "/sketch-threejs/sketch/metal_cube.html";
							break;
						case 6:
							location.href = "/sketch-threejs/sketch/distort.html";
							break;
						case 5:
							location.href = "/sketch-threejs/sketch/image_data.html";
							break;
						case 4:
							location.href = "/sketch-threejs/sketch/gallery.html";
							break;
						case 3:
							location.href = "/sketch-threejs/sketch/comet.html";
							break;
						case 2:
							location.href = "/sketch-threejs/sketch/hyper_space.html";
							break;
						case 1:
							location.href = "/sketch-threejs/sketch/fire_ball.html"
					}
				}
		}
	}, {}],
	45: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e(t, n, r) {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						rotate: {
							type: "f",
							value: 10 * Math.random()
						}
					}, this.obj = this.createObj(), this.obj.position.set(t, n, r)
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.BoxBufferGeometry(100, 100, 100), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  mat4 rotateMat = calcRotateMat4(vec3(time * 0.1 + rotate));\n  vec4 updatePosition = rotateMat * vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec3 hsv = vec3(0.5 + time * 0.1, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n  gl_FragColor = vec4(rgb, 0.25);\n}\n"]),
							transparent: !0,
							wireframe: !0
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	46: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						resolution: {
							type: "v2",
							value: new o.Vector2
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.BufferGeometry,
							t = new Float32Array([0, Math.sqrt(3) / 2, 0, -1, Math.sqrt(3) / 2 * -1, 0, 1, Math.sqrt(3) / 2 * -1, 0]),
							n = new Uint16Array([0, 1, 2, 0]);
						return e.addAttribute("position", new o.BufferAttribute(t, 3)), e.setIndex(new o.BufferAttribute(n, 1)), new o.Line(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute float index;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["#define GLSLIFY 1\nvoid main() {\n  gl_FragColor = vec4(1.0);\n}\n"])
						}))
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	47: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = this.createObj(), this.obj.position.set(0, -200, 0), this.obj.rotation.set(s.radians(-90), 0, 0)
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(1024, 1024, 32, 32), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  float sin1 = sin((position.x + position.y) * 0.2 + time * 0.5);\n  float sin2 = sin((position.x - position.y) * 0.4 + time * 2.0);\n  float sin3 = sin((position.x + position.y) * -0.6 + time);\n  vec3 updatePosition = vec3(position.x, position.y, position.z + sin1 * 50.0 + sin2 * 10.0 + sin3 * 8.0);\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\n\nconst float duration = 8.0;\nconst float delay = 4.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  float opacity = (1.0 - length(vPosition.xy / vec2(512.0))) * 0.6 * now;\n  vec3 v = normalize(vPosition);\n  vec3 rgb = convertHsvToRgb(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.4, 1.0));\n  gl_FragColor = vec4(rgb, opacity);\n}\n"]),
							transparent: !0,
							wireframe: !0
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	48: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t) {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = this.createObj(t), this.time = 1
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(['precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nconst float duration = 8.0;\nconst float delay = 4.0;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n\n  // ホワイトノイズ\n  float whiteNoise = random(vUv.xy * time) * 0.1 - 0.1;\n\n  // モニターエフェクト\n  float monitor1 = abs(sin(vUv.y * resolution.y * 2.4 + time * 10.0)) * 0.04;\n  float monitor2 = abs(sin(vUv.y * resolution.y * 1.0 + time * 3.0)) * 0.04;\n  float monitor = monitor1 - monitor2;\n\n  // ヴィネット\n  float vignetteMask = smoothstep(0.8, 1.4, length(vUv * 2.0 - 1.0));\n  vec3 vignetteColor = convertHsvToRgb(vec3(0.5 + (vUv.x + vUv.y) / 40.0 + time * 0.1, 0.4, 1.0));\n  vec3 vignette = vignetteMask * vignetteColor * 0.1;\n\n  // RGBズレ\n  float r = texture2D(texture, vUv - vec2(2.0, 0.0) / resolution).r;\n  float g = texture2D(texture, vUv).g;\n  float b = texture2D(texture, vUv + vec2(2.0, 0.0) / resolution).b;\n\n  gl_FragColor = vec4((vec3(r, g, b) + whiteNoise) + monitor + vignette, 1.0);\n}\n'])
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e * this.time
					}
				}, {
					key: "resize",
					value: function() {
						this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	49: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function(e, t, n) {
				var i = [],
					r = [t[0] - e[0], t[1] - e[1], t[2] - e[2]],
					o = [n[0] - e[0], n[1] - e[1], n[2] - e[2]];
				i[0] = r[1] * o[2] - r[2] * o[1], i[1] = r[2] * o[0] - r[0] * o[2], i[2] = r[0] * o[1] - r[1] * o[0];
				for (var a = Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2], 2), s = 0; s < i.length; s++) i[s] = i[s] / a;
				return i
			}),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						for (var e = new o.OctahedronBufferGeometry(90, 4), t = e.attributes.position.array, n = [], i = [], r = [], c = 0; c < t.length; c += 9) {
							var l = s([t[c + 0], t[c + 1], t[c + 2]], [t[c + 3], t[c + 4], t[c + 5]], [t[c + 6], t[c + 7], t[c + 8]]);
							n.push(l[0], l[1], l[2], l[0], l[1], l[2], l[0], l[1], l[2]);
							var u = [(t[c + 0] + t[c + 3] + t[c + 6]) / 3, (t[c + 1] + t[c + 4] + t[c + 7]) / 3, (t[c + 2] + t[c + 5] + t[c + 8]) / 3],
								h = .5 * Math.random();
							i.push(u[0], u[1], u[2], u[0], u[1], u[2], u[0], u[1], u[2]), r.push(h, h, h)
						}
						var d = new Float32Array(n),
							f = new Float32Array(i),
							v = new Float32Array(r);
						return e.addAttribute("faceNormal", new o.BufferAttribute(d, 3)), e.addAttribute("center", new o.BufferAttribute(f, 3)), e.addAttribute("delay", new o.BufferAttribute(v, 1)), new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(['#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 faceNormal;\nattribute vec3 center;\nattribute float delay;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vNoise;\nvarying float vNow;\n\nconst float duration = 2.0;\nconst float delayAll = 1.0;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvoid main() {\n  float now = exponentialOut(max((time - delayAll - delay - (faceNormal.x + 1.0) / 2.0 - (faceNormal.y + 1.0) / 2.0) / duration, 0.0));\n  mat4 translateMat = calcTranslateMat4(vec3(faceNormal) * 1200.0 * (1.0 - now) + vec3(0.0, sin(time) * 10.0 + 210.0, 0.0));\n  mat4 rotateMat = calcRotateMat4(vec3(0.0, radians((1.0 - now) * faceNormal.y * 4320.0), 0.0));\n  float rotateRadian = radians((time + faceNormal.x + faceNormal.y) * 1440.0);\n  mat4 rotateMatSelf = calcRotateMat4(vec3(rotateRadian, rotateRadian, 0.0));\n  float noise = smoothstep(-0.4, 0.4,\n    cnoise(vec3(position.x * 0.035 - time, position.y * 0.035 - time, position.z * 0.035 + time))\n  ) * 2.0 - 1.0;\n  vec3 updatePositionSelf = (rotateMatSelf * vec4(position - center, 1.0)).xyz * (1.0 - now) + position\n    + normalize(position) * noise ;\n  vec4 updatePosition = rotateMat * translateMat * vec4(updatePositionSelf, 1.0);\n  vPosition = updatePosition.xyz;\n  vNoise = noise;\n  vNow = now;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n']),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vNoise;\nvarying float vNow;\n\nconst vec3 lightDirection = vec3(1.0, -1.0, -1.0);\nconst float duration = 2.0;\nconst float delayAll = 1.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float now = clamp((time - delayAll - 1.5) / duration, 0.0, 1.0);\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 light = normalize(normalMatrix * lightDirection);\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2;\n  float opacity = smoothstep(0.1, 0.2, vNow);\n  vec3 v = normalize(vPosition);\n  vec3 rgb = (1.0 - now) * vec3(1.0) + convertHsvToRgb(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.8, 0.4 + sin(time) * 0.05 + vNoise * 0.02));\n  gl_FragColor = vec4(rgb + diff, opacity);\n}\n"]),
							flatShading: !0,
							transparent: !0,
							side: o.DoubleSide
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	50: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.OctahedronBufferGeometry(150, 4);
						return new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(['#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vOpacity;\n\nconst float duration = 4.0;\nconst float delay = 3.0;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  mat4 translateMat = calcTranslateMat4(vec3(0.0, sin(time) * 10.0 + 210.0, 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(exponentialOut(now) * 0.6 + 0.4 + sin(time * 2.0) * 0.04));\n  mat4 rotateMat = calcRotateMat4(vec3(radians(45.0), radians(time * 2.0), radians(-time * 2.0)));\n  float noise = smoothstep(-0.4, 0.4, cnoise(position * 0.035 - time)) * 2.0 - 1.0;\n  vec4 updatePosition = translateMat * rotateMat * scaleMat * vec4(position + normalize(position) * noise * 2.0, 1.0);\n  vPosition = normalize(position);\n  vOpacity = normalize(updatePosition).z;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n']),
							fragmentShader: a(['precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vOpacity;\n\nconst float duration = 4.0;\nconst float delay = 3.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  float noise1 = cnoise(vec3((vPosition * vec3(0.4, 2.0, -0.6) * 2.0 + time))) * 7.0 - (1.0 + (1.0 - now) * 7.0);\n  float noise2 = cnoise(vec3((vPosition * 42.0 + time)));\n  float noise3 = cnoise(vec3((vPosition * 7.0 + time))) * 2.0;\n  float bright = smoothstep(-0.2, 1.0, (noise1 + noise2 + noise3) * now);\n  vec3 v = normalize(vPosition);\n  vec3 rgb = (1.0 - now) * vec3(1.0) + convertHsvToRgb(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.4, 1.0));\n  float whiteNoise = random(vPosition.xy);\n  if (bright < 0.4) discard;\n  gl_FragColor = vec4(rgb * vec3(1.0 - bright + 0.6) + whiteNoise * 0.2, 0.4 + vOpacity * 0.5 + sin(time * 2.0) * 0.1);\n}\n']),
							transparent: !0,
							side: o.DoubleSide,
							depthWrite: !1
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	51: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						resolution: {
							type: "v2",
							value: new o.Vector2
						},
						texture: {
							type: "t",
							value: null
						}
					}, this.obj = null, this.isLoaded = !1
				}
				return r(e, [{
					key: "loadTexture",
					value: function(e) {
						var t = this;
						(new o.TextureLoader).load("/sketch-threejs/img/index/tex_title.png", function(n) {
							n.magFilter = o.NearestFilter, n.minFilter = o.NearestFilter, t.uniforms.texture.value = n, t.obj = t.createObj(), t.isLoaded = !0, e()
						})
					}
				}, {
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(256, 64, 40, 10), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec2 vUv;\n\nconst float interval = 3.0;\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nvoid main() {\n  float now = cubicOut(min(time / interval, 1.0));\n  vec3 updatePosition = vec3(\n    position.x * (1.2 - now * 0.2),\n    position.y * (1.2 - now * 0.2),\n    position.z\n  );\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nconst float interval = 3.0;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nvoid main() {\n  float now = cubicOut(min(time / interval, 1.0));\n  float noise = (snoise(vec3(vUv.x * 4.0, vUv.y * 4.0, 1.0)) + 1.0) / 2.0;\n  float opacity = smoothstep(0.4, 0.6, ((noise - 1.0) + now * interval) - vUv.x);\n  gl_FragColor = texture2D(texture, vUv) * vec4(vec3(1.0), opacity);\n}\n"]),
							transparent: !0
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.isLoaded && (this.uniforms.time.value += e)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	52: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js");
		e("./util");
		t.exports = function() {
			var e = function() {
				this.velocity = new i.Vector2, this.acceleration = new i.Vector2, this.anchor = new i.Vector2, this.mass = 1
			};
			return e.prototype.updateVelocity = function() {
				this.acceleration.divideScalar(this.mass), this.velocity.add(this.acceleration)
			}, e.prototype.applyForce = function(e) {
				this.acceleration.add(e)
			}, e.prototype.applyFriction = function(e, t) {
				var n = this.acceleration.clone();
				t || (t = 1), n.multiplyScalar(-1), n.normalize(), n.multiplyScalar(e), this.applyForce(n)
			}, e.prototype.applyDrag = function(e) {
				var t = this.acceleration.clone();
				t.multiplyScalar(-1), t.normalize(), t.multiplyScalar(this.acceleration.length() * e), this.applyForce(t)
			}, e.prototype.applyHook = function(e, t) {
				var n = this.velocity.clone().sub(this.anchor),
					i = n.length() - e;
				n.normalize(), n.multiplyScalar(-1 * t * i), this.applyForce(n)
			}, e
		}()
	}, {
		"./util": 59,
		"three/build/three.js": 8
	}],
	53: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js");
		e("./util");
		t.exports = function() {
			var e = function() {
				this.velocity = new i.Vector3, this.acceleration = new i.Vector3, this.anchor = new i.Vector3, this.mass = 1
			};
			return e.prototype.updateVelocity = function() {
				this.acceleration.divideScalar(this.mass), this.velocity.add(this.acceleration)
			}, e.prototype.applyForce = function(e) {
				this.acceleration.add(e)
			}, e.prototype.applyFriction = function(e, t) {
				var n = this.acceleration.clone();
				t || (t = 1), n.multiplyScalar(-1), n.normalize(), n.multiplyScalar(e), this.applyForce(n)
			}, e.prototype.applyDrag = function(e) {
				var t = this.acceleration.clone();
				t.multiplyScalar(-1), t.normalize(), t.multiplyScalar(this.acceleration.length() * e), this.applyForce(t)
			}, e.prototype.applyHook = function(e, t) {
				var n = this.velocity.clone().sub(this.anchor),
					i = n.length() - e;
				n.normalize(), n.multiplyScalar(-1 * t * i), this.applyForce(n)
			}, e
		}()
	}, {
		"./util": 59,
		"three/build/three.js": 8
	}],
	54: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js"),
			r = e("./util"),
			o = e("./Force3");
		t.exports = function() {
			var e = function(e, t, n, r) {
				i.PerspectiveCamera.call(this, e, t, n, r), this.force = {
					position: new o,
					look: new o
				}, this.up.set(0, 1, 0)
			};
			return e.prototype = Object.create(i.PerspectiveCamera.prototype), e.prototype.constructor = e, e.prototype.updatePosition = function() {
				this.position.copy(this.force.position.velocity)
			}, e.prototype.updateLook = function() {
				this.lookAt(this.force.look.velocity.x, this.force.look.velocity.y, this.force.look.velocity.z)
			}, e.prototype.reset = function() {
				this.setPolarCoord(), this.lookAtCenter()
			}, e.prototype.resize = function(e, t) {
				this.aspect = e / t, this.updateProjectionMatrix()
			}, e.prototype.setPolarCoord = function(e, t, n) {
				this.force.position.anchor.copy(r.getPolarCoord(e, t, n))
			}, e.prototype.lookAtCenter = function() {
				this.lookAt(0, 0, 0)
			}, e
		}()
	}, {
		"./Force3": 53,
		"./util": 59,
		"three/build/three.js": 8
	}],
	55: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js"),
			r = e("./util"),
			o = e("./Force3");
		t.exports = function() {
			var e = function(e, t, n) {
				i.HemisphereLight.call(this, e, t, n), this.force = new o
			};
			return e.prototype = Object.create(i.HemisphereLight.prototype), e.prototype.constructor = e, e.prototype.updatePosition = function() {
				this.position.copy(this.force.velocity)
			}, e.prototype.setPositionSpherical = function(e, t, n) {
				this.position.copy(r.getPolarCoord(e, t, n))
			}, e
		}()
	}, {
		"./Force3": 53,
		"./util": 59,
		"three/build/three.js": 8
	}],
	56: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js"),
			r = e("./util"),
			o = e("./Force3");
		t.exports = function() {
			var e = function(e, t, n, r) {
				i.PointLight.call(this, e, t, n, r), this.force = new o
			};
			return e.prototype = Object.create(i.PointLight.prototype), e.prototype.constructor = e, e.prototype.updatePosition = function() {
				this.position.copy(this.force.velocity)
			}, e.prototype.setPolarCoord = function(e, t, n) {
				this.position.copy(r.getPolarCoord(e, t, n))
			}, e
		}()
	}, {
		"./Force3": 53,
		"./util": 59,
		"three/build/three.js": 8
	}],
	57: [function(e, t, n) {
		"use strict";
		e("three/build/three.js"), e("./util");
		var i = e("./Force3");
		t.exports = function() {
			var e = function() {
				this.size = 0, this.time = 0, this.is_active = !1, i.call(this)
			};
			return e.prototype = Object.create(i.prototype), e.prototype.constructor = e, e.prototype.init = function(e) {
				this.velocity = e.clone(), this.anchor = e.clone(), this.acceleration.set(0, 0, 0), this.time = 0
			}, e.prototype.activate = function() {
				this.is_active = !0
			}, e.prototype.inactivate = function() {
				this.is_active = !1
			}, e
		}()
	}, {
		"./Force3": 53,
		"./util": 59,
		"three/build/three.js": 8
	}],
	58: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js"),
			r = (e("./util"), e("./Force3"));
		t.exports = function() {
			var e = function() {
				this.geometry = new i.BufferGeometry, this.material = null, this.obj = null, r.call(this)
			};
			return e.prototype = Object.create(r.prototype), e.prototype.constructor = e, e.prototype.init = function(e) {
				this.material = new i.ShaderMaterial({
					uniforms: {
						color: {
							type: "c",
							value: new i.Color(16777215)
						},
						texture: {
							type: "t",
							value: e.texture
						}
					},
					vertexShader: e.vs,
					fragmentShader: e.fs,
					transparent: !0,
					depthWrite: !1,
					blending: e.blending
				}), this.geometry.addAttribute("position", new i.BufferAttribute(e.positions, 3)), this.geometry.addAttribute("customColor", new i.BufferAttribute(e.colors, 3)), this.geometry.addAttribute("vertexOpacity", new i.BufferAttribute(e.opacities, 1)), this.geometry.addAttribute("size", new i.BufferAttribute(e.sizes, 1)), this.obj = new i.Points(this.geometry, this.material), e.scene.add(this.obj)
			}, e.prototype.updatePoints = function() {
				this.obj.position.copy(this.velocity), this.obj.geometry.attributes.position.needsUpdate = !0, this.obj.geometry.attributes.vertexOpacity.needsUpdate = !0, this.obj.geometry.attributes.size.needsUpdate = !0, this.obj.geometry.attributes.customColor.needsUpdate = !0
			}, e
		}()
	}, {
		"./Force3": 53,
		"./util": 59,
		"three/build/three.js": 8
	}],
	59: [function(e, t, n) {
		"use strict";
		var i = e("three/build/three.js");
		t.exports = {
			getRandomInt: function(e, t) {
				return Math.floor(Math.random() * (t - e)) + e
			},
			getDegree: function(e) {
				return e / Math.PI * 180
			},
			getRadian: function(e) {
				return e * Math.PI / 180
			},
			getPolarCoord: function(e, t, n) {
				var r = Math.cos(e) * Math.cos(t) * n,
					o = Math.cos(e) * Math.sin(t) * n,
					a = Math.sin(e) * n;
				return new i.Vector3(r, a, o)
			}
		}
	}, {
		"three/build/three.js": 8
	}],
	60: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.SphereBufferGeometry(1e4, 128, 128),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 hsv1 = vec3(0.98, 0.9, 0.05);\nconst vec3 hsv2 = vec3(1.13, 0.9, 0.8);\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 rgb = convertHsvToRgb(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float noise = random(vUv) * 0.08;\n\n  gl_FragColor = vec4(vColor + noise, 1.0);\n}\n"]),
								side: o.BackSide
							});
						this.obj = new o.Mesh(e, t)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	61: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = (e("three/build/three.js"), e("gl-matrix")),
			a = (e("js-util/MathEx"), function() {
				function e(t, n) {
					i(this, e), this.camera = t, this.anchorTilt = [0, 0, 0]
				}
				return r(e, [{
					key: "init",
					value: function(e, t) {
						for (var n = 0; n < e.length; n++) this.camera.anchor[n] = this.camera.velocity[n] = e[n], this.camera.lookAnchor[n] = this.camera.lookVelocity[n] = t[n]
					}
				}, {
					key: "tilt",
					value: function(e) {
						this.anchorTilt = [-200 * e.x, 200 * e.y, 0]
					}
				}, {
					key: "move",
					value: function(e, t, n) {
						for (var i = 0; i < e.length; i++) this.camera.anchor[i] = e[i], this.camera.lookAnchor[i] = t[i];
						n > 0 && this.focalLength.next !== n && (this.focalLength.prev = this.focalLength.next, this.focalLength.next = n, this.focalLength.time = 0)
					}
				}, {
					key: "render",
					value: function(e, t) {
						this.tilt(t), o.vec3.add(this.camera.velocity, this.camera.velocity, this.anchorTilt), this.camera.render()
					}
				}]), e
			}());
		n.default = a
	}, {
		"gl-matrix": 1,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	62: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.OctahedronBufferGeometry(450, 3),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nconst vec3 light = vec3(0.0, 1.0, 0.0);\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(0.88 + diff * 0.2, 1.0 - diff * 0.4, pow(diff, 3.0) * 0.88 + 0.12);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"]),
								flatShading: !0
							});
						this.obj = new o.Mesh(e, t)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	63: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.PlaneBufferGeometry(1e3, 3e3, 128, 128),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main(void) {\n  float roundRadius = (1.0 - smoothstep(0.1, 1.0, uv.y)* 1.2) * 480.0;\n  vec3 roundPosition = vec3(\n    sin(radians(uv.x * 360.0)) * roundRadius,\n    position.y + 900.0,\n    cos(radians(uv.x * 360.0)) * roundRadius\n    );\n\n  float noise = (snoise(roundPosition * vec3(0.01, 0.0001, 0.01) + time * 0.8) + 0.5);\n  float noiseRadius = noise * smoothstep(0.2, 0.3, uv.y) * 70.0;\n  vec3 noisePosition = vec3(\n    sin(radians(uv.x * 360.0)) * noiseRadius,\n    0.0,\n    cos(radians(uv.x * 360.0)) * noiseRadius\n    );\n\n  vec4 mvPosition = modelViewMatrix * vec4(roundPosition + noisePosition, 1.0);\n\n  vPosition = roundPosition;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float noise = snoise(\n    vPosition * vec3(0.005, 0.002, 0.004) + vec3(time * 2.6, -time * 3.6, time * 2.6)\n    );\n  float opacity = smoothstep(0.3, 0.8, (noise + 1.0) / 2.0 - (1.0 - smoothstep(0.0, 0.3, vUv.y) * (1.0 - smoothstep(0.3, 1.0, vUv.y))));\n  vec3 hsv = vec3(0.98 + opacity * 0.2, 1.0 - opacity * 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, opacity);\n}\n"]),
								transparent: !0,
								depthWrite: !1,
								side: o.DoubleSide,
								blending: o.AdditiveBlending
							});
						this.obj = new o.Mesh(e, t)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	64: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.num = 5e3, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry,
							t = new o.BoxBufferGeometry(16, 800, 200);
						e.addAttribute("position", t.attributes.position), e.addAttribute("normal", t.attributes.normal), e.addAttribute("uv", t.attributes.uv), e.setIndex(t.index);
						for (var n = new o.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), i = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), r = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), c = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), l = 0, u = this.num; l < u; l++) {
							s.radians(s.randomArbitrary(0, 360));
							var h = s.randomArbitrary(1e3, 7e3),
								d = (7e3 - h) / 7e3 * .75 + .25,
								f = s.randomArbitrary(.1, .4);
							n.setXYZ(l, h, s.randomArbitrary(-1e4, -100), 0), i.setXYZ(l, d), r.setXYZ(l, l), c.setXYZ(l, f)
						}
						e.addAttribute("instancePosition", n), e.addAttribute("scale", i), e.addAttribute("rotate", r), e.addAttribute("speed", c);
						var v = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float scale;\nattribute float rotate;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDistance;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvoid main(void) {\n  mat4 scaleMat = calcScaleMat4(vec3(scale));\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, rotate + time * speed * 0.2, 0.0));\n  vec3 updatePosition = (scaleMat * vec4(position, 1.0)).xyz;\n  vec4 mvPosition = modelViewMatrix * rotateMatWorld * vec4(updatePosition + instancePosition, 1.0);\n  float distanceFromCenter = 1.0 - clamp(length(instancePosition) / 6000.0, 0.0, 0.8);\n\n  vPosition = updatePosition + instancePosition;\n  vUv = uv;\n  vDistance = distanceFromCenter;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDistance;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(-vPosition);\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(\n    0.86 + diff * 0.24,\n    1.0 - diff * 0.4,\n    (diff * 0.88 + 0.12) * vDistance\n    );\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"]),
							flatShading: !0
						});
						this.obj = new o.Mesh(e, v)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	65: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.instances = 500, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry,
							t = new o.BoxBufferGeometry(1, 1e3, 1, 2, 128);
						e.addAttribute("position", t.attributes.position), e.addAttribute("uv", t.attributes.uv), e.setIndex(t.index);
						for (var n = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), i = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), r = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), c = 0, l = this.instances; c < l; c++) n.setXYZ(c, 300 * ((Math.random() + Math.random() + Math.random()) / 3 * 2 - 1), 0, 150 * ((Math.random() + Math.random() + Math.random()) / 3 * 2 - 1)), i.setXYZ(c, 90 * (2 * s.randomInt(0, 1) - 1) + 60 * (2 * Math.random(0, 1) - 1)), r.setXYZ(c, 2 * Math.random());
						e.addAttribute("instancePosition", n), e.addAttribute("rotate", i), e.addAttribute("delay", r);
						var u = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(['#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float rotate;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate posiitons of instances.\n  vec3 wavePosition = vec3(0.0, 0.0, sin(radians(position.y / 3.6) + time * 0.1 + delay * 9.0) * 50.0);\n  vec3 updatePosition = position + instancePosition + wavePosition;\n  mat4 rotateMat = calcRotateMat4(vec3(radians(90.0), 0.0, radians(rotate)));\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(updatePosition, 1.0);\n\n  // calculate interval for uv animation and setting color.\n  float noise = cnoise(updatePosition / 100.0) * 0.5 + time * 0.1;\n  vec3 hsv = vec3(noise, 0.45, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  vPosition = position;\n  vUv = uv;\n  vDelay = delay;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n']),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nconst float duration = 3.0;\n\nvoid main() {\n  float now = mod(time + vDelay * duration, duration) / duration;\n  float opacityBothEnds = smoothstep(-500.0, -400.0, vPosition.y) * (1.0 - smoothstep(400.0, 500.0, vPosition.y));\n  float opacity = smoothstep(0.95, 1.0, mod(vUv.y - now, 1.0));\n\n  gl_FragColor = vec4(vColor, opacity * opacityBothEnds * 0.9);\n}\n"]),
							depthWrite: !1,
							transparent: !0,
							side: o.DoubleSide,
							blending: o.AdditiveBlending
						});
						this.obj = new o.Mesh(e, u)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	66: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						for (var e = new o.BufferGeometry, t = [], n = 0; n < 50; n++)
							for (var i = 0; i < 50; i++)
								for (var r = 0; r < 50; r++) {
									var s = 70 * (r / 50 * 2 - 1),
										c = 70 * (i / 50 * 2 - 1),
										l = 70 * (n / 50 * 2 - 1);
									t.push(s, c, l)
								}
						var u = new o.BufferAttribute(new Float32Array(t), 3);
						e.addAttribute("position", u);
						var h = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  float noise1 = snoise(mvPosition.xyz * 0.046 + vec3(-time, time, time) * 0.3);\n  float noise2 = snoise(mvPosition.xyz * 0.0012 + vec3(time, -time, time) * 0.01);\n\n  vec3 hsv = vec3(noise2 * 0.2 + time * 0.1, 1.0, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  vColor = rgb;\n  vOpacity = pow(40.0 / length(mvPosition.xyz) * noise1, 2.0);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 600.0 / length(mvPosition.xyz) * noise1;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity);\n}\n"]),
							transparent: !0,
							depthWrite: !1
						});
						this.obj = new o.Points(e, h)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e, this.obj.rotation.set(.005 * this.uniforms.time.value, .02 * this.uniforms.time.value, .004 * this.uniforms.time.value)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	67: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = 280,
			c = function() {
				function e(t, n) {
					i(this, e), this.uniforms = {
						index: {
							type: "f",
							value: t
						},
						time: {
							type: "f",
							value: 0
						},
						size: {
							type: "f",
							value: s
						},
						texture: {
							type: "t",
							value: n
						},
						colorH: {
							type: "f",
							value: Math.random()
						}
					}, this.obj = this.createObj(), this.obj.renderOrder = 10
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.PlaneBufferGeometry(s, s / 2, 24, 12),
							t = new o.Mesh(e, new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float index;\nuniform float time;\nuniform float size;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  float flapTime = radians(sin(time * 4.0 - length(position.xy) / size * 2.0 + index * 2.0) * 45.0 + 30.0);\n  float hovering = cos(time * 2.0 + index * 3.0) * size / 16.0;\n  vec3 updatePosition = vec3(\n    cos(flapTime) * position.x,\n    position.y + hovering,\n    sin(flapTime) * abs(position.x) + hovering\n  );\n\n  vPosition = position;\n  vUv = uv;\n  vOpacity = (1.0 - smoothstep(0.75, 1.0, abs((modelMatrix * vec4(updatePosition, 1.0)).z) / 900.0)) * 0.85;\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float size;\nuniform sampler2D texture;\nuniform float colorH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec4 texColor = texture2D(texture, vUv);\n\n  float noise = snoise(vPosition / vec3(size * 0.25) + vec3(0.0, 0.0, time));\n  vec3 hsv = vec3(colorH + noise * 0.2, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  if (texColor.a < 0.5) discard;\n\n  gl_FragColor = vec4(rgb, vOpacity) * texColor;\n}\n"]),
								side: o.DoubleSide,
								transparent: !0
							}));
						return t.position.y = .5 * s + (2 * Math.random() - 1) * s * .1, t.rotation.set(-45 * Math.PI / 180, 0, 0), t
					}
				}, {
					key: "render",
					value: function(e, t) {
						this.uniforms.time.value += t, this.obj.position.z -= 4, this.obj.position.z < -900 && (this.obj.position.x = 280 * (2 * Math.random() - 1), this.obj.position.z = 900, this.uniforms.colorH.value = Math.random())
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	68: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("./PostEffectBlur.js")),
			a = e("three/build/three.js"),
			s = e("glslify"),
			c = function() {
				function e(t) {
					i(this, e), this.mirrorCamera = new a.PerspectiveCamera(30, t.x / t.y, 1, 15e3), this.mirrorRender = new a.WebGLRenderTarget(t.x, t.y), this.textureMatrix = new a.Matrix4, this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						texture: {
							type: "t",
							value: this.mirrorRender.texture
						},
						textureMatrix: {
							type: "m4",
							value: this.textureMatrix
						}
					}, this.renderBack1 = new a.WebGLRenderTarget(t.x, t.y), this.renderBack2 = new a.WebGLRenderTarget(t.x, t.y), this.postEffectBlurX = new o.default(this.renderBack1.texture, 1, 0, 4), this.postEffectBlurY = new o.default(this.renderBack2.texture, 0, 1, 4), this.mirrorCamera.up.set(0, -1, 0), this.obj = this.createObj()
				}
				return r(e, [{
					key: "add",
					value: function(e, t) {
						t.add(this.obj), e.add(this.postEffectBlurX.obj), e.add(this.postEffectBlurY.obj)
					}
				}, {
					key: "createObj",
					value: function() {
						var e = new a.Mesh(new a.PlaneBufferGeometry(1e3, 2e3), new a.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: s(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec4 vUv;\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vUv = textureMatrix * worldPosition;\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"]),
							fragmentShader: s(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec4 vUv;\n\nvoid main() {\n  vec4 projectorColor;\n  if (all(bvec4(vUv.x >= 0.0, vUv.y >= 0.0, vUv.x <= vUv.z, vUv.y <= vUv.z))) {\n    projectorColor = texture2DProj(texture, vUv);\n  }\n  gl_FragColor = vec4(vec3(1.0), 0.3) * projectorColor;\n}\n"]),
							transparent: !0
						}));
						return e.rotation.set(-.5 * Math.PI, 0, 0), e
					}
				}, {
					key: "updateTextureMatrix",
					value: function() {
						this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
					}
				}, {
					key: "render",
					value: function(e, t, n, i, r) {
						this.uniforms.time.value += r, this.updateTextureMatrix(), this.obj.visible = !1, e.render(n, this.mirrorCamera, this.renderBack1), this.obj.visible = !0, this.postEffectBlurX.render(e, t, i, this.renderBack2), this.postEffectBlurY.render(e, t, i, this.mirrorRender)
					}
				}, {
					key: "resize",
					value: function(e) {
						this.mirrorCamera.aspect = e.x / e.y, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(e.x, e.y), this.renderBack1.setSize(e.x, e.y), this.renderBack2.setSize(e.x, e.y), this.postEffectBlurX.resize(e), this.postEffectBlurY.resize(e)
					}
				}]), e
			}();
		n.default = c
	}, {
		"./PostEffectBlur.js": 71,
		glslify: 2,
		"three/build/three.js": 8
	}],
	69: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e(t) {
					i(this, e), this.interval = 4, this.attr = {
						position: new o.BufferAttribute(new Float32Array(3 * t), 3),
						colorH: new o.BufferAttribute(new Float32Array(t), 1),
						index: new o.BufferAttribute(new Float32Array(t), 1),
						valid: new o.BufferAttribute(new Float32Array(t), 1)
					}, this.geometry = new o.BufferGeometry, this.uniforms = {
						size: {
							type: "f",
							value: t
						},
						interval: {
							type: "f",
							value: this.interval
						},
						time: {
							type: "f",
							value: 0
						}
					}, this.butterflies = null, this.butterfliesLengh = 0, this.obj = this.createObj(), this.obj.renderOrder = 20
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						for (var e = 0; e < this.uniforms.size.value; e++) this.attr.index.setX(e, e);
						return this.geometry.addAttribute("position", this.attr.position), this.geometry.addAttribute("colorH", this.attr.colorH), this.geometry.addAttribute("i", this.attr.index), this.geometry.addAttribute("valid", this.attr.valid), new o.Points(this.geometry, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute float colorH;\nattribute float i;\nattribute float valid;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float size;\nuniform float interval;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float thisTime = mod(time + i / size * interval, interval);\n\n  vec3 updatePosition = position + vec3(\n    cos(thisTime * 3.0 + i) * 3.0,\n    thisTime * -16.0,\n    sin(thisTime * 3.0 + i) * 3.0\n  );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vec3 hsv = vec3(colorH + sin(i) * 0.075, 0.8, 1.0);\n\n  vColor = convertHsvToRgb(hsv);\n  vOpacity = smoothstep(interval * 0.0, interval * 0.1, thisTime)\n    * (1.0 - smoothstep(interval * 0.2, interval * 0.9, thisTime));\n\n  gl_PointSize = 12000.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity * 0.5);\n}\n"]),
							depthWrite: !1,
							transparent: !0
						}))
					}
				}, {
					key: "addButterflies",
					value: function(e) {
						this.butterflies = e, this.butterfliesLengh = e.length
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e;
						for (var t = 0; t < this.uniforms.size.value; t++) {
							var n = (this.uniforms.time.value + this.attr.index.getX(t) / this.uniforms.size.value * this.interval) % this.interval,
								i = this.attr.valid.getX(t);
							if (n >= .9 * this.interval && 1 == i) this.attr.valid.setX(t, 0);
							else if (n <= .9 * this.interval && 0 == i) {
								var r = Math.floor(Math.random() * this.butterfliesLengh),
									o = this.butterflies[r],
									a = (-90 * Math.random() - 90) * Math.PI / 180,
									c = -180 * Math.random() * Math.PI / 180,
									l = Math.random() * o.uniforms.size.value / 4 + o.uniforms.size.value / 8,
									u = s.spherical(a, c, l);
								this.attr.position.setXYZ(t, u[0] + o.obj.position.x, .2 * u[1] + o.obj.position.y + 20 * Math.sin(o.uniforms.time.value), .5 * u[2] + o.obj.position.z), this.attr.colorH.setX(t, o.uniforms.colorH.value), this.attr.valid.setX(t, 1)
							}
						}
						this.attr.position.needsUpdate = !0, this.attr.colorH.needsUpdate = !0
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	70: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n) {
					i(this, e), this.uniforms = {
						texture1: {
							type: "t",
							value: t
						},
						texture2: {
							type: "t",
							value: n
						}
					}, this.obj = this.createObj(), this.obj.visible = !1
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * 0.5 + color2;\n}\n"])
						}))
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.obj.visible = !0, e.render(t, n, i), this.obj.visible = !1
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	71: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n, r, a) {
					i(this, e), this.uniforms = {
						resolution: {
							type: "v2",
							value: new o.Vector2
						},
						direction: {
							type: "v2",
							value: new o.Vector2(n, r)
						},
						radius: {
							type: "f",
							value: a
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = this.createObj(), this.obj.visible = !1
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n"])
						}))
					}
				}, {
					key: "resize",
					value: function(e) {
						this.uniforms.resolution.value.set(e.x, e.y)
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.obj.visible = !0, e.render(t, n, i), this.obj.visible = !1
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	72: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t) {
					i(this, e), this.uniforms = {
						minBright: {
							type: "f",
							value: .3
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = this.createObj(), this.obj.visible = !1
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n"])
						}))
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.obj.visible = !0, e.render(t, n, i), this.obj.visible = !1
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	73: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.instances = 2e3, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry,
							t = new o.BoxBufferGeometry(100, 4e3, 2, 2, 2);
						e.addAttribute("position", t.attributes.position), e.addAttribute("uv", t.attributes.uv), e.setIndex(t.index);
						for (var n = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), i = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), r = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), c = 0, l = this.instances; c < l; c++) n.setXYZ(c, s.randomArbitrary(-5e3, 5e3), 0, s.randomArbitrary(-500, 500) + 700 * (2 * s.randomInt(0, 1) - 1)), i.setXYZ(c, 2 * Math.random()), r.setXYZ(c, .3 * Math.random());
						e.addAttribute("instancePosition", n), e.addAttribute("delay", i), e.addAttribute("h", r);
						var u = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float h;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // update positions\n  vec3 updatePosition = position + instancePosition;\n  mat4 rotateMat = calcRotateMat4(vec3(radians(90.0), 0.0, radians(180.0)));\n\n  // calculate colors\n  vec3 hsv = vec3(h + time * 0.1, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vDelay = delay;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nconst float duration = 10.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float now = mod(time + vDelay * duration, duration) / duration;\n\n  float opacityBothEnds = smoothstep(-2000.0, -1800.0, vPosition.y) * (1.0 - smoothstep(1800.0, 2000.0, vPosition.y));\n  float opacity = smoothstep(0.85, 1.0, mod(vUv.y - now, 1.0));\n\n  gl_FragColor = vec4(vColor, opacity * opacityBothEnds * 0.08);\n}\n"]),
							depthWrite: !1,
							transparent: !0,
							side: o.DoubleSide,
							blending: o.AdditiveBlending
						});
						this.obj = new o.Mesh(e, u)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	74: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.isShown = !1, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.SphereBufferGeometry(1e4, 32, 32),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 1.0, (1.0 - abs(vPosition.y / 10000.0)) * 0.08);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"]),
								side: o.BackSide
							});
						this.obj = new o.Mesh(e, t)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	75: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						wave1: {
							type: "f",
							value: 0
						},
						wave2: {
							type: "f",
							value: 0
						},
						wave3: {
							type: "f",
							value: 0
						},
						wave4: {
							type: "f",
							value: 0
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function(e, t, n, i, r) {
						var s = new o.SphereBufferGeometry(e, 64, 64),
							c = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float wave1;\nuniform float wave2;\nuniform float wave3;\nuniform float wave4;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main() {\n  // draw lines\n  float v1 = sin(vUv.y * wave1 + time * 0.2);\n  float v2 = sin(vUv.y * wave2 + time * 0.2);\n  float v3 = sin(vUv.y * wave3 + time * 0.2);\n  float v4 = sin(vUv.y * wave4 + time * 0.2);\n  float v = smoothstep(0.65, 0.7, (v1 + v2 + v3 + v4) / 4.0);\n  vec3 color = vec3(v);\n\n  gl_FragColor = vec4(color, v * 0.08);\n}\n"]),
								transparent: !0,
								depthWrite: !1,
								side: o.BackSide,
								blending: o.AdditiveBlending
							});
						this.uniforms.wave1.value = t, this.uniforms.wave2.value = n, this.uniforms.wave3.value = i, this.uniforms.wave4.value = r, this.obj = new o.Mesh(s, c)
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.uniforms.time.value += e, this.obj.rotation.set(t, this.uniforms.time.value * n, i)
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	76: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = (e("three/build/three.js"), e("gl-matrix")),
			a = (e("js-util/MathEx"), function() {
				function e(t, n) {
					i(this, e), this.camera = t, this.anchorTilt = [0, 0, 0]
				}
				return r(e, [{
					key: "init",
					value: function(e, t) {
						for (var n = 0; n < e.length; n++) this.camera.anchor[n] = this.camera.velocity[n] = e[n], this.camera.lookAnchor[n] = this.camera.lookVelocity[n] = t[n]
					}
				}, {
					key: "tilt",
					value: function(e) {
						this.anchorTilt = [-50 * e.x, 25 * e.y, 0]
					}
				}, {
					key: "move",
					value: function(e, t, n) {
						for (var i = 0; i < e.length; i++) this.camera.anchor[i] = e[i], this.camera.lookAnchor[i] = t[i];
						n > 0 && this.focalLength.next !== n && (this.focalLength.prev = this.focalLength.next, this.focalLength.next = n, this.focalLength.time = 0)
					}
				}, {
					key: "render",
					value: function(e, t) {
						this.tilt(t), o.vec3.add(this.camera.velocity, this.camera.velocity, this.anchorTilt), this.camera.render()
					}
				}]), e
			}());
		n.default = a
	}, {
		"gl-matrix": 1,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	77: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.num = 2e3, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						for (var e = new o.BufferGeometry, t = new o.BufferAttribute(new Float32Array(3 * this.num), 3, 1), n = new o.BufferAttribute(new Float32Array(this.num), 1, 1), i = new o.BufferAttribute(new Float32Array(this.num), 1, 1), r = 0, c = this.num; r < c; r++) {
							var l = s.radians(s.randomArbitrary(0, 150) - 75),
								u = s.radians(s.randomArbitrary(0, 360)),
								h = s.randomArbitrary(600, 2500),
								d = s.spherical(l, u, h);
							t.setXYZ(r, d[0], d[1], d[2]), n.setXYZ(r, Math.random()), i.setXYZ(r, s.randomArbitrary(5, 10) * (2 * s.randomInt(0, 1) - 1))
						}
						e.addAttribute("position", t), e.addAttribute("delay", n), e.addAttribute("speed", i);
						var f = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor1;\nvarying vec3 vColor2;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float interval = mod(time + delay * duration, duration) / duration;\n\n  // update position and size\n  float size = 10.0 * sin(interval * 4.0);\n  float blink = max(sin(interval * 4.0) * 2.0 - 1.0, 0.0);\n  mat4 rotateMat = calcRotateMat4(vec3(\n    radians(time * speed * 0.3),\n    radians(time * speed),\n    radians(time * speed * 0.3)\n    ));\n\n  // calculate colors\n  vec3 hsv1 = vec3(time * 0.1, 0.6, 1.0);\n  vec3 rgb1 = convertHsvToRgb(hsv1);\n  vec3 hsv2 = vec3(time * 0.1 + 0.2, 0.6, 1.0);\n  vec3 rgb2 = convertHsvToRgb(hsv2);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(position, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor1 = rgb1;\n  vColor2 = rgb2;\n  vOpacity = blink * clamp(distanceFromCamera, 0.1, 0.8);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera * size;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vColor1;\nvarying vec3 vColor2;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float radius = length(p);\n  float r1 = (1.0 - smoothstep(0.95, 1.0, radius));\n  float r2 = (1.0 - smoothstep(0.45, 0.5, radius));\n  vec3 color1 = vColor1 * (r1 - r2);\n  vec3 color2 = vColor2 * r2;\n  vec3 color = color1 + color2;\n  float opacity = ((r1 - r2) * 0.25 + r2 * 0.5) * vOpacity;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"]),
							transparent: !0,
							depthWrite: !1,
							blending: o.AdditiveBlending
						});
						this.obj = new o.Points(e, f)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	78: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						texture1: {
							type: "t",
							value: null
						},
						texture2: {
							type: "t",
							value: null
						},
						texture3: {
							type: "t",
							value: null
						}
					}, this.num = 6, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function(e) {
						var t = new o.InstancedBufferGeometry,
							n = new o.PlaneBufferGeometry(1200, 1200, 2, 2);
						t.addAttribute("position", n.attributes.position), t.addAttribute("normal", n.attributes.normal), t.addAttribute("uv", n.attributes.uv), t.setIndex(n.index);
						for (var i = new o.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), r = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), s = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), c = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), l = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), u = 0, h = this.num; u < h; u++) i.setXYZ(u, 0, 0, -150 * (this.num - u)), r.setXYZ(u, 2 * Math.random() - 1), s.setXYZ(u, 2 * Math.random() - 1), c.setXYZ(u, 2 * Math.random() - 1), l.setXYZ(u, .15 * (2 * Math.random() - 1));
						t.addAttribute("instancePosition", i), t.addAttribute("rotate1", r), t.addAttribute("rotate2", s), t.addAttribute("rotate3", c), t.addAttribute("h", l);
						var d = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nattribute vec3 instancePosition;\nattribute float rotate1;\nattribute float rotate2;\nattribute float rotate3;\nattribute float h;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vRotate1;\nvarying float vRotate2;\nvarying float vRotate3;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate colors\n  vec3 hsv = vec3(h + time * 0.1 + 0.5, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + instancePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vRotate1 = rotate1;\n  vRotate2 = rotate2;\n  vRotate3 = rotate3;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform sampler2D texture3;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vRotate1;\nvarying float vRotate2;\nvarying float vRotate3;\n\nmat3 rotateMat3(float radian) {\n  return mat3(\n    cos(radian), -sin(radian), 0.0,\n    sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nvoid main() {\n  // rotate textures\n  vec2 uv1 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate1)).xy + 0.5);\n  vec2 uv2 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate2)).xy + 0.5);\n  vec2 uv3 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate3)).xy + 0.5);\n  vec4 texColor1 = texture2D(texture1, uv1);\n  vec4 texColor2 = texture2D(texture2, uv2);\n  vec4 texColor3 = texture2D(texture3, uv3);\n  vec4 color = texColor1 + texColor2 + texColor3;\n\n  // discard low alpha value\n  if (color.a <= 0.1) discard;\n\n  gl_FragColor = vec4(vColor, color.a * 0.35);\n}\n"]),
							transparent: !0,
							blending: o.AdditiveBlending
						});
						this.uniforms.texture1.value = e[0], this.uniforms.texture2.value = e[1], this.uniforms.texture3.value = e[2], this.obj = new o.Mesh(t, d)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	79: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = null, this.objWire = null, this.objPoints = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.RingBufferGeometry(1550, 1600, 36, 2, s.radians(135), s.radians(270)),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 resolution = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = resolution.x * 100.0 + time / 2.0;\n  float rotateY = resolution.y * 200.0 + time / 2.0;\n  float rotateZ = length(resolution.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + resolution.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (resolution.x + resolution.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n  // flat shading\n  vec3 light = normalize(vec3(0.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = pow((dot(normal, light) + 1.0) / 2.0, 10.0);\n\n  gl_FragColor = vec4(vColor, diff * 0.4 + 0.03);\n}\n"]),
								depthWrite: !1,
								transparent: !0,
								blending: o.AdditiveBlending,
								flatShading: !0
							}),
							n = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 resolution = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = resolution.x * 100.0 + time / 2.0;\n  float rotateY = resolution.y * 200.0 + time / 2.0;\n  float rotateZ = length(resolution.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + resolution.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (resolution.x + resolution.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 0.15);\n}\n"]),
								depthWrite: !1,
								transparent: !0,
								blending: o.AdditiveBlending,
								wireframe: !0
							}),
							i = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 p = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = p.x * 100.0 + time / 2.0;\n  float rotateY = p.y * 200.0 + time / 2.0;\n  float rotateZ = length(p.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + p.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (p.x + p.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // update size\n  float size = (pow(sin(rotateX * 10.0), 3.0) + 1.0) * 2.0 + 3.0;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = size;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  // make round\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n  float radius = length(p);\n  float r = 1.0 - smoothstep(0.95, 1.0, radius);\n\n  gl_FragColor = vec4(vColor, r * 0.1);\n}\n"]),
								depthWrite: !1,
								transparent: !0,
								blending: o.AdditiveBlending
							});
						this.obj = new o.Mesh(e, t), this.objWire = new o.Mesh(e, n), this.objPoints = new o.Points(e, i), this.obj.position.set(0, 0, -1200), this.objWire.position.set(0, 0, -1200), this.objPoints.position.set(0, 0, -1200)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e;
						var t = [s.radians(20 * Math.sin(.1 * this.uniforms.time.value) + 90), s.radians(20 * Math.sin(.05 * this.uniforms.time.value)), 0];
						this.obj.rotation.set(t[0], t[1], t[2]), this.objWire.rotation.set(t[0], t[1], t[2]), this.objPoints.rotation.set(t[0], t[1], t[2])
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	80: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						noiseRange: {
							type: "f",
							value: 3 * Math.random()
						},
						speed: {
							type: "f",
							value: .08
						},
						circleOutStepMin: {
							type: "f",
							value: .1
						},
						circleOutStepMax: {
							type: "f",
							value: 1
						},
						circleInStepMin: {
							type: "f",
							value: 0
						},
						circleInStepMax: {
							type: "f",
							value: .3
						},
						noisePosition: {
							type: "f",
							value: .8
						},
						noiseSize: {
							type: "f",
							value: .5
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.Mesh(new o.PlaneBufferGeometry(640, 640), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main() {\n  vPosition = position;\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\nuniform float noiseRange;\nuniform sampler2D texEgg1;\nuniform sampler2D texEgg2;\nuniform sampler2D texDiffSpace;\n\nuniform float speed;\nuniform float circleOutStepMin;\nuniform float circleOutStepMax;\nuniform float circleInStepMin;\nuniform float circleInStepMax;\nuniform float noisePosition;\nuniform float noiseSize;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main() {\n  float t1 = exponentialOut(min(time, 2.0) / 2.0);\n  float t2 = (1.0 - exponentialOut(min(time, 2.0) / 2.0)) * 3.0;\n  vec2 pos = vUv * 2.0 - vec2(1.0);\n\n  float circleOut = smoothstep(circleOutStepMin, circleOutStepMax, t1 - length(pos));\n  float circleIn = smoothstep(circleInStepMin, circleInStepMax, t1 * 0.5 - length(pos)) * 0.5;\n  float circleLight = smoothstep(0.0, 0.1, (t1 - t2) * 0.3 - length(pos)) * smoothstep(0.0, 0.1, (t1 - t2) * 0.2 - length(pos + vec2(0.2, -0.2)));\n\n  float noiseTime = time * speed + t2;\n  float noise = (\n    snoise(\n      vec3(pos * (noisePosition + noiseRange * 0.1) + vec2(sin(noiseTime),\n      cos(noiseTime)),\n      noiseTime + noiseRange * 100.0\n      )\n    ) + 1.0) / 2.0 * noiseSize;\n\n  float mask = circleOut * noise + circleIn;\n  float maskHighLight = circleLight * (noise + 0.12);\n  float mask0 = 1.0 - step(maskHighLight, 0.13);\n  float mask1 = (1.0 - step(mask, 0.6)) * step(maskHighLight, 0.13);\n  float mask2 = (1.0 - step(mask, 0.28)) * step(mask, 0.6) * step(maskHighLight, 0.23);\n  float mask3 = (1.0 - step(mask, 0.014)) * step(mask, 0.28);\n  float mask4 = (1.0 - step(mask, 0.01)) * step(mask, 0.014);\n\n  vec4 rgba0 = vec4(convertHsvToRgb(vec3(0.125, 0.2, 1.0)), 1.0) * mask0;\n  vec4 rgba1 = vec4(convertHsvToRgb(vec3(0.125, 0.76, 1.0)), 1.0) * mask1;\n  vec4 rgba2 = vec4(convertHsvToRgb(vec3(0.108, 0.91, 1.0)), 1.0) * mask2;\n  vec4 rgba3 = vec4(convertHsvToRgb(vec3(0.1, 0.02, 0.99)), 1.0) * mask3;\n  vec4 rgba4 = vec4(convertHsvToRgb(vec3(0.1, 0.2, 0.9)), 1.0) * mask4;\n\n  float patternNoise1 = step(0.0, snoise(vPosition * 0.015 + vec3(0.0, 0.0, time * 0.1))) * 0.05;\n  float patternNoise2 = step(0.2, snoise(vPosition * 0.025 + vec3(0.0, 1.0, time * 0.3))) * 0.03;\n  vec4 patternColor = vec4(vec3(patternNoise1), 1.0) * mask1 + vec4(vec3(patternNoise2), 1.0) * mask2;\n\n  vec4 eggColor = rgba0 + rgba1 + rgba2 + rgba3 + rgba4 + patternColor;\n\n  gl_FragColor = eggColor;\n}\n"]),
							transparent: !0
						}));
						return e.position.set(80, 0, 0), e
					}
				}, {
					key: "render",
					value: function(e) {
						this.obj.visible && (this.uniforms.time.value += e)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	81: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						tex: {
							type: "t",
							value: null
						}
					}, this.num = 200, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function(e) {
						var t = new o.InstancedBufferGeometry,
							n = new o.PlaneBufferGeometry(1100, 1100, 20, 20);
						t.addAttribute("position", n.attributes.position), t.addAttribute("normal", n.attributes.normal), t.addAttribute("uv", n.attributes.uv), t.setIndex(n.index);
						for (var i = new o.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), r = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), s = new o.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), c = 0, l = this.num; c < l; c++) i.setXYZ(c, 850 * (2 * Math.random() - 1), 0, 300 * (2 * Math.random() - 1)), r.setXYZ(c, Math.random()), s.setXYZ(c, 2 * Math.random() + 1);
						t.addAttribute("instancePosition", i), t.addAttribute("delay", r), t.addAttribute("rotate", s);
						var u = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vBlink;\n\nconst float duration = 200.0;\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  float now = mod(time + delay * duration, duration) / duration;\n\n  mat4 rotateMat = calcRotateMat4Z(radians(rotate * 360.0) + time * 0.1);\n  vec3 rotatePosition = (rotateMat * vec4(position, 1.0)).xyz;\n\n  vec3 moveRise = vec3(\n    (now * 2.0 - 1.0) * (2500.0 - (delay * 2.0 - 1.0) * 2000.0),\n    (now * 2.0 - 1.0) * 2000.0,\n    sin(radians(time * 50.0 + delay + length(position))) * 30.0\n    );\n  vec3 updatePosition = instancePosition + moveRise + rotatePosition;\n\n  vec3 hsv = vec3(time * 0.1 + delay * 0.2 + length(instancePosition) * 100.0, 0.5 , 0.8);\n  vec3 rgb = convertHsvToRgb(hsv);\n  float blink = (sin(radians(now * 360.0 * 20.0)) + 1.0) * 0.88;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vBlink = blink;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vBlink;\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec4 texColor = texture2D(tex, vUv);\n  vec3 color = (texColor.rgb - vBlink * length(p) * 0.8) * vColor;\n  float opacity = texColor.a * 0.36;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"]),
							transparent: !0,
							depthWrite: !1,
							blending: o.AdditiveBlending
						});
						this.uniforms.tex.value = e, this.obj = new o.Mesh(t, u)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	82: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						imageResolution: {
							type: "v2",
							value: new o.Vector2(2048, 1356)
						},
						texture: {
							type: "t",
							value: null
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						var t = this;
						(new o.TextureLoader).load("/sketch-threejs/img/sketch/glitch/osaka.jpg", function(n) {
							t.uniforms.texture.value = n, t.obj = t.createObj(), e()
						})
					}
				}, {
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 imageResolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec2 ratio = vec2(\n      min((resolution.x / resolution.y) / (imageResolution.x / imageResolution.y), 1.0),\n      min((resolution.y / resolution.x) / (imageResolution.y / imageResolution.x), 1.0)\n    );\n\n  vec2 uv = vec2(\n      vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n      vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n    );\n  gl_FragColor = texture2D(texture, uv);\n}\n"])
						}))
					}
				}, {
					key: "resize",
					value: function() {
						this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	83: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t) {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nconst float interval = 3.0;\n\nvoid main(void){\n  float strength = smoothstep(interval * 0.5, interval, interval - mod(time, interval));\n  vec2 shake = vec2(strength * 8.0 + 0.5) * vec2(\n    random(vec2(time)) * 2.0 - 1.0,\n    random(vec2(time * 2.0)) * 2.0 - 1.0\n  ) / resolution;\n\n  float y = vUv.y * resolution.y;\n  float rgbWave = (\n      snoise(vec3(0.0, y * 0.01, time * 400.0)) * (2.0 + strength * 32.0)\n      * snoise(vec3(0.0, y * 0.02, time * 200.0)) * (1.0 + strength * 4.0)\n      + step(0.9995, sin(y * 0.005 + time * 1.6)) * 12.0\n      + step(0.9999, sin(y * 0.005 + time * 2.0)) * -18.0\n    ) / resolution.x;\n  float rgbDiff = (6.0 + sin(time * 500.0 + vUv.y * 40.0) * (20.0 * strength + 1.0)) / resolution.x;\n  float rgbUvX = vUv.x + rgbWave;\n  float r = texture2D(texture, vec2(rgbUvX + rgbDiff, vUv.y) + shake).r;\n  float g = texture2D(texture, vec2(rgbUvX, vUv.y) + shake).g;\n  float b = texture2D(texture, vec2(rgbUvX - rgbDiff, vUv.y) + shake).b;\n\n  float whiteNoise = (random(vUv + mod(time, 10.0)) * 2.0 - 1.0) * (0.15 + strength * 0.15);\n\n  float bnTime = floor(time * 20.0) * 200.0;\n  float noiseX = step((snoise(vec3(0.0, vUv.x * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float noiseY = step((snoise(vec3(0.0, vUv.y * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float bnMask = noiseX * noiseY;\n  float bnUvX = vUv.x + sin(bnTime) * 0.2 + rgbWave;\n  float bnR = texture2D(texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask;\n  float bnG = texture2D(texture, vec2(bnUvX, vUv.y)).g * bnMask;\n  float bnB = texture2D(texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask;\n  vec4 blockNoise = vec4(bnR, bnG, bnB, 1.0);\n\n  float bnTime2 = floor(time * 25.0) * 300.0;\n  float noiseX2 = step((snoise(vec3(0.0, vUv.x * 2.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.5);\n  float noiseY2 = step((snoise(vec3(0.0, vUv.y * 8.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float bnMask2 = noiseX2 * noiseY2;\n  float bnR2 = texture2D(texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask2;\n  float bnG2 = texture2D(texture, vec2(bnUvX, vUv.y)).g * bnMask2;\n  float bnB2 = texture2D(texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask2;\n  vec4 blockNoise2 = vec4(bnR2, bnG2, bnB2, 1.0);\n\n  float waveNoise = (sin(vUv.y * 1200.0) + 1.0) / 2.0 * (0.15 + strength * 0.2);\n\n  gl_FragColor = vec4(r, g, b, 1.0) * (1.0 - bnMask - bnMask2) + (whiteNoise + blockNoise + blockNoise2 - waveNoise);\n}\n"])
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}, {
					key: "resize",
					value: function() {
						this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	84: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = (e("three/build/three.js"), e("gl-matrix")),
			a = e("js-util/MathEx"),
			s = function() {
				function e(t) {
					i(this, e), this.camera = t, this.radian1 = 0, this.radian1Base = 0, this.radian2 = 0, this.radian2Base = 0, this.radius = 2500, this.isZoom = !1
				}
				return r(e, [{
					key: "rotate",
					value: function(e, t) {
						!0 === this.isZoom && (this.isZoom = !1), this.radian1 = a.clamp(this.radian1Base + t, a.radians(-75), a.radians(75)), this.radian2 = this.radian2Base - 2 * e
					}
				}, {
					key: "zoom",
					value: function(e) {
						if (e) {
							!1 === this.isZoom && (this.isZoom = !0);
							var t = this.radius;
							this.radius -= e / Math.abs(e) * 200, this.radius = a.clamp(this.radius, 700, 8e3);
							this.radius
						}
					}
				}, {
					key: "touchEnd",
					value: function() {
						this.radian1Base = this.radian1, this.radian2Base = this.radian2
					}
				}, {
					key: "render",
					value: function() {
						this.camera.anchor = a.spherical(this.radian1, this.radian2, this.radius), this.camera.render()
					}
				}, {
					key: "computeZoomLength",
					value: function() {
						return this.isZoom ? .05 * o.vec3.length(this.camera.acceleration) : 0
					}
				}, {
					key: "computeAcceleration",
					value: function() {
						return .05 * o.vec3.length(this.camera.acceleration)
					}
				}]), e
			}();
		n.default = s
	}, {
		"gl-matrix": 1,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	85: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						cubeTex: {
							type: "t",
							value: null
						}
					}, this.instances = 1e3, this.obj = null
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						this.uniforms.cubeTex.value = e, this.obj = this.createObj()
					}
				}, {
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry,
							t = new o.BoxBufferGeometry(10, 10, 10);
						e.addAttribute("position", t.attributes.position), e.addAttribute("normal", t.attributes.normal), e.setIndex(t.index);
						for (var n = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), i = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), r = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), c = 0, l = i.count; c < l; c++) {
							var u = s.spherical(2 * Math.random() * Math.PI, 2 * Math.random() * Math.PI, 3e3 * Math.random() + 100);
							n.setXYZ(c, u[0], u[1], u[2]), i.setXYZ(c, 100 * Math.random()), r.setXYZ(c, Math.random() - .5, Math.random() - .5, Math.random() - .5)
						}
						return e.addAttribute("translate", n), e.addAttribute("offset", i), e.addAttribute("rotate", r), new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 translate;\nattribute float offset;\nattribute vec3 rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  float radian = radians(time);\n  mat4 rotateWorld = calcRotateMat4(vec3(radian) * vec3(5.0, 20.0, 1.0) + rotate);\n  mat4 rotateSelf = calcRotateMat4(vec3(radian) * rotate * 100.0);\n  vec4 updatePosition =\n    rotateWorld\n    * calcTranslateMat4(translate)\n    * rotateSelf\n    * vec4(position + normalize(position) * offset, 1.0);\n  vPosition = (modelMatrix * updatePosition).xyz;\n  vNormal = (modelMatrix * rotateWorld * rotateSelf * vec4(normal, 1.0)).xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\nuniform samplerCube cubeTex;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 ref = reflect(vPosition - cameraPosition, vNormal);\n  vec4 envColor = textureCube(cubeTex, ref);\n  gl_FragColor = envColor * vec4(0.8, 1.0, 0.95, 0.7);\n}\n"]),
							transparent: !0,
							side: o.DoubleSide
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	86: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t) {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						texture: {
							type: "t",
							value: t
						},
						strengthZoom: {
							type: "f",
							value: 0
						},
						strengthGlitch: {
							type: "f",
							value: 0
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\nuniform float strengthZoom;\nuniform float strengthGlitch;\n\nvarying vec2 vUv;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main(void){\n  // zoom blur\n  vec2 tFrag = 1.0 / resolution;\n  float nFrag = 1.0 / 30.0;\n  vec2 centerOffset = resolution / 2.0;\n  vec3 destColor = vec3(0.0);\n  vec2 fcc = gl_FragCoord.xy - centerOffset;\n  float totalWeight = 0.0;\n\n  for(float i = 0.0; i <= 30.0; i++){\n    float percent = (i + random(gl_FragCoord.xy)) * nFrag;\n    float weight = percent - percent * percent;\n    vec2  t = gl_FragCoord.xy - fcc * percent * strengthZoom * nFrag;\n    destColor += texture2D(texture, t * tFrag).rgb * weight;\n    totalWeight += weight;\n  }\n  vec4 zoomColor = vec4(destColor / totalWeight, 1.0);\n\n  // glitch\n  float strengthWhiteNoise = min(strengthGlitch * 0.05, 0.1);\n  float whiteNoise = (random(gl_FragCoord.xy + time) * 2.0 - 1.0) * (0.05 + strengthWhiteNoise);\n\n  float strengthBlockNoise = min(strengthGlitch * 0.15, 1.2);\n  float noiseX = step((snoise(vec3(0.0, gl_FragCoord.x / resolution.x * 1.0, time * 600.0)) + 1.0) / 2.0, strengthBlockNoise * 0.6);\n  float noiseY = step((snoise(vec3(0.0, gl_FragCoord.y / resolution.y * 3.0, time * 200.0)) + 1.0) / 2.0, strengthBlockNoise * 0.3);\n  float blockNoiseMask = noiseX * noiseY;\n  vec4 blockNoise = texture2D(texture, 1.0 - vUv) * blockNoiseMask;\n\n  gl_FragColor = zoomColor + whiteNoise + blockNoise;\n}\n"])
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}, {
					key: "resize",
					value: function() {
						this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	87: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						cubeTex: {
							type: "t",
							value: null
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						this.uniforms.cubeTex.value = e, this.obj = this.createObj()
					}
				}, {
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.BoxBufferGeometry(3e4, 3e4, 3e4, 1, 1, 1), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nvoid main(void) {\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform samplerCube cubeTex;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  vec3 normal = normalize(vPosition);\n  vec4 color = textureCube(cubeTex, normal);\n  gl_FragColor = color;\n}\n"]),
							side: o.BackSide
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	88: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.SphereBufferGeometry(1e4, 128, 128),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 hsv1 = vec3(0.0, 0.6, 0.4);\nconst vec3 hsv2 = vec3(0.24, 0.6, 0.4);\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 rgb = convertHsvToRgb(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float noise = random(vUv) * 0.08;\n\n  gl_FragColor = vec4(vColor + noise, 1.0);\n}\n"]),
								side: o.BackSide
							});
						this.obj = new o.Mesh(e, t)
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	89: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e() {
					i(this, e), this.durationTransform = .8, this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						timeTransform: {
							type: "f",
							value: this.durationTransform
						},
						durationTransform: {
							type: "f",
							value: this.durationTransform
						},
						prevIndex: {
							type: "f",
							value: 1
						},
						nextIndex: {
							type: "f",
							value: 0
						}
					}, this.isTransform = !1, this.obj = null, this.objWire = null, this.objPoints = null
				}
				return r(e, [{
					key: "createObj",
					value: function(e) {
						var t = {
								font: e,
								size: 300,
								height: 0,
								curveSegments: 1
							},
							n = [new o.TextBufferGeometry("My Love", t), new o.TextBufferGeometry("I love you!", t)],
							i = new o.BufferGeometry,
							r = 0;
						n.map(function(e, t) {
							e.center(), e.attributes.position.count > r && (r = e.attributes.position.count)
						}), n.map(function(e, t) {
							var n = t > 0 ? t + 1 : "";
							if (e.attributes.position.count < r) {
								for (var a = e.attributes.position.array, s = [], c = [], l = 0; l < 3 * r; l += 3)
									if (l < (3 * r - a.length) / 2) s[l] = 700 * (2 * Math.random() - 1), s[l + 1] = 250 * (2 * Math.random() - 1), s[l + 2] = 250 * (2 * Math.random() - 1), c[l / 3] = 0;
									else if (l >= a.length + (3 * r - a.length) / 2) s[l] = 700 * (2 * Math.random() - 1), s[l + 1] = 250 * (2 * Math.random() - 1), s[l + 2] = 250 * (2 * Math.random() - 1), c[l / 3] = 0;
								else {
									var u = l - (3 * r - a.length) / 2;
									s[l] = e.attributes.position.array[u], s[l + 1] = e.attributes.position.array[u + 1], s[l + 2] = e.attributes.position.array[u + 2], c[l / 3] = 1
								}
								i.addAttribute("position" + n, new o.Float32BufferAttribute(s, 3, 1)), i.addAttribute("opacity" + n, new o.Float32BufferAttribute(c, 1, 1))
							} else {
								for (var h = [], l = 0; l < r; l++) h[l] = 1;
								i.addAttribute("position" + n, e.attributes.position), i.addAttribute("opacity" + n, new o.Float32BufferAttribute(h, 1, 1)), i.addAttribute("normal", e.attributes.normal), i.addAttribute("uv", e.attributes.uv), i.setIndex(e.index)
							}
						});
						var s = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute vec2 uv;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vPosition = mixPosition;\n  vUv = uv;\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"]),
								depthWrite: !1,
								transparent: !0,
								flatShading: !0
							}),
							c = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute vec2 uv;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vPosition = mixPosition;\n  vUv = uv;\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"]),
								depthWrite: !1,
								transparent: !0,
								wireframe: !0
							}),
							l = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying float vOpacity;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main() {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 8.0;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  // Round the point\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"]),
								depthWrite: !1,
								transparent: !0
							});
						this.obj = new o.Mesh(i, s), this.objWire = new o.Mesh(i, c), this.objPoints = new o.Points(i, l)
					}
				}, {
					key: "transform",
					value: function() {
						this.isTransform = !0, this.uniforms.timeTransform.value = 0, this.uniforms.prevIndex.value = this.uniforms.prevIndex.value < 1 ? this.uniforms.prevIndex.value + 1 : 0, this.uniforms.nextIndex.value = this.uniforms.nextIndex.value < 1 ? this.uniforms.nextIndex.value + 1 : 0
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e, this.isTransform && (this.uniforms.timeTransform.value = s.clamp(this.uniforms.timeTransform.value + e, 0, this.durationTransform)), this.uniforms.timeTransform.value === this.durationTransform && (this.isTransform = !1)
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	90: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("../../../modules/common/PhysicsRenderer")),
			a = e("three/build/three.js"),
			s = e("glslify"),
			c = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						velocity: {
							type: "t",
							value: null
						},
						acceleration: {
							type: "t",
							value: null
						}
					}, this.physicsRenderer = null, this.vectorTouchMove = new a.Vector2(0, 0), this.vectorTouchMoveDiff = new a.Vector2(0, 0), this.obj = null
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						this.obj = this.createObj(e)
					}
				}, {
					key: "createObj",
					value: function(e) {
						for (var t = window.innerWidth > 768 ? 7 : 6, n = new a.OctahedronBufferGeometry(100, t), i = n.attributes.position.array, r = [], c = 0; c < i.length; c += 3) r[c + 0] = i[c + 0] + 10 * (2 * Math.random() - 1), r[c + 1] = i[c + 1] + 10 * (2 * Math.random() - 1), r[c + 2] = i[c + 2] + 10 * (2 * Math.random() - 1);
						return this.physicsRenderer = new o.default(s(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]), s(['#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform float time;\nuniform vec2 vTouchMove;\n\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n#ifndef PRECISION\n#define PRECISION 0.000001\n#endif\n\nvec3 drag(vec3 a, float value) {\n  return normalize(a * -1.0 + PRECISION) * length(a) * value;\n}\n\nvoid main(void) {\n  vec3 v = texture2D(velocity, vUv).xyz;\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  float noise = sqrt(length(v)) * 10.0;\n  vec3 d = drag(a, 0.028);\n  float fx = cnoise(vec3(time * 0.1, v.y / noise, v.z / noise));\n  float fy = cnoise(vec3(v.x / noise, time * 0.1, v.z / noise));\n  float fz = cnoise(vec3(v.x / noise, v.y / noise, time * 0.1));\n  vec3 f1 = vec3(fx, fy, fz) * 0.24;\n  vec3 f2 = vec3(vTouchMove * 16.0 * (resolution / 640.0), 0.0);\n  vec3 f3 = a + f1 + f2 + d;\n  float vStep = 1.0 - step(1000.0, length(v + f3));\n  gl_FragColor = vec4(f3 * vStep, 1.0);\n}\n']), s(["#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]), s(["#define GLSLIFY 1\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform float time;\n\nvarying vec2 vUv;\n\nvec3 spherical(float radian1, float radian2, float radius) {\n  return vec3(\n    cos(radian1) * cos(radian2) * radius,\n    sin(radian1) * radius,\n    cos(radian1) * sin(radian2) * radius\n  );\n}\n\nconst float radius = 100.0;\n\nvoid main(void) {\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  vec3 v = texture2D(velocity, vUv).xyz;\n  float vStep = step(0.000001, length(a));\n  gl_FragColor = vec4(\n    (a + v) * vStep + normalize(v + spherical(time, -time, 1.0)) * radius * (1.0 - vStep),\n    1.0\n  );\n}\n"])), this.physicsRenderer.init(e, r), this.physicsRenderer.mergeAUniforms({
							vTouchMove: {
								type: "v2",
								value: this.vectorTouchMoveDiff
							}
						}), this.uniforms.velocity.value = this.physicsRenderer.getCurrentVelocity(), this.uniforms.acceleration.value = this.physicsRenderer.getCurrentAcceleration(), n.addAttribute("uvVelocity", this.physicsRenderer.getBufferAttributeUv()), new a.Points(n, new a.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: s(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uvVelocity;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform sampler2D acceleration;\nuniform sampler2D velocity;\n\nvarying vec3 vAcceleration;\n\nvoid main() {\n  vec3 a = texture2D(acceleration, uvVelocity).xyz;\n  vec3 v = texture2D(velocity, uvVelocity).xyz;\n  vec4 mvPosition = modelViewMatrix * vec4(v, 1.0);\n  vAcceleration = a;\n  gl_PointSize = 1.2 * (1200.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: s(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vAcceleration;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float start = smoothstep(time, 0.0, 1.0);\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  float aLength = length(vAcceleration);\n  vec3 color = convertHsvToRgb(vec3(aLength * 0.08 + time * 0.05, 0.5, 0.8));\n  gl_FragColor = vec4(color, 0.4 * start);\n}\n"]),
							transparent: !0,
							depthWrite: !1,
							blending: a.AdditiveBlending
						}))
					}
				}, {
					key: "render",
					value: function(e, t) {
						this.physicsRenderer.render(e, t), this.uniforms.time.value += t
					}
				}, {
					key: "touchStart",
					value: function(e) {
						this.vectorTouchMove.copy(e)
					}
				}, {
					key: "touchMove",
					value: function(e) {
						this.vectorTouchMoveDiff.set(e.x - this.vectorTouchMove.x, e.y - this.vectorTouchMove.y), this.vectorTouchMove.copy(e)
					}
				}, {
					key: "touchEnd",
					value: function() {
						this.vectorTouchMove.set(0, 0), this.vectorTouchMoveDiff.set(0, 0)
					}
				}, {
					key: "resize",
					value: function() {
						this.physicsRenderer && this.physicsRenderer.resize()
					}
				}]), e
			}();
		n.default = c
	}, {
		"../../../modules/common/PhysicsRenderer": 40,
		glslify: 2,
		"three/build/three.js": 8
	}],
	91: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n) {
					i(this, e), this.uniforms = {
						texture1: {
							type: "t",
							value: t
						},
						texture2: {
							type: "t",
							value: n
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * 0.6 + color2;\n}\n"])
						}))
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	92: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n, r) {
					i(this, e), this.uniforms = {
						resolution: {
							type: "v2",
							value: new o.Vector2(document.body.clientWidth, window.innerHeight)
						},
						direction: {
							type: "v2",
							value: new o.Vector2(n, r)
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, 1.0, resolution, direction);\n  gl_FragColor = color;\n}\n"])
						}))
					}
				}, {
					key: "resize",
					value: function() {
						this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	93: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t) {
					i(this, e), this.uniforms = {
						minBright: {
							type: "f",
							value: .3
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(2, 2), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n"])
						}))
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	94: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						colorH: {
							type: "f",
							value: 0
						},
						noiseRange: {
							type: "f",
							value: 0
						}
					}, this.obj = this.createObj(), this.obj.visible = !1
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(1500, 1500), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float colorH;\nuniform float noiseRange;\n\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main() {\n  float t1 = exponentialOut(min(time, 1.0) / 1.0);\n  float t2 = exponentialOut(clamp(time - 14.0, 0.0, 1.0) / 1.0);\n  vec2 pos = vUv * 2.0 - vec2(1.0);\n  float circleOut = smoothstep(0.0, 0.5, t1 - t2 - length(pos));\n  float circleIn = smoothstep(0.0, 0.5, (t1 - t2) * 0.5 - length(pos));\n  float noise = (snoise(vec3(pos * (1.4 + noiseRange * 0.1) + vec2(sin(time), cos(time)), time + noiseRange * 100.0)) + 1.0) / 2.0;\n  float mask = circleOut * noise + circleIn;\n  float opacity = 1.0 - step(mask, 0.3);\n  float h1 = step(mask, 0.99) * 0.4 - time * 0.05;\n  float h2 = step(mask, 0.4) * 0.5;\n  vec3 hsv = vec3(h1 - h2 + colorH, 0.45, 0.8);\n  vec3 rgb = convertHsvToRgb(hsv);\n  gl_FragColor = vec4(rgb, opacity);\n}\n"]),
							transparent: !0
						}))
					}
				}, {
					key: "show",
					value: function(e) {
						this.uniforms.time.value = 0, this.uniforms.colorH.value = Math.random(), this.uniforms.noiseRange.value = 3 * Math.random(), this.obj.visible = !0, this.obj.position.set((2 * Math.random() - 1) * window.innerWidth, (2 * Math.random() - 1) * window.innerHeight, 0)
					}
				}, {
					key: "render",
					value: function(e) {
						this.obj.visible && (this.uniforms.time.value += e, this.obj.position.z -= 3)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	95: [function(e, t, n) {
		"use strict";

		function i(e) {
			return e && e.__esModule ? e : {
				default: e
			}
		}

		function r(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var o = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			a = i(e("../../common/force3")),
			s = i(e("./Core")),
			c = i(e("./Wire")),
			l = (e("three/build/three.js"), e("glslify"), e("js-util/MathEx"), e("js-util/debounce"), function() {
				function e() {
					r(this, e), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.instances = 36, this.core = new s.default(this.instances), this.wire = new c.default(this.instances)
				}
				return o(e, [{
					key: "updateRotation",
					value: function() {
						a.default.applyHook(this.velocity, this.acceleration, this.anchor, 0, .02), a.default.applyDrag(this.acceleration, .3), a.default.updateVelocity(this.velocity, this.acceleration, 1), this.core.uniforms.rotate.value = this.velocity[0], this.wire.uniforms.rotate.value = this.velocity[0]
					}
				}, {
					key: "rotate",
					value: function(e) {
						e && (this.anchor[0] -= .05 * e)
					}
				}, {
					key: "picked",
					value: function(e) {
						this.core.uniforms.pickedId.value = e, this.wire.uniforms.pickedId.value = e, e < this.instances && e > -1 ? document.body.classList.add("is-picked") : document.body.classList.remove("is-picked")
					}
				}, {
					key: "render",
					value: function(e) {
						this.core.uniforms.time.value += e, this.wire.render(e), this.updateRotation()
					}
				}]), e
			}());
		n.default = l
	}, {
		"../../common/force3": 41,
		"./Core": 96,
		"./Wire": 99,
		glslify: 2,
		"js-util/MathEx": 3,
		"js-util/debounce": 4,
		"three/build/three.js": 8
	}],
	96: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e(t) {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						rotate: {
							type: "f",
							value: 0
						},
						pickedId: {
							type: "f",
							value: -1
						}
					}, this.instances = t, this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry,
							t = new o.OctahedronBufferGeometry(30, 4);
						e.addAttribute("position", t.attributes.position), e.addAttribute("normal", t.attributes.normal), e.setIndex(t.index);
						for (var n = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), i = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), r = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), c = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), l = 0; l < this.instances; l++) n.setXYZ(l, s.radians(l / this.instances * 360)), i.setXYZ(l, l / this.instances - .25, .2, .9), r.setXYZ(l, Math.random()), c.setXYZ(l, .5 * (Math.random() + 1));
						return e.addAttribute("radian", n), e.addAttribute("hsv", i), e.addAttribute("noiseDiff", r), e.addAttribute("speed", c), new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float radian;\nattribute vec3 hsv;\nattribute float noiseDiff;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main(void) {\n  float noise = snoise(position * 0.02 + time * speed + noiseDiff);\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 translateMat = calcTranslateMat4(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * vec4(\n    position + normalize(position) * noise * 5.0,\n    1.0\n    );\n  vPosition = updatePosition.xyz;\n  vNormal = normal;\n  vColor = convertHsvToRgb(hsv);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\n\nconst vec3 light = vec3(0.7);\n\nvoid main() {\n  float diff = (dot(vNormal, light) + 1.0) / 2.0 * 0.25 + 0.75;\n  float opacity = (1.0 - (vPosition.z / 1000.0)) * 0.8 + 0.2;\n  gl_FragColor = vec4(vColor * diff, opacity);\n}\n"]),
							transparent: !0
						}))
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	97: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.mirrorCamera = new o.PerspectiveCamera(24, document.body.clientWidth / window.innerHeight, 1, 15e3), this.mirrorRender = new o.WebGLRenderTarget(document.body.clientWidth, window.innerHeight), this.textureMatrix = new o.Matrix4, this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						texture: {
							type: "t",
							value: this.mirrorRender.texture
						},
						textureMatrix: {
							type: "m4",
							value: this.textureMatrix
						},
						mirrorPosition: {
							type: "v3",
							value: this.mirrorCamera.position
						}
					}, this.mirrorCamera.up.set(0, -1, 0), this.obj = this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						return new o.Mesh(new o.PlaneBufferGeometry(4e3, 4e3), new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying mat4 vInvertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vPosition = worldPosition.xyz;\n  vNormal = normal;\n  vUv = textureMatrix * worldPosition;\n  vInvertMatrix = inverse(modelMatrix);\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec4 projectorColor;\n  if (all(bvec4(vUv.x >= 0.0, vUv.y >= 0.0, vUv.x <= vUv.z, vUv.y <= vUv.z))) {\n    projectorColor = texture2DProj(texture, vUv);\n  }\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 0.35) * projectorColor;\n}\n"]),
							transparent: !0
						}))
					}
				}, {
					key: "updateTextureMatrix",
					value: function() {
						this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
					}
				}, {
					key: "render",
					value: function(e, t, n) {
						this.uniforms.time.value += n, this.updateTextureMatrix(), this.obj.visible = !1, e.render(t, this.mirrorCamera, this.mirrorRender), this.obj.visible = !0
					}
				}, {
					key: "resize",
					value: function() {
						this.mirrorCamera.aspect = document.body.clientWidth / window.innerHeight, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(document.body.clientWidth, window.innerHeight)
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	98: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e() {
					i(this, e), this.cubeCamera = new o.CubeCamera(1, 15e3, 1024), this.instances = 6, this.uniforms = {
						time: {
							type: "f",
							value: 0
						}
					}, this.obj = this.createObj(), this.obj.rotation.set(0, .3 * Math.PI, 0)
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry,
							t = new o.BoxBufferGeometry(40, 1, 10);
						e.addAttribute("position", t.attributes.position), e.addAttribute("normal", t.attributes.normal), e.setIndex(t.index);
						for (var n = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), i = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), r = 0, s = this.instances; r < s; r++) n.setXYZ(r, 150 * (r + 1) + 200), i.setXYZ(r, 120 * (r - (this.instances - 1) / 2));
						return e.addAttribute("height", n), e.addAttribute("offsetX", i), new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float height;\nattribute float offsetX;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  mat4 translateMat = calcTranslateMat4(vec3(offsetX, 0.0, 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(1.0, (position.y + 0.5) * height, 1.0));\n  vec4 updatePosition = scaleMat * translateMat * vec4(position, 1.0);\n  vPosition = (modelMatrix * updatePosition).xyz;\n  vInvertMatrix = inverse(modelMatrix);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 light = vec3(-0.7, 0.7, -0.7);\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2 + 0.8;\n  gl_FragColor = vec4(vec3(0.98) * diff, 1.0);\n}\n"]),
							flatShading: !0
						}))
					}
				}, {
					key: "render",
					value: function(e, t, n) {
						this.uniforms.time.value += n, this.obj.visible = !1, this.cubeCamera.update(e, t), this.obj.visible = !0
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	99: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = (function(e) {
				e && e.__esModule
			}(e("../../common/force3")), e("three/build/three.js")),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e(t) {
					i(this, e), this.size = 120, this.baseGeometry = new o.BoxBufferGeometry(this.size, this.size, this.size), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						rotate: {
							type: "f",
							value: 0
						},
						pickedId: {
							type: "f",
							value: -1
						}
					}, this.instances = t, this.obj = this.createObj(), this.objPicked = this.createObjPicked()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.InstancedBufferGeometry;
						e.addAttribute("position", this.baseGeometry.attributes.position), e.setIndex(this.baseGeometry.index);
						for (var t = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), n = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), i = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), r = 0; r < this.instances; r++) t.setXYZ(r, s.radians(r / this.instances * 360)), n.setXYZ(r, r / this.instances - .25, .2, 1), i.setXYZ(r, 0);
						return e.addAttribute("radian", t), e.addAttribute("hsv", n), e.addAttribute("timeHover", i), new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float radian;\nattribute vec3 hsv;\nattribute float timeHover;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\nvarying mat4 vInvertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  float easeStep = circularOut(timeHover / 0.3);\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(1.0 + easeStep * 0.2));\n  mat4 translateMat = calcTranslateMat4(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * scaleMat * vec4(position, 1.0);\n  vPosition = updatePosition.xyz;\n  vInvertMatrix = inverse(rotateMatWorld * translateMat);\n  vColor = convertHsvToRgb(hsv * vec3(1.0, 1.0 - easeStep, 1.0));\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 vInvertMatrix;\n\nconst vec3 color = vec3(0.9);\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  if(!gl_FrontFacing) {\n      normal = -normal;\n  }\n  vec3 light = normalize(vInvertMatrix * vec4(vec3(-1000.0, 1000.0, -1000.0), 1.0)).xyz;\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2 + 0.8;\n  float opacity = (1.0 - (vPosition.z / 1000.0)) * 0.1 + 0.1;\n  gl_FragColor = vec4(color * diff * vColor, opacity);\n}\n"]),
							depthWrite: !1,
							transparent: !0,
							side: o.DoubleSide,
							flatShading: !0
						}))
					}
				}, {
					key: "createObjPicked",
					value: function() {
						var e = new o.InstancedBufferGeometry;
						e.addAttribute("position", this.baseGeometry.attributes.position), e.setIndex(this.baseGeometry.index);
						for (var t = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), n = new o.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3, 1), i = new o.Color, r = new o.InstancedBufferAttribute(new Float32Array(this.instances), 1, 1), c = 0; c < this.instances; c++) t.setXYZ(c, s.radians(c / this.instances * 360)), i.setHex(c), n.setXYZ(c, i.r, i.g, i.b), r.setXYZ(c, 0);
						return e.addAttribute("radian", t), e.addAttribute("pickedColor", n), e.addAttribute("timeHover", r), new o.Mesh(e, new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute float radian;\nattribute vec3 pickedColor;\nattribute float timeHover;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vColor;\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvoid main(void) {\n  float easeStep = circularOut(timeHover / 0.3);\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(1.0 + easeStep * 0.2));\n  mat4 translateMat = calcTranslateMat4(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * scaleMat * vec4(position, 1.0);\n  vColor = pickedColor;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"])
						}))
					}
				}, {
					key: "render",
					value: function(e) {
						var t = this.obj.geometry.attributes.timeHover,
							n = this.objPicked.geometry.attributes.timeHover;
						this.uniforms.time.value += e;
						for (var i = 0; i < t.array.length; i++) this.uniforms.pickedId.value == i ? (t.array[i] = Math.min(t.array[i] + e, .3), n.array[i] = Math.min(n.array[i] + e, .3)) : (t.array[i] = Math.max(t.array[i] - e, 0), n.array[i] = Math.max(n.array[i] - e, 0));
						t.needsUpdate = !0, n.needsUpdate = !0
					}
				}]), e
			}();
		n.default = c
	}, {
		"../../common/force3": 41,
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	100: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three"),
			a = e("glslify"),
			s = (e("js-util/MathEx"), function() {
				function e() {
					i(this, e), this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						tex: {
							type: "t",
							value: null
						},
						mouse: {
							type: "v3",
							value: new o.Vector3
						}
					}, this.obj = null
				}
				return r(e, [{
					key: "createObj",
					value: function(e) {
						var t = new o.PlaneBufferGeometry(800, 800, 200, 200),
							n = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform vec3 mouse;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n  vec3 subPosition = mouse - mPosition.xyz;\n  float force = (1000.0 - clamp(length(subPosition), 0.0, 1000.0)) / 4.0;\n  mPosition = vec4(mPosition.xyz + force * normalize(-subPosition), 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n  gl_PointSize = 3.0;\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 texColor = texture2D(tex, vUv);\n  gl_FragColor = texColor;\n}\n"]),
								transparent: !0
							});
						this.uniforms.tex.value = e, this.obj = new o.Points(t, n)
					}
				}, {
					key: "render",
					value: function(e, t, n) {
						this.uniforms.time.value += e;
						var i = new o.Vector3;
						i.set(n.x, n.y, -1), i.unproject(t);
						var r = i.sub(t.position).normalize(),
							a = -t.position.z / r.z,
							s = t.position.clone().add(r.multiplyScalar(a));
						this.uniforms.mouse.value.copy(s)
					}
				}]), e
			}());
		n.default = s
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		three: 8
	}],
	101: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n, r) {
					i(this, e), this.size = 280, this.interval = 1.2, this.uniforms = {
						index: {
							type: "f",
							value: t
						},
						time: {
							type: "f",
							value: 0
						},
						timeTransform: {
							type: "f",
							value: 0
						},
						interval: {
							type: "f",
							value: this.interval
						},
						size: {
							type: "f",
							value: this.size
						},
						texButterfly: {
							type: "t",
							value: n
						},
						texPicture: {
							type: "t",
							value: r
						},
						colorH: {
							type: "f",
							value: .08
						}
					}, this.obj = null, this.isTransform = !1, this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.PlaneBufferGeometry(this.size, this.size / 2, 64, 32),
							t = new o.SphereBufferGeometry(.1 * this.size, 64, 32, -.5 * Math.PI, 2 * Math.PI),
							n = new o.PlaneBufferGeometry(1.1 * this.size, .55 * this.size, 64, 32);
						e.addAttribute("spherePosition", t.attributes.position), e.addAttribute("squarePosition", n.attributes.position);
						var i = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(['#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 spherePosition;\nattribute vec3 squarePosition;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float index;\nuniform float time;\nuniform float timeTransform;\nuniform float interval;\nuniform float size;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vStep1;\nvarying float vStep2;\nvarying float vStep3;\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main() {\n  // Calcurate time of tranforming\n  float t = timeTransform / interval;\n  float transformTime1 = max((1.0 - t) * 2.0 - 1.0, 0.0);\n  float transformTime2 = min((t) * 2.0, 1.0) * min((1.0 - t) * 2.0, 1.0);\n  float transformTime3 = max((t) * 2.0 - 1.0, 0.0);\n\n  // Position of Butterfly\n  float flapTime = radians(sin(time * 4.0 - length(position.xy) / size * 2.0 + index * 2.0) * 45.0 + 30.0);\n  vec3 flapPosition = vec3(\n    cos(flapTime) * position.x,\n    position.y + sin(time) * 10.0,\n    sin(flapTime) * abs(position.x) + sin(time) * 10.0\n  );\n  mat4 flapRotateMat = calcRotateMat4(vec3(radians(45.0), 0.0, 0.0));\n  vec3 position1 = (flapRotateMat * vec4(flapPosition, 1.0)).xyz;\n\n  // Position of Sphere on transforming\n  float sphereNoise = cnoise(spherePosition * 0.02 + time * 2.4);\n  vec3 sphereNoisePosition = normalize(spherePosition) * sphereNoise * 30.0;\n  mat4 sphereRotateMat = calcRotateMat4(vec3(t * 4.0, 0.0, 0.0));\n  vec3 position2 = (sphereRotateMat * vec4(spherePosition + sphereNoisePosition, 1.0)).xyz;\n\n  // Position of Picture\n  mat4 pictureRotateMat = calcRotateMat4(vec3(0.0, radians(45.0), 0.0));\n  vec3 position3 = (pictureRotateMat * vec4(squarePosition, 1.0)).xyz;;\n\n  // Total of All Position\n  vec3 updatePosition = position1 * exponentialInOut(transformTime1) + position2 * exponentialInOut(transformTime2) + position3 * exponentialInOut(transformTime3);\n\n  // varying\n  vPosition = updatePosition;\n  vUv = uv;\n  vStep1 = clamp((1.0 - t) * 6.0 - 2.0, 0.0, 1.0);\n  vStep2 = clamp((t) * 6.0 - 1.0, 0.0, 1.0) * clamp((1.0 - t) * 6.0 - 1.0, 0.0, 1.0);\n  vStep3 = clamp((t) * 6.0 - 3.0, 0.0, 1.0);\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n}\n']),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float size;\nuniform sampler2D texButterfly;\nuniform sampler2D texPicture;\nuniform float colorH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vStep1;\nvarying float vStep2;\nvarying float vStep3;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float rgbDiff = 0.01;\n\nvoid main() {\n  // Glitch Noise.\n  float bnStrength = sin(time) * 0.05;\n  float bnTime = floor(time * 18.0) * 200.0;\n  float noiseX = step(0.87 + bnStrength, (snoise(vec3(0.0, vUv.x * 1.8, bnTime)) + 1.0) / 2.0);\n  float noiseY = step(0.87 + bnStrength, (snoise(vec3(0.0, vUv.y * 4.2, bnTime)) + 1.0) / 2.0);\n  float bnMask = noiseX * noiseY;\n  float bnUvX = mod(vUv.x + sin(bnTime) + rgbDiff, 1.0);\n  vec4 bnDiff = (1.0 - texture2D(texPicture, vec2(bnUvX, vUv.y))) * bnMask;\n\n  // White Noise.\n  float whiteNoise = (random(vUv + mod(time, 10.0)) * 2.0 - 1.0) * 0.15;\n  vec4 wnColor = vec4(vec3(whiteNoise), 0.0);\n\n  // Color Noise for BUterfly.\n  float noise = snoise(vPosition / vec3(size * 0.25) + vec3(0.0, 0.0, time));\n  vec3 hsv = vec3(colorH + noise * 0.2, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // Butterly Color.\n  vec4 texButterflyColor = texture2D(texButterfly, vUv);\n  vec4 color1 = vec4(rgb, 1.0) * texButterflyColor;\n\n  // Sphere color on transforming.\n  vec4 color2 = vec4(rgb, 1.0) * vec4((1.0 - texButterflyColor.rgb * 0.5), texButterflyColor.a) + wnColor;\n\n  // Picture Color.\n  vec2 pictUv = vUv * 1.1 - 0.05;\n  vec4 texPictureColor = texture2D(texPicture, pictUv);\n  float pictAlpha = step(0.0, pictUv.x) * (1.0 - step(1.0, pictUv.x)) * step(0.0, pictUv.y) * (1.0 - step(1.0, pictUv.y));\n  vec4 pictColor = texPictureColor * (1.0 - bnMask) * vec4(vec3(1.0), pictAlpha);\n  vec4 bnColor = vec4(bnDiff.rgb * 1.2, bnMask);\n  vec4 color3 = pictColor + bnColor + wnColor;\n\n  // total of colors.\n  vec4 color = (color1 * vStep1 + color2 * vStep2) + color3 * vStep3;\n\n  if (color.a < 0.5) discard;\n\n  gl_FragColor = color;\n}\n"]),
							side: o.DoubleSide,
							transparent: !0
						});
						this.obj = new o.Mesh(e, i), this.obj.position.y = .3 * this.size, this.obj.renderOrder = 10
					}
				}, {
					key: "render",
					value: function(e, t) {
						this.uniforms.time.value += t, this.uniforms.timeTransform.value < this.interval && !0 === this.isTransform ? this.uniforms.timeTransform.value = Math.min(this.uniforms.timeTransform.value + t, this.interval) : this.uniforms.timeTransform.value > 0 && !1 === this.isTransform && (this.uniforms.timeTransform.value = Math.max(this.uniforms.timeTransform.value - t, 0))
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	102: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = function(e) {
				return e && e.__esModule ? e : {
					default: e
				}
			}(e("./PostEffectBlur.js")),
			a = e("three/build/three.js"),
			s = e("glslify"),
			c = function() {
				function e(t) {
					i(this, e), this.mirrorCamera = new a.PerspectiveCamera(30, t.x / t.y, 1, 15e3), this.mirrorRender = new a.WebGLRenderTarget(t.x, t.y), this.textureMatrix = new a.Matrix4, this.uniforms = {
						time: {
							type: "f",
							value: 0
						},
						texture: {
							type: "t",
							value: this.mirrorRender.texture
						},
						textureMatrix: {
							type: "m4",
							value: this.textureMatrix
						}
					}, this.renderBack1 = new a.WebGLRenderTarget(t.x, t.y), this.renderBack2 = new a.WebGLRenderTarget(t.x, t.y), this.postEffectBlurX = new o.default(this.renderBack1.texture, 1, 0, 4), this.postEffectBlurY = new o.default(this.renderBack2.texture, 0, 1, 4), this.mirrorCamera.up.set(0, -1, 0), this.obj = null, this.createObj()
				}
				return r(e, [{
					key: "add",
					value: function(e, t) {
						t.add(this.obj), e.add(this.postEffectBlurX.obj), e.add(this.postEffectBlurY.obj)
					}
				}, {
					key: "createObj",
					value: function() {
						var e = new a.PlaneBufferGeometry(4e3, 4e3),
							t = new a.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: s(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec3 vPosition;\nvarying vec4 vUv;\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = worldPosition.xyz;\n  vUv = textureMatrix * worldPosition;\n\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"]),
								fragmentShader: s(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec4 vUv;\n\nconst float mirrorOpacity = 0.2;\n\nvoid main() {\n  float opacity = 1.0 - length(vPosition - cameraPosition) / 700.0;\n\n  vec4 mirrorColor = vec4(vec3(0.9), 1.0) * (1.0 - mirrorOpacity);\n\n  vec4 projectorColor = texture2DProj(texture, vUv) * mirrorOpacity;\n\n  gl_FragColor = (mirrorColor + projectorColor) * vec4(vec3(1.0), opacity);\n}\n"]),
								transparent: !0
							});
						this.obj = new a.Mesh(e, t), this.obj.rotation.set(-.5 * Math.PI, 0, 0)
					}
				}, {
					key: "updateTextureMatrix",
					value: function() {
						this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
					}
				}, {
					key: "render",
					value: function(e, t, n, i, r) {
						this.uniforms.time.value += r, this.updateTextureMatrix(), this.obj.visible = !1, e.render(n, this.mirrorCamera, this.renderBack1), this.obj.visible = !0, this.postEffectBlurX.render(e, t, i, this.renderBack2), this.postEffectBlurY.render(e, t, i, this.mirrorRender)
					}
				}, {
					key: "resize",
					value: function(e) {
						this.mirrorCamera.aspect = e.x / e.y, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(e.x, e.y), this.renderBack1.setSize(e.x, e.y), this.renderBack2.setSize(e.x, e.y), this.postEffectBlurX.resize(e), this.postEffectBlurY.resize(e)
					}
				}]), e
			}();
		n.default = c
	}, {
		"./PostEffectBlur.js": 105,
		glslify: 2,
		"three/build/three.js": 8
	}],
	103: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = e("js-util/MathEx"),
			c = function() {
				function e(t) {
					i(this, e), this.interval = 4, this.attr = {
						position: new o.BufferAttribute(new Float32Array(3 * t), 3),
						colorH: new o.BufferAttribute(new Float32Array(t), 1),
						index: new o.BufferAttribute(new Float32Array(t), 1),
						opacity: new o.BufferAttribute(new Float32Array(t), 1),
						valid: new o.BufferAttribute(new Float32Array(t), 1)
					}, this.uniforms = {
						size: {
							type: "f",
							value: t
						},
						interval: {
							type: "f",
							value: this.interval
						},
						time: {
							type: "f",
							value: 0
						}
					}, this.butterflies = null, this.butterfliesLengh = 0, this.obj = null, this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						for (var e = new o.BufferGeometry, t = 0; t < this.uniforms.size.value; t++) this.attr.index.setX(t, t);
						e.addAttribute("position", this.attr.position), e.addAttribute("colorH", this.attr.colorH), e.addAttribute("i", this.attr.index), e.addAttribute("opacity", this.attr.opacity), e.addAttribute("valid", this.attr.valid);
						var n = new o.RawShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute float colorH;\nattribute float i;\nattribute float opacity;\nattribute float valid;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float size;\nuniform float interval;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float thisTime = mod(time + i / size * interval, interval);\n\n  vec3 updatePosition = position + vec3(\n    cos(thisTime * 3.0 + i) * 3.0,\n    thisTime * -20.0,\n    sin(thisTime * 3.0 + i) * 3.0\n  );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vec3 hsv = vec3(colorH + sin(i) * 0.075, 0.8, 1.0);\n\n  vColor = convertHsvToRgb(hsv);\n  vOpacity = (\n    smoothstep(interval * 0.0, interval * 0.1, thisTime)\n    * (1.0 - smoothstep(interval * 0.2, interval * 0.9, thisTime))\n  ) * opacity;\n\n  gl_PointSize = 5000.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
							fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity * 0.5);\n}\n"]),
							depthWrite: !1,
							transparent: !0
						});
						this.obj = new o.Points(e, n), this.obj.renderOrder = 20
					}
				}, {
					key: "addButterflies",
					value: function(e) {
						this.butterflies = e, this.butterfliesLengh = e.length
					}
				}, {
					key: "render",
					value: function(e) {
						this.uniforms.time.value += e;
						for (var t = 0; t < this.uniforms.size.value; t++) {
							var n = (this.uniforms.time.value + this.attr.index.getX(t) / this.uniforms.size.value * this.interval) % this.interval,
								i = this.attr.valid.getX(t);
							if (n >= .9 * this.interval && 1 == i) this.attr.valid.setX(t, 0);
							else if (n <= .9 * this.interval && 0 == i) {
								var r = Math.floor(Math.random() * this.butterfliesLengh),
									o = this.butterflies[r],
									a = (-90 * Math.random() - 90) * Math.PI / 180,
									c = -180 * Math.random() * Math.PI / 180,
									l = Math.random() * o.uniforms.size.value / 4 + o.uniforms.size.value / 8,
									u = s.spherical(a, c, l),
									h = o.uniforms.timeTransform.value > 0 ? 0 : 1;
								this.attr.position.setXYZ(t, u[0] + o.obj.position.x, .2 * u[1] + o.obj.position.y + 20 * Math.sin(o.uniforms.time.value), .5 * u[2] + o.obj.position.z), this.attr.colorH.setX(t, o.uniforms.colorH.value), this.attr.opacity.setX(t, h), this.attr.valid.setX(t, 1)
							}
						}
						this.attr.position.needsUpdate = !0, this.attr.colorH.needsUpdate = !0, this.attr.opacity.needsUpdate = !0, this.attr.valid.needsUpdate = !0
					}
				}]), e
			}();
		n.default = c
	}, {
		glslify: 2,
		"js-util/MathEx": 3,
		"three/build/three.js": 8
	}],
	104: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n, r) {
					i(this, e), this.uniforms = {
						brightMin: {
							type: "f",
							value: t
						},
						texture1: {
							type: "t",
							value: n
						},
						texture2: {
							type: "t",
							value: r
						}
					}, this.obj = null, this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.PlaneBufferGeometry(2, 2),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float brightMin;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * brightMin + color2;\n}\n"])
							});
						this.obj = new o.Mesh(e, t), this.obj.visible = !1
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.obj.visible = !0, e.render(t, n, i), this.obj.visible = !1
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	105: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n, r, a) {
					i(this, e), this.uniforms = {
						resolution: {
							type: "v2",
							value: new o.Vector2
						},
						direction: {
							type: "v2",
							value: new o.Vector2(n, r)
						},
						radius: {
							type: "f",
							value: a
						},
						texture: {
							type: "t",
							value: t
						}
					}, this.obj = null, this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.PlaneBufferGeometry(2, 2),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n"])
							});
						this.obj = new o.Mesh(e, t), this.obj.visible = !1
					}
				}, {
					key: "resize",
					value: function(e) {
						this.uniforms.resolution.value.set(e.x, e.y)
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.obj.visible = !0, e.render(t, n, i), this.obj.visible = !1
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	106: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("three/build/three.js"),
			a = e("glslify"),
			s = function() {
				function e(t, n) {
					i(this, e), this.uniforms = {
						brightMin: {
							type: "f",
							value: t
						},
						texture: {
							type: "t",
							value: n
						}
					}, this.obj = null, this.createObj()
				}
				return r(e, [{
					key: "createObj",
					value: function() {
						var e = new o.PlaneBufferGeometry(2, 2),
							t = new o.RawShaderMaterial({
								uniforms: this.uniforms,
								vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"]),
								fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float brightMin;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - brightMin));\n  gl_FragColor = bright;\n}\n"])
							});
						this.obj = new o.Mesh(e, t), this.obj.visible = !1
					}
				}, {
					key: "render",
					value: function(e, t, n, i) {
						this.obj.visible = !0, e.render(t, n, i), this.obj.visible = !1
					}
				}]), e
			}();
		n.default = s
	}, {
		glslify: 2,
		"three/build/three.js": 8
	}],
	107: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("../common/Force3").default,
			a = function() {
				function e(t) {
					i(this, e), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.k = t && void 0 !== t.k ? t.k : .3, this.d = t && void 0 !== t.d ? t.d : .7, this.m = t && void 0 !== t.m ? t.m : 1
				}
				return r(e, [{
					key: "render",
					value: function() {
						o.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), o.applyDrag(this.acceleration, this.d), o.updateVelocity(this.velocity, this.acceleration, this.m)
					}
				}]), e
			}();
		n.default = a
	}, {
		"../common/Force3": 38
	}],
	108: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("js-util/MathEx"),
			a = e("js-util/isIE"),
			s = function() {
				function e(t, n, r, o) {
					i(this, e), this.scrollManager = n, this.hookes = r, this.elm = t, this.height = 0, this.top = 0, this.rangeX = o && o.rangeX ? o.rangeX : 1e4, this.ratioX = o && o.ratioX ? o.ratioX : 0, this.unitX = o && o.unitX ? o.unitX : "px", this.rangeY = o && o.rangeY ? o.rangeY : 10, this.ratioY = o && o.ratioY ? o.ratioY : .012, this.unitY = o && o.unitY ? o.unitY : "%"
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						this.elm.style.transform = "";
						var t = this.elm.getBoundingClientRect();
						this.height = t.height, this.top = e + t.top, this.elm.style.backfaceVisibility = "hidden", this.render()
					}
				}, {
					key: "render",
					value: function(e) {
						var t = e ? o.clamp(this.hookes.velocity[0] * this.ratioX, -1 * this.rangeX, this.rangeX) : 0,
							n = e ? o.clamp((this.hookes.velocity[1] - (this.top + .5 * this.height)) * this.ratioY, -1 * this.rangeY, this.rangeY) : 0;
						this.elm.style.transform = a() ? "translate(" + t + this.unitX + ", " + n + this.unitY + ")" : "translate3D(" + t + this.unitX + ", " + n + this.unitY + ", 0)"
					}
				}]), e
			}();
		n.default = s
	}, {
		"js-util/MathEx": 3,
		"js-util/isIE": 6
	}],
	109: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = function() {
				function e(t) {
					i(this, e), this.elm = t, this.elmChildren = t.querySelectorAll(".js-scroll-item-child"), this.top = 0, this.bottom = 0
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						var t = this.elm.getBoundingClientRect();
						this.top = e + t.top, this.bottom = this.top + t.height
					}
				}, {
					key: "show",
					value: function(e, t) {
						if (e > this.top && t < this.bottom) {
							this.elm.classList.add("is-shown");
							for (var n = 0; n < this.elmChildren.length; n++) this.elmChildren[n].classList.add("is-shown")
						}
					}
				}]), e
			}();
		n.default = o
	}, {}],
	110: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("./ScrollItem").default,
			a = e("./SmoothItem").default,
			s = e("./ParallaxItem").default,
			c = function() {
				function e(t) {
					i(this, e), this.scrollManager = t, this.scrollItems = [], this.smoothItems = [], this.parallaxItems = []
				}
				return r(e, [{
					key: "init",
					value: function() {
						var e = document.querySelectorAll(".js-scroll-item"),
							t = document.querySelectorAll(".js-smooth-item"),
							n = document.querySelectorAll(".js-parallax-item");
						this.scrollItems = [], this.smoothItems = [], this.parallaxItems = [];
						for (i = 0; i < e.length; i++) this.scrollItems[i] = new o(e[i], this.scrollManager);
						for (i = 0; i < t.length; i++) this.smoothItems[i] = new a(t[i], this.scrollManager, this.scrollManager.hookes.smooth, t[i].dataset);
						for (var i = 0; i < n.length; i++) this.parallaxItems[i] = new s(n[i], this.scrollManager, this.scrollManager.hookes.parallax, n[i].dataset)
					}
				}, {
					key: "scroll",
					value: function() {
						for (var e = 0; e < this.scrollItems.length; e++) this.scrollItems[e].show(this.scrollManager.scrollTop + this.scrollManager.resolution.y, this.scrollManager.scrollTop)
					}
				}, {
					key: "resize",
					value: function() {
						for (e = 0; e < this.scrollItems.length; e++) this.scrollItems[e].init(this.scrollManager.scrollTop);
						for (e = 0; e < this.smoothItems.length; e++) this.smoothItems[e].init(this.scrollManager.scrollTop);
						for (var e = 0; e < this.parallaxItems.length; e++) this.parallaxItems[e].init(this.scrollManager.scrollTop)
					}
				}, {
					key: "render",
					value: function(e) {
						for (t = 0; t < this.smoothItems.length; t++) this.smoothItems[t].render(e);
						for (var t = 0; t < this.parallaxItems.length; t++) this.parallaxItems[t].render(e)
					}
				}]), e
			}();
		n.default = c
	}, {
		"./ParallaxItem": 108,
		"./ScrollItem": 109,
		"./SmoothItem": 111
	}],
	111: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = function() {
				function e(t, n, r, o) {
					i(this, e), this.scrollManager = n, this.hookes = r, this.elm = t, this.height = 0, this.top = 0, this.max = o && o.max ? o.max : null, this.min = o && o.min ? o.min : null, this.ratio = o && o.ratio ? o.ratio : .1, this.unit = o && o.unit ? o.unit : "px"
				}
				return r(e, [{
					key: "init",
					value: function(e) {
						var t = this.elm.getBoundingClientRect();
						this.height = t.height, this.top = e + t.top, this.elm.style.backfaceVisibility = "hidden"
					}
				}, {
					key: "render",
					value: function(e) {
						var t = 0;
						e && (t = this.hookes.velocity[1] * this.ratio, Math.abs(this.hookes.acceleration[1]) < .01 && (this.hookes.velocity[1] = this.hookes.anchor[1]), this.min && (t = Math.max(t, this.min)), this.max && (t = Math.min(t, this.max))), this.elm.style.transform = "translate3D(0, " + t + this.unit + ", 0)"
					}
				}]), e
			}();
		n.default = o
	}, {}],
	112: [function(e, t, n) {
		"use strict";

		function i(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(n, "__esModule", {
			value: !0
		});
		var r = function() {
				function e(e, t) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
					}
				}
				return function(t, n, i) {
					return n && e(t.prototype, n), i && e(t, i), t
				}
			}(),
			o = e("js-util/debounce"),
			a = e("js-util/isiOS"),
			s = e("js-util/isAndroid"),
			c = e("./Hookes").default,
			l = e("./ScrollItems").default,
			u = document.querySelector(".js-contents"),
			h = document.querySelector(".js-dummy-scroll"),
			d = function() {
				function e() {
					i(this, e), this.scrollItems = new l(this), this.scrollTop = 0, this.scrollFrame = 0, this.scrollTopPause = 0, this.resolution = {
						x: 0,
						y: 0
					}, this.bodyResolution = {
						x: 0,
						y: 0
					}, this.X_SWITCH_SMOOTH = 1024, this.hookes = {}, this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null, this.isWorking = !1, this.isWorkingSmooth = !1, this.isAlreadyAddEvent = !1
				}
				return r(e, [{
					key: "start",
					value: function(e) {
						var t = this;
						setTimeout(function() {
							t.scrollTop = window.pageYOffset, t.initHookes(), t.scrollItems.init();
							var n = location.hash,
								i = n ? document.querySelector(n) : null;
							if (i) {
								var r = i.getBoundingClientRect();
								t.scrollTop + r.top
							}
							t.resize(function() {
								t.scroll(), t.isWorkingSmooth = !0, t.renderLoop(), t.on(), e && e()
							})
						}, 100)
					}
				}, {
					key: "pause",
					value: function() {
						this.isWorking = !1, u.style.position = "fixed", this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.scrollTopPause = this.scrollTop, window.scrollTo(0, this.scrollTop)
					}
				}, {
					key: "play",
					value: function() {
						u.style.position = "", this.scrollTop = this.scrollTopPause, this.resolution.x <= this.X_SWITCH_SMOOTH && (this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = 0), window.scrollTo(0, this.scrollTop), this.isWorking = !0
					}
				}, {
					key: "initDummyScroll",
					value: function() {
						this.resolution.x <= this.X_SWITCH_SMOOTH ? (u.style.transform = "", u.classList.remove("is-fixed"), h.style.height = "0") : (u.classList.add("is-fixed"), h.style.height = u.clientHeight + "px"), this.render()
					}
				}, {
					key: "initHookes",
					value: function() {
						this.hookes = {
							contents: new c({
								k: .575,
								d: .8
							}),
							smooth: new c({
								k: .18,
								d: .75
							}),
							parallax: new c({
								k: .28,
								d: .7
							})
						}
					}
				}, {
					key: "scrollBasis",
					value: function() {
						this.resolution.x > this.X_SWITCH_SMOOTH && (this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.hookes.smooth.velocity[1] += this.scrollFrame, this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y), this.scrollItems.scroll()
					}
				}, {
					key: "scroll",
					value: function(e) {
						if (!1 !== this.isWorking) {
							var t = window.pageYOffset;
							this.scrollFrame = t - this.scrollTop, this.scrollTop = t, this.scrollPrev && this.scrollPrev(), this.scrollBasis(), this.scrollNext && this.scrollNext()
						}
					}
				}, {
					key: "tilt",
					value: function(e) {
						!1 !== this.isWorking && this.resolution.x > this.X_SWITCH_SMOOTH && (this.hookes.parallax.anchor[0] = -100 * (e.clientX / this.resolution.x * 2 - 1))
					}
				}, {
					key: "resizeBasis",
					value: function() {
						this.scrollItems.resize()
					}
				}, {
					key: "resize",
					value: function(e) {
						if (this.isWorking = !1, this.resizeReset && this.resizeReset(), this.scrollTop = window.pageYOffset, this.resolution.x = window.innerWidth, this.resolution.y = window.innerHeight, this.bodyResolution.x = document.body.clientWidth, this.bodyResolution.y = document.body.clientHeight, this.resolution.x > this.X_SWITCH_SMOOTH) this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -this.scrollTop, this.hookes.parallax.velocity[1] = this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y;
						else
							for (var t in this.hookes) switch (t) {
								case "contents":
								case "parallax":
									this.hookes[t].anchor[1] = this.hookes[t].velocity[1] = 0;
									break;
								default:
									this.hookes[t].velocity[1] = 0
							}
						this.resizePrev && this.resizePrev(), this.initDummyScroll(), this.render(), window.scrollTo(0, this.scrollTop), this.resizeBasis(), this.resizeNext && this.resizeNext(), this.isWorking = !0, e && e()
					}
				}, {
					key: "render",
					value: function() {
						this.renderPrev && this.renderPrev();
						var e = Math.floor(1e3 * this.hookes.contents.velocity[1]) / 1e3;
						u.style.transform = "translate3D(0, " + e + "px, 0)";
						for (var t in this.hookes) this.hookes[t].render();
						this.scrollItems.render(this.isValidSmooth()), this.renderNext && this.renderNext()
					}
				}, {
					key: "renderLoop",
					value: function() {
						var e = this;
						this.render(), this.isWorkingSmooth && requestAnimationFrame(function() {
							e.renderLoop()
						})
					}
				}, {
					key: "on",
					value: function() {
						var e = this;
						if (!this.isAlreadyAddEvent) {
							var t = a() || s() ? "orientationchange" : "resize";
							window.addEventListener("scroll", function(t) {
								e.scroll(t)
							}, !1), window.addEventListener("mousemove", function(t) {
								e.tilt(t)
							}, !1), window.addEventListener(t, o(function(t) {
								e.resize()
							}, 400), !1), this.isAlreadyAddEvent = !0
						}
					}
				}, {
					key: "off",
					value: function() {
						this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null
					}
				}, {
					key: "isValidSmooth",
					value: function() {
						return this.isWorkingSmooth && this.resolution.x > this.X_SWITCH_SMOOTH
					}
				}]), e
			}();
		n.default = d
	}, {
		"./Hookes": 107,
		"./ScrollItems": 110,
		"js-util/debounce": 4,
		"js-util/isAndroid": 5,
		"js-util/isiOS": 7
	}]
}, {}, [36]);